/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fluent-ffmpeg";
exports.ids = ["vendor-chunks/fluent-ffmpeg"];
exports.modules = {

/***/ "(rsc)/./node_modules/fluent-ffmpeg/index.js":
/*!*********************************************!*\
  !*** ./node_modules/fluent-ffmpeg/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/fluent-ffmpeg */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/fluent-ffmpeg.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSwwSEFBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtZmlyZWJhc2UtYXBpLy4vbm9kZV9tb2R1bGVzL2ZsdWVudC1mZm1wZWcvaW5kZXguanM/OGUzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2ZsdWVudC1mZm1wZWcnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/capabilities.js":
/*!********************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/capabilities.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path?8ff8\");\nvar async = __webpack_require__(/*! async */ \"(rsc)/./node_modules/async/lib/async.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\");\n\n/*\n *! Capability helpers\n */\n\nvar avCodecRegexp = /^\\s*([D ])([E ])([VAS])([S ])([D ])([T ]) ([^ ]+) +(.*)$/;\nvar ffCodecRegexp = /^\\s*([D\\.])([E\\.])([VAS])([I\\.])([L\\.])([S\\.]) ([^ ]+) +(.*)$/;\nvar ffEncodersRegexp = /\\(encoders:([^\\)]+)\\)/;\nvar ffDecodersRegexp = /\\(decoders:([^\\)]+)\\)/;\nvar encodersRegexp = /^\\s*([VAS\\.])([F\\.])([S\\.])([X\\.])([B\\.])([D\\.]) ([^ ]+) +(.*)$/;\nvar formatRegexp = /^\\s*([D ])([E ])\\s+([^ ]+)\\s+(.*)$/;\nvar lineBreakRegexp = /\\r\\n|\\r|\\n/;\nvar filterRegexp = /^(?: [T\\.][S\\.][C\\.] )?([^ ]+) +(AA?|VV?|\\|)->(AA?|VV?|\\|) +(.*)$/;\n\nvar cache = {};\n\nmodule.exports = function(proto) {\n  /**\n   * Manually define the ffmpeg binary full path.\n   *\n   * @method FfmpegCommand#setFfmpegPath\n   *\n   * @param {String} ffmpegPath The full path to the ffmpeg binary.\n   * @return FfmpegCommand\n   */\n  proto.setFfmpegPath = function(ffmpegPath) {\n    cache.ffmpegPath = ffmpegPath;\n    return this;\n  };\n\n  /**\n   * Manually define the ffprobe binary full path.\n   *\n   * @method FfmpegCommand#setFfprobePath\n   *\n   * @param {String} ffprobePath The full path to the ffprobe binary.\n   * @return FfmpegCommand\n   */\n  proto.setFfprobePath = function(ffprobePath) {\n    cache.ffprobePath = ffprobePath;\n    return this;\n  };\n\n  /**\n   * Manually define the flvtool2/flvmeta binary full path.\n   *\n   * @method FfmpegCommand#setFlvtoolPath\n   *\n   * @param {String} flvtool The full path to the flvtool2 or flvmeta binary.\n   * @return FfmpegCommand\n   */\n  proto.setFlvtoolPath = function(flvtool) {\n    cache.flvtoolPath = flvtool;\n    return this;\n  };\n\n  /**\n   * Forget executable paths\n   *\n   * (only used for testing purposes)\n   *\n   * @method FfmpegCommand#_forgetPaths\n   * @private\n   */\n  proto._forgetPaths = function() {\n    delete cache.ffmpegPath;\n    delete cache.ffprobePath;\n    delete cache.flvtoolPath;\n  };\n\n  /**\n   * Check for ffmpeg availability\n   *\n   * If the FFMPEG_PATH environment variable is set, try to use it.\n   * If it is unset or incorrect, try to find ffmpeg in the PATH instead.\n   *\n   * @method FfmpegCommand#_getFfmpegPath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  proto._getFfmpegPath = function(callback) {\n    if ('ffmpegPath' in cache) {\n      return callback(null, cache.ffmpegPath);\n    }\n\n    async.waterfall([\n      // Try FFMPEG_PATH\n      function(cb) {\n        if (process.env.FFMPEG_PATH) {\n          fs.exists(process.env.FFMPEG_PATH, function(exists) {\n            if (exists) {\n              cb(null, process.env.FFMPEG_PATH);\n            } else {\n              cb(null, '');\n            }\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Search in the PATH\n      function(ffmpeg, cb) {\n        if (ffmpeg.length) {\n          return cb(null, ffmpeg);\n        }\n\n        utils.which('ffmpeg', function(err, ffmpeg) {\n          cb(err, ffmpeg);\n        });\n      }\n    ], function(err, ffmpeg) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.ffmpegPath = (ffmpeg || ''));\n      }\n    });\n  };\n\n\n  /**\n   * Check for ffprobe availability\n   *\n   * If the FFPROBE_PATH environment variable is set, try to use it.\n   * If it is unset or incorrect, try to find ffprobe in the PATH instead.\n   * If this still fails, try to find ffprobe in the same directory as ffmpeg.\n   *\n   * @method FfmpegCommand#_getFfprobePath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  proto._getFfprobePath = function(callback) {\n    var self = this;\n\n    if ('ffprobePath' in cache) {\n      return callback(null, cache.ffprobePath);\n    }\n\n    async.waterfall([\n      // Try FFPROBE_PATH\n      function(cb) {\n        if (process.env.FFPROBE_PATH) {\n          fs.exists(process.env.FFPROBE_PATH, function(exists) {\n            cb(null, exists ? process.env.FFPROBE_PATH : '');\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Search in the PATH\n      function(ffprobe, cb) {\n        if (ffprobe.length) {\n          return cb(null, ffprobe);\n        }\n\n        utils.which('ffprobe', function(err, ffprobe) {\n          cb(err, ffprobe);\n        });\n      },\n\n      // Search in the same directory as ffmpeg\n      function(ffprobe, cb) {\n        if (ffprobe.length) {\n          return cb(null, ffprobe);\n        }\n\n        self._getFfmpegPath(function(err, ffmpeg) {\n          if (err) {\n            cb(err);\n          } else if (ffmpeg.length) {\n            var name = utils.isWindows ? 'ffprobe.exe' : 'ffprobe';\n            var ffprobe = path.join(path.dirname(ffmpeg), name);\n            fs.exists(ffprobe, function(exists) {\n              cb(null, exists ? ffprobe : '');\n            });\n          } else {\n            cb(null, '');\n          }\n        });\n      }\n    ], function(err, ffprobe) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.ffprobePath = (ffprobe || ''));\n      }\n    });\n  };\n\n\n  /**\n   * Check for flvtool2/flvmeta availability\n   *\n   * If the FLVTOOL2_PATH or FLVMETA_PATH environment variable are set, try to use them.\n   * If both are either unset or incorrect, try to find flvtool2 or flvmeta in the PATH instead.\n   *\n   * @method FfmpegCommand#_getFlvtoolPath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n   proto._getFlvtoolPath = function(callback) {\n    if ('flvtoolPath' in cache) {\n      return callback(null, cache.flvtoolPath);\n    }\n\n    async.waterfall([\n      // Try FLVMETA_PATH\n      function(cb) {\n        if (process.env.FLVMETA_PATH) {\n          fs.exists(process.env.FLVMETA_PATH, function(exists) {\n            cb(null, exists ? process.env.FLVMETA_PATH : '');\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Try FLVTOOL2_PATH\n      function(flvtool, cb) {\n        if (flvtool.length) {\n          return cb(null, flvtool);\n        }\n\n        if (process.env.FLVTOOL2_PATH) {\n          fs.exists(process.env.FLVTOOL2_PATH, function(exists) {\n            cb(null, exists ? process.env.FLVTOOL2_PATH : '');\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Search for flvmeta in the PATH\n      function(flvtool, cb) {\n        if (flvtool.length) {\n          return cb(null, flvtool);\n        }\n\n        utils.which('flvmeta', function(err, flvmeta) {\n          cb(err, flvmeta);\n        });\n      },\n\n      // Search for flvtool2 in the PATH\n      function(flvtool, cb) {\n        if (flvtool.length) {\n          return cb(null, flvtool);\n        }\n\n        utils.which('flvtool2', function(err, flvtool2) {\n          cb(err, flvtool2);\n        });\n      },\n    ], function(err, flvtool) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.flvtoolPath = (flvtool || ''));\n      }\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableFilters}.\n   *\n   * @callback FfmpegCommand~filterCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} filters filter object with filter names as keys and the following\n   *   properties for each filter:\n   * @param {String} filters.description filter description\n   * @param {String} filters.input input type, one of 'audio', 'video' and 'none'\n   * @param {Boolean} filters.multipleInputs whether the filter supports multiple inputs\n   * @param {String} filters.output output type, one of 'audio', 'video' and 'none'\n   * @param {Boolean} filters.multipleOutputs whether the filter supports multiple outputs\n   */\n\n  /**\n   * Query ffmpeg for available filters\n   *\n   * @method FfmpegCommand#availableFilters\n   * @category Capabilities\n   * @aliases getAvailableFilters\n   *\n   * @param {FfmpegCommand~filterCallback} callback callback function\n   */\n  proto.availableFilters =\n  proto.getAvailableFilters = function(callback) {\n    if ('filters' in cache) {\n      return callback(null, cache.filters);\n    }\n\n    this._spawnFfmpeg(['-filters'], { captureStdout: true, stdoutLines: 0 }, function (err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      var stdout = stdoutRing.get();\n      var lines = stdout.split('\\n');\n      var data = {};\n      var types = { A: 'audio', V: 'video', '|': 'none' };\n\n      lines.forEach(function(line) {\n        var match = line.match(filterRegexp);\n        if (match) {\n          data[match[1]] = {\n            description: match[4],\n            input: types[match[2].charAt(0)],\n            multipleInputs: match[2].length > 1,\n            output: types[match[3].charAt(0)],\n            multipleOutputs: match[3].length > 1\n          };\n        }\n      });\n\n      callback(null, cache.filters = data);\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableCodecs}.\n   *\n   * @callback FfmpegCommand~codecCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} codecs codec object with codec names as keys and the following\n   *   properties for each codec (more properties may be available depending on the\n   *   ffmpeg version used):\n   * @param {String} codecs.description codec description\n   * @param {Boolean} codecs.canDecode whether the codec is able to decode streams\n   * @param {Boolean} codecs.canEncode whether the codec is able to encode streams\n   */\n\n  /**\n   * Query ffmpeg for available codecs\n   *\n   * @method FfmpegCommand#availableCodecs\n   * @category Capabilities\n   * @aliases getAvailableCodecs\n   *\n   * @param {FfmpegCommand~codecCallback} callback callback function\n   */\n  proto.availableCodecs =\n  proto.getAvailableCodecs = function(callback) {\n    if ('codecs' in cache) {\n      return callback(null, cache.codecs);\n    }\n\n    this._spawnFfmpeg(['-codecs'], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n\n      lines.forEach(function(line) {\n        var match = line.match(avCodecRegexp);\n        if (match && match[7] !== '=') {\n          data[match[7]] = {\n            type: { 'V': 'video', 'A': 'audio', 'S': 'subtitle' }[match[3]],\n            description: match[8],\n            canDecode: match[1] === 'D',\n            canEncode: match[2] === 'E',\n            drawHorizBand: match[4] === 'S',\n            directRendering: match[5] === 'D',\n            weirdFrameTruncation: match[6] === 'T'\n          };\n        }\n\n        match = line.match(ffCodecRegexp);\n        if (match && match[7] !== '=') {\n          var codecData = data[match[7]] = {\n            type: { 'V': 'video', 'A': 'audio', 'S': 'subtitle' }[match[3]],\n            description: match[8],\n            canDecode: match[1] === 'D',\n            canEncode: match[2] === 'E',\n            intraFrameOnly: match[4] === 'I',\n            isLossy: match[5] === 'L',\n            isLossless: match[6] === 'S'\n          };\n\n          var encoders = codecData.description.match(ffEncodersRegexp);\n          encoders = encoders ? encoders[1].trim().split(' ') : [];\n\n          var decoders = codecData.description.match(ffDecodersRegexp);\n          decoders = decoders ? decoders[1].trim().split(' ') : [];\n\n          if (encoders.length || decoders.length) {\n            var coderData = {};\n            utils.copy(codecData, coderData);\n            delete coderData.canEncode;\n            delete coderData.canDecode;\n\n            encoders.forEach(function(name) {\n              data[name] = {};\n              utils.copy(coderData, data[name]);\n              data[name].canEncode = true;\n            });\n\n            decoders.forEach(function(name) {\n              if (name in data) {\n                data[name].canDecode = true;\n              } else {\n                data[name] = {};\n                utils.copy(coderData, data[name]);\n                data[name].canDecode = true;\n              }\n            });\n          }\n        }\n      });\n\n      callback(null, cache.codecs = data);\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableEncoders}.\n   *\n   * @callback FfmpegCommand~encodersCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} encoders encoders object with encoder names as keys and the following\n   *   properties for each encoder:\n   * @param {String} encoders.description codec description\n   * @param {Boolean} encoders.type \"audio\", \"video\" or \"subtitle\"\n   * @param {Boolean} encoders.frameMT whether the encoder is able to do frame-level multithreading\n   * @param {Boolean} encoders.sliceMT whether the encoder is able to do slice-level multithreading\n   * @param {Boolean} encoders.experimental whether the encoder is experimental\n   * @param {Boolean} encoders.drawHorizBand whether the encoder supports draw_horiz_band\n   * @param {Boolean} encoders.directRendering whether the encoder supports direct encoding method 1\n   */\n\n  /**\n   * Query ffmpeg for available encoders\n   *\n   * @method FfmpegCommand#availableEncoders\n   * @category Capabilities\n   * @aliases getAvailableEncoders\n   *\n   * @param {FfmpegCommand~encodersCallback} callback callback function\n   */\n  proto.availableEncoders =\n  proto.getAvailableEncoders = function(callback) {\n    if ('encoders' in cache) {\n      return callback(null, cache.encoders);\n    }\n\n    this._spawnFfmpeg(['-encoders'], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n\n      lines.forEach(function(line) {\n        var match = line.match(encodersRegexp);\n        if (match && match[7] !== '=') {\n          data[match[7]] = {\n            type: { 'V': 'video', 'A': 'audio', 'S': 'subtitle' }[match[1]],\n            description: match[8],\n            frameMT: match[2] === 'F',\n            sliceMT: match[3] === 'S',\n            experimental: match[4] === 'X',\n            drawHorizBand: match[5] === 'B',\n            directRendering: match[6] === 'D'\n          };\n        }\n      });\n\n      callback(null, cache.encoders = data);\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableFormats}.\n   *\n   * @callback FfmpegCommand~formatCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} formats format object with format names as keys and the following\n   *   properties for each format:\n   * @param {String} formats.description format description\n   * @param {Boolean} formats.canDemux whether the format is able to demux streams from an input file\n   * @param {Boolean} formats.canMux whether the format is able to mux streams into an output file\n   */\n\n  /**\n   * Query ffmpeg for available formats\n   *\n   * @method FfmpegCommand#availableFormats\n   * @category Capabilities\n   * @aliases getAvailableFormats\n   *\n   * @param {FfmpegCommand~formatCallback} callback callback function\n   */\n  proto.availableFormats =\n  proto.getAvailableFormats = function(callback) {\n    if ('formats' in cache) {\n      return callback(null, cache.formats);\n    }\n\n    // Run ffmpeg -formats\n    this._spawnFfmpeg(['-formats'], { captureStdout: true, stdoutLines: 0 }, function (err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      // Parse output\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n\n      lines.forEach(function(line) {\n        var match = line.match(formatRegexp);\n        if (match) {\n          match[3].split(',').forEach(function(format) {\n            if (!(format in data)) {\n              data[format] = {\n                description: match[4],\n                canDemux: false,\n                canMux: false\n              };\n            }\n\n            if (match[1] === 'D') {\n              data[format].canDemux = true;\n            }\n            if (match[2] === 'E') {\n              data[format].canMux = true;\n            }\n          });\n        }\n      });\n\n      callback(null, cache.formats = data);\n    });\n  };\n\n\n  /**\n   * Check capabilities before executing a command\n   *\n   * Checks whether all used codecs and formats are indeed available\n   *\n   * @method FfmpegCommand#_checkCapabilities\n   * @param {Function} callback callback with signature (err)\n   * @private\n   */\n  proto._checkCapabilities = function(callback) {\n    var self = this;\n    async.waterfall([\n      // Get available formats\n      function(cb) {\n        self.availableFormats(cb);\n      },\n\n      // Check whether specified formats are available\n      function(formats, cb) {\n        var unavailable;\n\n        // Output format(s)\n        unavailable = self._outputs\n          .reduce(function(fmts, output) {\n            var format = output.options.find('-f', 1);\n            if (format) {\n              if (!(format[0] in formats) || !(formats[format[0]].canMux)) {\n                fmts.push(format);\n              }\n            }\n\n            return fmts;\n          }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Output format ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Output formats ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        // Input format(s)\n        unavailable = self._inputs\n          .reduce(function(fmts, input) {\n            var format = input.options.find('-f', 1);\n            if (format) {\n              if (!(format[0] in formats) || !(formats[format[0]].canDemux)) {\n                fmts.push(format[0]);\n              }\n            }\n\n            return fmts;\n          }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Input format ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Input formats ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        cb();\n      },\n\n      // Get available codecs\n      function(cb) {\n        self.availableEncoders(cb);\n      },\n\n      // Check whether specified codecs are available and add strict experimental options if needed\n      function(encoders, cb) {\n        var unavailable;\n\n        // Audio codec(s)\n        unavailable = self._outputs.reduce(function(cdcs, output) {\n          var acodec = output.audio.find('-acodec', 1);\n          if (acodec && acodec[0] !== 'copy') {\n            if (!(acodec[0] in encoders) || encoders[acodec[0]].type !== 'audio') {\n              cdcs.push(acodec[0]);\n            }\n          }\n\n          return cdcs;\n        }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Audio codec ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Audio codecs ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        // Video codec(s)\n        unavailable = self._outputs.reduce(function(cdcs, output) {\n          var vcodec = output.video.find('-vcodec', 1);\n          if (vcodec && vcodec[0] !== 'copy') {\n            if (!(vcodec[0] in encoders) || encoders[vcodec[0]].type !== 'video') {\n              cdcs.push(vcodec[0]);\n            }\n          }\n\n          return cdcs;\n        }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Video codec ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Video codecs ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        cb();\n      }\n    ], callback);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvY2FwYWJpbGl0aWVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIsU0FBUyxtQkFBTyxDQUFDLGNBQUk7QUFDckIsV0FBVyxtQkFBTyxDQUFDLHVCQUFNO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxzREFBTztBQUMzQixZQUFZLG1CQUFPLENBQUMsZ0VBQVM7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBLDJCQUEyQixxQ0FBcUM7QUFDaEU7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxxQ0FBcUM7QUFDM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0EsMkJBQTJCLG9DQUFvQztBQUMvRDtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLHFDQUFxQztBQUMxRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZDQUE2QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBNkM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQSwyQkFBMkIsc0NBQXNDO0FBQ2pFO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQ0FBZ0M7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxxQ0FBcUM7QUFDNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBNkM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0EsMkJBQTJCLHFDQUFxQztBQUNoRTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLHFDQUFxQztBQUMzRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtZmlyZWJhc2UtYXBpLy4vbm9kZV9tb2R1bGVzL2ZsdWVudC1mZm1wZWcvbGliL2NhcGFiaWxpdGllcy5qcz8yYWY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qanNoaW50IG5vZGU6dHJ1ZSovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qXG4gKiEgQ2FwYWJpbGl0eSBoZWxwZXJzXG4gKi9cblxudmFyIGF2Q29kZWNSZWdleHAgPSAvXlxccyooW0QgXSkoW0UgXSkoW1ZBU10pKFtTIF0pKFtEIF0pKFtUIF0pIChbXiBdKykgKyguKikkLztcbnZhciBmZkNvZGVjUmVnZXhwID0gL15cXHMqKFtEXFwuXSkoW0VcXC5dKShbVkFTXSkoW0lcXC5dKShbTFxcLl0pKFtTXFwuXSkgKFteIF0rKSArKC4qKSQvO1xudmFyIGZmRW5jb2RlcnNSZWdleHAgPSAvXFwoZW5jb2RlcnM6KFteXFwpXSspXFwpLztcbnZhciBmZkRlY29kZXJzUmVnZXhwID0gL1xcKGRlY29kZXJzOihbXlxcKV0rKVxcKS87XG52YXIgZW5jb2RlcnNSZWdleHAgPSAvXlxccyooW1ZBU1xcLl0pKFtGXFwuXSkoW1NcXC5dKShbWFxcLl0pKFtCXFwuXSkoW0RcXC5dKSAoW14gXSspICsoLiopJC87XG52YXIgZm9ybWF0UmVnZXhwID0gL15cXHMqKFtEIF0pKFtFIF0pXFxzKyhbXiBdKylcXHMrKC4qKSQvO1xudmFyIGxpbmVCcmVha1JlZ2V4cCA9IC9cXHJcXG58XFxyfFxcbi87XG52YXIgZmlsdGVyUmVnZXhwID0gL14oPzogW1RcXC5dW1NcXC5dW0NcXC5dICk/KFteIF0rKSArKEFBP3xWVj98XFx8KS0+KEFBP3xWVj98XFx8KSArKC4qKSQvO1xuXG52YXIgY2FjaGUgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwcm90bykge1xuICAvKipcbiAgICogTWFudWFsbHkgZGVmaW5lIHRoZSBmZm1wZWcgYmluYXJ5IGZ1bGwgcGF0aC5cbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI3NldEZmbXBlZ1BhdGhcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZmbXBlZ1BhdGggVGhlIGZ1bGwgcGF0aCB0byB0aGUgZmZtcGVnIGJpbmFyeS5cbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by5zZXRGZm1wZWdQYXRoID0gZnVuY3Rpb24oZmZtcGVnUGF0aCkge1xuICAgIGNhY2hlLmZmbXBlZ1BhdGggPSBmZm1wZWdQYXRoO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYW51YWxseSBkZWZpbmUgdGhlIGZmcHJvYmUgYmluYXJ5IGZ1bGwgcGF0aC5cbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI3NldEZmcHJvYmVQYXRoXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmZnByb2JlUGF0aCBUaGUgZnVsbCBwYXRoIHRvIHRoZSBmZnByb2JlIGJpbmFyeS5cbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by5zZXRGZnByb2JlUGF0aCA9IGZ1bmN0aW9uKGZmcHJvYmVQYXRoKSB7XG4gICAgY2FjaGUuZmZwcm9iZVBhdGggPSBmZnByb2JlUGF0aDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTWFudWFsbHkgZGVmaW5lIHRoZSBmbHZ0b29sMi9mbHZtZXRhIGJpbmFyeSBmdWxsIHBhdGguXG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNzZXRGbHZ0b29sUGF0aFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZmx2dG9vbCBUaGUgZnVsbCBwYXRoIHRvIHRoZSBmbHZ0b29sMiBvciBmbHZtZXRhIGJpbmFyeS5cbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by5zZXRGbHZ0b29sUGF0aCA9IGZ1bmN0aW9uKGZsdnRvb2wpIHtcbiAgICBjYWNoZS5mbHZ0b29sUGF0aCA9IGZsdnRvb2w7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcmdldCBleGVjdXRhYmxlIHBhdGhzXG4gICAqXG4gICAqIChvbmx5IHVzZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMpXG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNfZm9yZ2V0UGF0aHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RvLl9mb3JnZXRQYXRocyA9IGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSBjYWNoZS5mZm1wZWdQYXRoO1xuICAgIGRlbGV0ZSBjYWNoZS5mZnByb2JlUGF0aDtcbiAgICBkZWxldGUgY2FjaGUuZmx2dG9vbFBhdGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGZvciBmZm1wZWcgYXZhaWxhYmlsaXR5XG4gICAqXG4gICAqIElmIHRoZSBGRk1QRUdfUEFUSCBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBzZXQsIHRyeSB0byB1c2UgaXQuXG4gICAqIElmIGl0IGlzIHVuc2V0IG9yIGluY29ycmVjdCwgdHJ5IHRvIGZpbmQgZmZtcGVnIGluIHRoZSBQQVRIIGluc3RlYWQuXG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNfZ2V0RmZtcGVnUGF0aFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayB3aXRoIHNpZ25hdHVyZSAoZXJyLCBwYXRoKVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdG8uX2dldEZmbXBlZ1BhdGggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmICgnZmZtcGVnUGF0aCcgaW4gY2FjaGUpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBjYWNoZS5mZm1wZWdQYXRoKTtcbiAgICB9XG5cbiAgICBhc3luYy53YXRlcmZhbGwoW1xuICAgICAgLy8gVHJ5IEZGTVBFR19QQVRIXG4gICAgICBmdW5jdGlvbihjYikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuRkZNUEVHX1BBVEgpIHtcbiAgICAgICAgICBmcy5leGlzdHMocHJvY2Vzcy5lbnYuRkZNUEVHX1BBVEgsIGZ1bmN0aW9uKGV4aXN0cykge1xuICAgICAgICAgICAgaWYgKGV4aXN0cykge1xuICAgICAgICAgICAgICBjYihudWxsLCBwcm9jZXNzLmVudi5GRk1QRUdfUEFUSCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYihudWxsLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IobnVsbCwgJycpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyBTZWFyY2ggaW4gdGhlIFBBVEhcbiAgICAgIGZ1bmN0aW9uKGZmbXBlZywgY2IpIHtcbiAgICAgICAgaWYgKGZmbXBlZy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgZmZtcGVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWxzLndoaWNoKCdmZm1wZWcnLCBmdW5jdGlvbihlcnIsIGZmbXBlZykge1xuICAgICAgICAgIGNiKGVyciwgZmZtcGVnKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgXSwgZnVuY3Rpb24oZXJyLCBmZm1wZWcpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGNhY2hlLmZmbXBlZ1BhdGggPSAoZmZtcGVnIHx8ICcnKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cblxuICAvKipcbiAgICogQ2hlY2sgZm9yIGZmcHJvYmUgYXZhaWxhYmlsaXR5XG4gICAqXG4gICAqIElmIHRoZSBGRlBST0JFX1BBVEggZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgc2V0LCB0cnkgdG8gdXNlIGl0LlxuICAgKiBJZiBpdCBpcyB1bnNldCBvciBpbmNvcnJlY3QsIHRyeSB0byBmaW5kIGZmcHJvYmUgaW4gdGhlIFBBVEggaW5zdGVhZC5cbiAgICogSWYgdGhpcyBzdGlsbCBmYWlscywgdHJ5IHRvIGZpbmQgZmZwcm9iZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkgYXMgZmZtcGVnLlxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjX2dldEZmcHJvYmVQYXRoXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIHdpdGggc2lnbmF0dXJlIChlcnIsIHBhdGgpXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90by5fZ2V0RmZwcm9iZVBhdGggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICgnZmZwcm9iZVBhdGgnIGluIGNhY2hlKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgY2FjaGUuZmZwcm9iZVBhdGgpO1xuICAgIH1cblxuICAgIGFzeW5jLndhdGVyZmFsbChbXG4gICAgICAvLyBUcnkgRkZQUk9CRV9QQVRIXG4gICAgICBmdW5jdGlvbihjYikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuRkZQUk9CRV9QQVRIKSB7XG4gICAgICAgICAgZnMuZXhpc3RzKHByb2Nlc3MuZW52LkZGUFJPQkVfUEFUSCwgZnVuY3Rpb24oZXhpc3RzKSB7XG4gICAgICAgICAgICBjYihudWxsLCBleGlzdHMgPyBwcm9jZXNzLmVudi5GRlBST0JFX1BBVEggOiAnJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IobnVsbCwgJycpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyBTZWFyY2ggaW4gdGhlIFBBVEhcbiAgICAgIGZ1bmN0aW9uKGZmcHJvYmUsIGNiKSB7XG4gICAgICAgIGlmIChmZnByb2JlLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBjYihudWxsLCBmZnByb2JlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWxzLndoaWNoKCdmZnByb2JlJywgZnVuY3Rpb24oZXJyLCBmZnByb2JlKSB7XG4gICAgICAgICAgY2IoZXJyLCBmZnByb2JlKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICAvLyBTZWFyY2ggaW4gdGhlIHNhbWUgZGlyZWN0b3J5IGFzIGZmbXBlZ1xuICAgICAgZnVuY3Rpb24oZmZwcm9iZSwgY2IpIHtcbiAgICAgICAgaWYgKGZmcHJvYmUubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG51bGwsIGZmcHJvYmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5fZ2V0RmZtcGVnUGF0aChmdW5jdGlvbihlcnIsIGZmbXBlZykge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgfSBlbHNlIGlmIChmZm1wZWcubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHV0aWxzLmlzV2luZG93cyA/ICdmZnByb2JlLmV4ZScgOiAnZmZwcm9iZSc7XG4gICAgICAgICAgICB2YXIgZmZwcm9iZSA9IHBhdGguam9pbihwYXRoLmRpcm5hbWUoZmZtcGVnKSwgbmFtZSk7XG4gICAgICAgICAgICBmcy5leGlzdHMoZmZwcm9iZSwgZnVuY3Rpb24oZXhpc3RzKSB7XG4gICAgICAgICAgICAgIGNiKG51bGwsIGV4aXN0cyA/IGZmcHJvYmUgOiAnJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2IobnVsbCwgJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgXSwgZnVuY3Rpb24oZXJyLCBmZnByb2JlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBjYWNoZS5mZnByb2JlUGF0aCA9IChmZnByb2JlIHx8ICcnKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cblxuICAvKipcbiAgICogQ2hlY2sgZm9yIGZsdnRvb2wyL2Zsdm1ldGEgYXZhaWxhYmlsaXR5XG4gICAqXG4gICAqIElmIHRoZSBGTFZUT09MMl9QQVRIIG9yIEZMVk1FVEFfUEFUSCBlbnZpcm9ubWVudCB2YXJpYWJsZSBhcmUgc2V0LCB0cnkgdG8gdXNlIHRoZW0uXG4gICAqIElmIGJvdGggYXJlIGVpdGhlciB1bnNldCBvciBpbmNvcnJlY3QsIHRyeSB0byBmaW5kIGZsdnRvb2wyIG9yIGZsdm1ldGEgaW4gdGhlIFBBVEggaW5zdGVhZC5cbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI19nZXRGbHZ0b29sUGF0aFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayB3aXRoIHNpZ25hdHVyZSAoZXJyLCBwYXRoKVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgIHByb3RvLl9nZXRGbHZ0b29sUGF0aCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKCdmbHZ0b29sUGF0aCcgaW4gY2FjaGUpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBjYWNoZS5mbHZ0b29sUGF0aCk7XG4gICAgfVxuXG4gICAgYXN5bmMud2F0ZXJmYWxsKFtcbiAgICAgIC8vIFRyeSBGTFZNRVRBX1BBVEhcbiAgICAgIGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5GTFZNRVRBX1BBVEgpIHtcbiAgICAgICAgICBmcy5leGlzdHMocHJvY2Vzcy5lbnYuRkxWTUVUQV9QQVRILCBmdW5jdGlvbihleGlzdHMpIHtcbiAgICAgICAgICAgIGNiKG51bGwsIGV4aXN0cyA/IHByb2Nlc3MuZW52LkZMVk1FVEFfUEFUSCA6ICcnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYihudWxsLCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vIFRyeSBGTFZUT09MMl9QQVRIXG4gICAgICBmdW5jdGlvbihmbHZ0b29sLCBjYikge1xuICAgICAgICBpZiAoZmx2dG9vbC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgZmx2dG9vbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuRkxWVE9PTDJfUEFUSCkge1xuICAgICAgICAgIGZzLmV4aXN0cyhwcm9jZXNzLmVudi5GTFZUT09MMl9QQVRILCBmdW5jdGlvbihleGlzdHMpIHtcbiAgICAgICAgICAgIGNiKG51bGwsIGV4aXN0cyA/IHByb2Nlc3MuZW52LkZMVlRPT0wyX1BBVEggOiAnJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IobnVsbCwgJycpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyBTZWFyY2ggZm9yIGZsdm1ldGEgaW4gdGhlIFBBVEhcbiAgICAgIGZ1bmN0aW9uKGZsdnRvb2wsIGNiKSB7XG4gICAgICAgIGlmIChmbHZ0b29sLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBjYihudWxsLCBmbHZ0b29sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWxzLndoaWNoKCdmbHZtZXRhJywgZnVuY3Rpb24oZXJyLCBmbHZtZXRhKSB7XG4gICAgICAgICAgY2IoZXJyLCBmbHZtZXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICAvLyBTZWFyY2ggZm9yIGZsdnRvb2wyIGluIHRoZSBQQVRIXG4gICAgICBmdW5jdGlvbihmbHZ0b29sLCBjYikge1xuICAgICAgICBpZiAoZmx2dG9vbC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgZmx2dG9vbCk7XG4gICAgICAgIH1cblxuICAgICAgICB1dGlscy53aGljaCgnZmx2dG9vbDInLCBmdW5jdGlvbihlcnIsIGZsdnRvb2wyKSB7XG4gICAgICAgICAgY2IoZXJyLCBmbHZ0b29sMik7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICBdLCBmdW5jdGlvbihlcnIsIGZsdnRvb2wpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGNhY2hlLmZsdnRvb2xQYXRoID0gKGZsdnRvb2wgfHwgJycpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBBIGNhbGxiYWNrIHBhc3NlZCB0byB7QGxpbmsgRmZtcGVnQ29tbWFuZCNhdmFpbGFibGVGaWx0ZXJzfS5cbiAgICpcbiAgICogQGNhbGxiYWNrIEZmbXBlZ0NvbW1hbmR+ZmlsdGVyQ2FsbGJhY2tcbiAgICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnIgZXJyb3Igb2JqZWN0IG9yIG51bGwgaWYgbm8gZXJyb3IgaGFwcGVuZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGZpbHRlcnMgZmlsdGVyIG9iamVjdCB3aXRoIGZpbHRlciBuYW1lcyBhcyBrZXlzIGFuZCB0aGUgZm9sbG93aW5nXG4gICAqICAgcHJvcGVydGllcyBmb3IgZWFjaCBmaWx0ZXI6XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaWx0ZXJzLmRlc2NyaXB0aW9uIGZpbHRlciBkZXNjcmlwdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsdGVycy5pbnB1dCBpbnB1dCB0eXBlLCBvbmUgb2YgJ2F1ZGlvJywgJ3ZpZGVvJyBhbmQgJ25vbmUnXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmlsdGVycy5tdWx0aXBsZUlucHV0cyB3aGV0aGVyIHRoZSBmaWx0ZXIgc3VwcG9ydHMgbXVsdGlwbGUgaW5wdXRzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaWx0ZXJzLm91dHB1dCBvdXRwdXQgdHlwZSwgb25lIG9mICdhdWRpbycsICd2aWRlbycgYW5kICdub25lJ1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbHRlcnMubXVsdGlwbGVPdXRwdXRzIHdoZXRoZXIgdGhlIGZpbHRlciBzdXBwb3J0cyBtdWx0aXBsZSBvdXRwdXRzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBRdWVyeSBmZm1wZWcgZm9yIGF2YWlsYWJsZSBmaWx0ZXJzXG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNhdmFpbGFibGVGaWx0ZXJzXG4gICAqIEBjYXRlZ29yeSBDYXBhYmlsaXRpZXNcbiAgICogQGFsaWFzZXMgZ2V0QXZhaWxhYmxlRmlsdGVyc1xuICAgKlxuICAgKiBAcGFyYW0ge0ZmbXBlZ0NvbW1hbmR+ZmlsdGVyQ2FsbGJhY2t9IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqL1xuICBwcm90by5hdmFpbGFibGVGaWx0ZXJzID1cbiAgcHJvdG8uZ2V0QXZhaWxhYmxlRmlsdGVycyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKCdmaWx0ZXJzJyBpbiBjYWNoZSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGNhY2hlLmZpbHRlcnMpO1xuICAgIH1cblxuICAgIHRoaXMuX3NwYXduRmZtcGVnKFsnLWZpbHRlcnMnXSwgeyBjYXB0dXJlU3Rkb3V0OiB0cnVlLCBzdGRvdXRMaW5lczogMCB9LCBmdW5jdGlvbiAoZXJyLCBzdGRvdXRSaW5nKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3Rkb3V0ID0gc3Rkb3V0UmluZy5nZXQoKTtcbiAgICAgIHZhciBsaW5lcyA9IHN0ZG91dC5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgdmFyIHR5cGVzID0geyBBOiAnYXVkaW8nLCBWOiAndmlkZW8nLCAnfCc6ICdub25lJyB9O1xuXG4gICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gbGluZS5tYXRjaChmaWx0ZXJSZWdleHApO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBkYXRhW21hdGNoWzFdXSA9IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBtYXRjaFs0XSxcbiAgICAgICAgICAgIGlucHV0OiB0eXBlc1ttYXRjaFsyXS5jaGFyQXQoMCldLFxuICAgICAgICAgICAgbXVsdGlwbGVJbnB1dHM6IG1hdGNoWzJdLmxlbmd0aCA+IDEsXG4gICAgICAgICAgICBvdXRwdXQ6IHR5cGVzW21hdGNoWzNdLmNoYXJBdCgwKV0sXG4gICAgICAgICAgICBtdWx0aXBsZU91dHB1dHM6IG1hdGNoWzNdLmxlbmd0aCA+IDFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY2FsbGJhY2sobnVsbCwgY2FjaGUuZmlsdGVycyA9IGRhdGEpO1xuICAgIH0pO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEEgY2FsbGJhY2sgcGFzc2VkIHRvIHtAbGluayBGZm1wZWdDb21tYW5kI2F2YWlsYWJsZUNvZGVjc30uXG4gICAqXG4gICAqIEBjYWxsYmFjayBGZm1wZWdDb21tYW5kfmNvZGVjQ2FsbGJhY2tcbiAgICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnIgZXJyb3Igb2JqZWN0IG9yIG51bGwgaWYgbm8gZXJyb3IgaGFwcGVuZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvZGVjcyBjb2RlYyBvYmplY3Qgd2l0aCBjb2RlYyBuYW1lcyBhcyBrZXlzIGFuZCB0aGUgZm9sbG93aW5nXG4gICAqICAgcHJvcGVydGllcyBmb3IgZWFjaCBjb2RlYyAobW9yZSBwcm9wZXJ0aWVzIG1heSBiZSBhdmFpbGFibGUgZGVwZW5kaW5nIG9uIHRoZVxuICAgKiAgIGZmbXBlZyB2ZXJzaW9uIHVzZWQpOlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29kZWNzLmRlc2NyaXB0aW9uIGNvZGVjIGRlc2NyaXB0aW9uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29kZWNzLmNhbkRlY29kZSB3aGV0aGVyIHRoZSBjb2RlYyBpcyBhYmxlIHRvIGRlY29kZSBzdHJlYW1zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29kZWNzLmNhbkVuY29kZSB3aGV0aGVyIHRoZSBjb2RlYyBpcyBhYmxlIHRvIGVuY29kZSBzdHJlYW1zXG4gICAqL1xuXG4gIC8qKlxuICAgKiBRdWVyeSBmZm1wZWcgZm9yIGF2YWlsYWJsZSBjb2RlY3NcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2F2YWlsYWJsZUNvZGVjc1xuICAgKiBAY2F0ZWdvcnkgQ2FwYWJpbGl0aWVzXG4gICAqIEBhbGlhc2VzIGdldEF2YWlsYWJsZUNvZGVjc1xuICAgKlxuICAgKiBAcGFyYW0ge0ZmbXBlZ0NvbW1hbmR+Y29kZWNDYWxsYmFja30gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICovXG4gIHByb3RvLmF2YWlsYWJsZUNvZGVjcyA9XG4gIHByb3RvLmdldEF2YWlsYWJsZUNvZGVjcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKCdjb2RlY3MnIGluIGNhY2hlKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgY2FjaGUuY29kZWNzKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zcGF3bkZmbXBlZyhbJy1jb2RlY3MnXSwgeyBjYXB0dXJlU3Rkb3V0OiB0cnVlLCBzdGRvdXRMaW5lczogMCB9LCBmdW5jdGlvbihlcnIsIHN0ZG91dFJpbmcpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGRvdXQgPSBzdGRvdXRSaW5nLmdldCgpO1xuICAgICAgdmFyIGxpbmVzID0gc3Rkb3V0LnNwbGl0KGxpbmVCcmVha1JlZ2V4cCk7XG4gICAgICB2YXIgZGF0YSA9IHt9O1xuXG4gICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gbGluZS5tYXRjaChhdkNvZGVjUmVnZXhwKTtcbiAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzddICE9PSAnPScpIHtcbiAgICAgICAgICBkYXRhW21hdGNoWzddXSA9IHtcbiAgICAgICAgICAgIHR5cGU6IHsgJ1YnOiAndmlkZW8nLCAnQSc6ICdhdWRpbycsICdTJzogJ3N1YnRpdGxlJyB9W21hdGNoWzNdXSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBtYXRjaFs4XSxcbiAgICAgICAgICAgIGNhbkRlY29kZTogbWF0Y2hbMV0gPT09ICdEJyxcbiAgICAgICAgICAgIGNhbkVuY29kZTogbWF0Y2hbMl0gPT09ICdFJyxcbiAgICAgICAgICAgIGRyYXdIb3JpekJhbmQ6IG1hdGNoWzRdID09PSAnUycsXG4gICAgICAgICAgICBkaXJlY3RSZW5kZXJpbmc6IG1hdGNoWzVdID09PSAnRCcsXG4gICAgICAgICAgICB3ZWlyZEZyYW1lVHJ1bmNhdGlvbjogbWF0Y2hbNl0gPT09ICdUJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBtYXRjaCA9IGxpbmUubWF0Y2goZmZDb2RlY1JlZ2V4cCk7XG4gICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFs3XSAhPT0gJz0nKSB7XG4gICAgICAgICAgdmFyIGNvZGVjRGF0YSA9IGRhdGFbbWF0Y2hbN11dID0ge1xuICAgICAgICAgICAgdHlwZTogeyAnVic6ICd2aWRlbycsICdBJzogJ2F1ZGlvJywgJ1MnOiAnc3VidGl0bGUnIH1bbWF0Y2hbM11dLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IG1hdGNoWzhdLFxuICAgICAgICAgICAgY2FuRGVjb2RlOiBtYXRjaFsxXSA9PT0gJ0QnLFxuICAgICAgICAgICAgY2FuRW5jb2RlOiBtYXRjaFsyXSA9PT0gJ0UnLFxuICAgICAgICAgICAgaW50cmFGcmFtZU9ubHk6IG1hdGNoWzRdID09PSAnSScsXG4gICAgICAgICAgICBpc0xvc3N5OiBtYXRjaFs1XSA9PT0gJ0wnLFxuICAgICAgICAgICAgaXNMb3NzbGVzczogbWF0Y2hbNl0gPT09ICdTJ1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgZW5jb2RlcnMgPSBjb2RlY0RhdGEuZGVzY3JpcHRpb24ubWF0Y2goZmZFbmNvZGVyc1JlZ2V4cCk7XG4gICAgICAgICAgZW5jb2RlcnMgPSBlbmNvZGVycyA/IGVuY29kZXJzWzFdLnRyaW0oKS5zcGxpdCgnICcpIDogW107XG5cbiAgICAgICAgICB2YXIgZGVjb2RlcnMgPSBjb2RlY0RhdGEuZGVzY3JpcHRpb24ubWF0Y2goZmZEZWNvZGVyc1JlZ2V4cCk7XG4gICAgICAgICAgZGVjb2RlcnMgPSBkZWNvZGVycyA/IGRlY29kZXJzWzFdLnRyaW0oKS5zcGxpdCgnICcpIDogW107XG5cbiAgICAgICAgICBpZiAoZW5jb2RlcnMubGVuZ3RoIHx8IGRlY29kZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNvZGVyRGF0YSA9IHt9O1xuICAgICAgICAgICAgdXRpbHMuY29weShjb2RlY0RhdGEsIGNvZGVyRGF0YSk7XG4gICAgICAgICAgICBkZWxldGUgY29kZXJEYXRhLmNhbkVuY29kZTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb2RlckRhdGEuY2FuRGVjb2RlO1xuXG4gICAgICAgICAgICBlbmNvZGVycy5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgZGF0YVtuYW1lXSA9IHt9O1xuICAgICAgICAgICAgICB1dGlscy5jb3B5KGNvZGVyRGF0YSwgZGF0YVtuYW1lXSk7XG4gICAgICAgICAgICAgIGRhdGFbbmFtZV0uY2FuRW5jb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZWNvZGVycy5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgaWYgKG5hbWUgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgIGRhdGFbbmFtZV0uY2FuRGVjb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhW25hbWVdID0ge307XG4gICAgICAgICAgICAgICAgdXRpbHMuY29weShjb2RlckRhdGEsIGRhdGFbbmFtZV0pO1xuICAgICAgICAgICAgICAgIGRhdGFbbmFtZV0uY2FuRGVjb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY2FsbGJhY2sobnVsbCwgY2FjaGUuY29kZWNzID0gZGF0YSk7XG4gICAgfSk7XG4gIH07XG5cblxuICAvKipcbiAgICogQSBjYWxsYmFjayBwYXNzZWQgdG8ge0BsaW5rIEZmbXBlZ0NvbW1hbmQjYXZhaWxhYmxlRW5jb2RlcnN9LlxuICAgKlxuICAgKiBAY2FsbGJhY2sgRmZtcGVnQ29tbWFuZH5lbmNvZGVyc0NhbGxiYWNrXG4gICAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyIGVycm9yIG9iamVjdCBvciBudWxsIGlmIG5vIGVycm9yIGhhcHBlbmVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbmNvZGVycyBlbmNvZGVycyBvYmplY3Qgd2l0aCBlbmNvZGVyIG5hbWVzIGFzIGtleXMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICogICBwcm9wZXJ0aWVzIGZvciBlYWNoIGVuY29kZXI6XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGVycy5kZXNjcmlwdGlvbiBjb2RlYyBkZXNjcmlwdGlvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuY29kZXJzLnR5cGUgXCJhdWRpb1wiLCBcInZpZGVvXCIgb3IgXCJzdWJ0aXRsZVwiXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5jb2RlcnMuZnJhbWVNVCB3aGV0aGVyIHRoZSBlbmNvZGVyIGlzIGFibGUgdG8gZG8gZnJhbWUtbGV2ZWwgbXVsdGl0aHJlYWRpbmdcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmNvZGVycy5zbGljZU1UIHdoZXRoZXIgdGhlIGVuY29kZXIgaXMgYWJsZSB0byBkbyBzbGljZS1sZXZlbCBtdWx0aXRocmVhZGluZ1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuY29kZXJzLmV4cGVyaW1lbnRhbCB3aGV0aGVyIHRoZSBlbmNvZGVyIGlzIGV4cGVyaW1lbnRhbFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuY29kZXJzLmRyYXdIb3JpekJhbmQgd2hldGhlciB0aGUgZW5jb2RlciBzdXBwb3J0cyBkcmF3X2hvcml6X2JhbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmNvZGVycy5kaXJlY3RSZW5kZXJpbmcgd2hldGhlciB0aGUgZW5jb2RlciBzdXBwb3J0cyBkaXJlY3QgZW5jb2RpbmcgbWV0aG9kIDFcbiAgICovXG5cbiAgLyoqXG4gICAqIFF1ZXJ5IGZmbXBlZyBmb3IgYXZhaWxhYmxlIGVuY29kZXJzXG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNhdmFpbGFibGVFbmNvZGVyc1xuICAgKiBAY2F0ZWdvcnkgQ2FwYWJpbGl0aWVzXG4gICAqIEBhbGlhc2VzIGdldEF2YWlsYWJsZUVuY29kZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7RmZtcGVnQ29tbWFuZH5lbmNvZGVyc0NhbGxiYWNrfSBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvblxuICAgKi9cbiAgcHJvdG8uYXZhaWxhYmxlRW5jb2RlcnMgPVxuICBwcm90by5nZXRBdmFpbGFibGVFbmNvZGVycyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKCdlbmNvZGVycycgaW4gY2FjaGUpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBjYWNoZS5lbmNvZGVycyk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3Bhd25GZm1wZWcoWyctZW5jb2RlcnMnXSwgeyBjYXB0dXJlU3Rkb3V0OiB0cnVlLCBzdGRvdXRMaW5lczogMCB9LCBmdW5jdGlvbihlcnIsIHN0ZG91dFJpbmcpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGRvdXQgPSBzdGRvdXRSaW5nLmdldCgpO1xuICAgICAgdmFyIGxpbmVzID0gc3Rkb3V0LnNwbGl0KGxpbmVCcmVha1JlZ2V4cCk7XG4gICAgICB2YXIgZGF0YSA9IHt9O1xuXG4gICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gbGluZS5tYXRjaChlbmNvZGVyc1JlZ2V4cCk7XG4gICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFs3XSAhPT0gJz0nKSB7XG4gICAgICAgICAgZGF0YVttYXRjaFs3XV0gPSB7XG4gICAgICAgICAgICB0eXBlOiB7ICdWJzogJ3ZpZGVvJywgJ0EnOiAnYXVkaW8nLCAnUyc6ICdzdWJ0aXRsZScgfVttYXRjaFsxXV0sXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogbWF0Y2hbOF0sXG4gICAgICAgICAgICBmcmFtZU1UOiBtYXRjaFsyXSA9PT0gJ0YnLFxuICAgICAgICAgICAgc2xpY2VNVDogbWF0Y2hbM10gPT09ICdTJyxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbDogbWF0Y2hbNF0gPT09ICdYJyxcbiAgICAgICAgICAgIGRyYXdIb3JpekJhbmQ6IG1hdGNoWzVdID09PSAnQicsXG4gICAgICAgICAgICBkaXJlY3RSZW5kZXJpbmc6IG1hdGNoWzZdID09PSAnRCdcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY2FsbGJhY2sobnVsbCwgY2FjaGUuZW5jb2RlcnMgPSBkYXRhKTtcbiAgICB9KTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBBIGNhbGxiYWNrIHBhc3NlZCB0byB7QGxpbmsgRmZtcGVnQ29tbWFuZCNhdmFpbGFibGVGb3JtYXRzfS5cbiAgICpcbiAgICogQGNhbGxiYWNrIEZmbXBlZ0NvbW1hbmR+Zm9ybWF0Q2FsbGJhY2tcbiAgICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnIgZXJyb3Igb2JqZWN0IG9yIG51bGwgaWYgbm8gZXJyb3IgaGFwcGVuZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGZvcm1hdHMgZm9ybWF0IG9iamVjdCB3aXRoIGZvcm1hdCBuYW1lcyBhcyBrZXlzIGFuZCB0aGUgZm9sbG93aW5nXG4gICAqICAgcHJvcGVydGllcyBmb3IgZWFjaCBmb3JtYXQ6XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXRzLmRlc2NyaXB0aW9uIGZvcm1hdCBkZXNjcmlwdGlvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcm1hdHMuY2FuRGVtdXggd2hldGhlciB0aGUgZm9ybWF0IGlzIGFibGUgdG8gZGVtdXggc3RyZWFtcyBmcm9tIGFuIGlucHV0IGZpbGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBmb3JtYXRzLmNhbk11eCB3aGV0aGVyIHRoZSBmb3JtYXQgaXMgYWJsZSB0byBtdXggc3RyZWFtcyBpbnRvIGFuIG91dHB1dCBmaWxlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBRdWVyeSBmZm1wZWcgZm9yIGF2YWlsYWJsZSBmb3JtYXRzXG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNhdmFpbGFibGVGb3JtYXRzXG4gICAqIEBjYXRlZ29yeSBDYXBhYmlsaXRpZXNcbiAgICogQGFsaWFzZXMgZ2V0QXZhaWxhYmxlRm9ybWF0c1xuICAgKlxuICAgKiBAcGFyYW0ge0ZmbXBlZ0NvbW1hbmR+Zm9ybWF0Q2FsbGJhY2t9IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqL1xuICBwcm90by5hdmFpbGFibGVGb3JtYXRzID1cbiAgcHJvdG8uZ2V0QXZhaWxhYmxlRm9ybWF0cyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKCdmb3JtYXRzJyBpbiBjYWNoZSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGNhY2hlLmZvcm1hdHMpO1xuICAgIH1cblxuICAgIC8vIFJ1biBmZm1wZWcgLWZvcm1hdHNcbiAgICB0aGlzLl9zcGF3bkZmbXBlZyhbJy1mb3JtYXRzJ10sIHsgY2FwdHVyZVN0ZG91dDogdHJ1ZSwgc3Rkb3V0TGluZXM6IDAgfSwgZnVuY3Rpb24gKGVyciwgc3Rkb3V0UmluZykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgLy8gUGFyc2Ugb3V0cHV0XG4gICAgICB2YXIgc3Rkb3V0ID0gc3Rkb3V0UmluZy5nZXQoKTtcbiAgICAgIHZhciBsaW5lcyA9IHN0ZG91dC5zcGxpdChsaW5lQnJlYWtSZWdleHApO1xuICAgICAgdmFyIGRhdGEgPSB7fTtcblxuICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGxpbmUubWF0Y2goZm9ybWF0UmVnZXhwKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgbWF0Y2hbM10uc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICAgICAgaWYgKCEoZm9ybWF0IGluIGRhdGEpKSB7XG4gICAgICAgICAgICAgIGRhdGFbZm9ybWF0XSA9IHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogbWF0Y2hbNF0sXG4gICAgICAgICAgICAgICAgY2FuRGVtdXg6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNhbk11eDogZmFsc2VcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hdGNoWzFdID09PSAnRCcpIHtcbiAgICAgICAgICAgICAgZGF0YVtmb3JtYXRdLmNhbkRlbXV4ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFsyXSA9PT0gJ0UnKSB7XG4gICAgICAgICAgICAgIGRhdGFbZm9ybWF0XS5jYW5NdXggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY2FsbGJhY2sobnVsbCwgY2FjaGUuZm9ybWF0cyA9IGRhdGEpO1xuICAgIH0pO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIENoZWNrIGNhcGFiaWxpdGllcyBiZWZvcmUgZXhlY3V0aW5nIGEgY29tbWFuZFxuICAgKlxuICAgKiBDaGVja3Mgd2hldGhlciBhbGwgdXNlZCBjb2RlY3MgYW5kIGZvcm1hdHMgYXJlIGluZGVlZCBhdmFpbGFibGVcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI19jaGVja0NhcGFiaWxpdGllc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayB3aXRoIHNpZ25hdHVyZSAoZXJyKVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdG8uX2NoZWNrQ2FwYWJpbGl0aWVzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgYXN5bmMud2F0ZXJmYWxsKFtcbiAgICAgIC8vIEdldCBhdmFpbGFibGUgZm9ybWF0c1xuICAgICAgZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgc2VsZi5hdmFpbGFibGVGb3JtYXRzKGNiKTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIENoZWNrIHdoZXRoZXIgc3BlY2lmaWVkIGZvcm1hdHMgYXJlIGF2YWlsYWJsZVxuICAgICAgZnVuY3Rpb24oZm9ybWF0cywgY2IpIHtcbiAgICAgICAgdmFyIHVuYXZhaWxhYmxlO1xuXG4gICAgICAgIC8vIE91dHB1dCBmb3JtYXQocylcbiAgICAgICAgdW5hdmFpbGFibGUgPSBzZWxmLl9vdXRwdXRzXG4gICAgICAgICAgLnJlZHVjZShmdW5jdGlvbihmbXRzLCBvdXRwdXQpIHtcbiAgICAgICAgICAgIHZhciBmb3JtYXQgPSBvdXRwdXQub3B0aW9ucy5maW5kKCctZicsIDEpO1xuICAgICAgICAgICAgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgICBpZiAoIShmb3JtYXRbMF0gaW4gZm9ybWF0cykgfHwgIShmb3JtYXRzW2Zvcm1hdFswXV0uY2FuTXV4KSkge1xuICAgICAgICAgICAgICAgIGZtdHMucHVzaChmb3JtYXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmbXRzO1xuICAgICAgICAgIH0sIFtdKTtcblxuICAgICAgICBpZiAodW5hdmFpbGFibGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignT3V0cHV0IGZvcm1hdCAnICsgdW5hdmFpbGFibGVbMF0gKyAnIGlzIG5vdCBhdmFpbGFibGUnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodW5hdmFpbGFibGUubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ091dHB1dCBmb3JtYXRzICcgKyB1bmF2YWlsYWJsZS5qb2luKCcsICcpICsgJyBhcmUgbm90IGF2YWlsYWJsZScpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElucHV0IGZvcm1hdChzKVxuICAgICAgICB1bmF2YWlsYWJsZSA9IHNlbGYuX2lucHV0c1xuICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24oZm10cywgaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBmb3JtYXQgPSBpbnB1dC5vcHRpb25zLmZpbmQoJy1mJywgMSk7XG4gICAgICAgICAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgIGlmICghKGZvcm1hdFswXSBpbiBmb3JtYXRzKSB8fCAhKGZvcm1hdHNbZm9ybWF0WzBdXS5jYW5EZW11eCkpIHtcbiAgICAgICAgICAgICAgICBmbXRzLnB1c2goZm9ybWF0WzBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZm10cztcbiAgICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgaWYgKHVuYXZhaWxhYmxlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ0lucHV0IGZvcm1hdCAnICsgdW5hdmFpbGFibGVbMF0gKyAnIGlzIG5vdCBhdmFpbGFibGUnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodW5hdmFpbGFibGUubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ0lucHV0IGZvcm1hdHMgJyArIHVuYXZhaWxhYmxlLmpvaW4oJywgJykgKyAnIGFyZSBub3QgYXZhaWxhYmxlJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2IoKTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIEdldCBhdmFpbGFibGUgY29kZWNzXG4gICAgICBmdW5jdGlvbihjYikge1xuICAgICAgICBzZWxmLmF2YWlsYWJsZUVuY29kZXJzKGNiKTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIENoZWNrIHdoZXRoZXIgc3BlY2lmaWVkIGNvZGVjcyBhcmUgYXZhaWxhYmxlIGFuZCBhZGQgc3RyaWN0IGV4cGVyaW1lbnRhbCBvcHRpb25zIGlmIG5lZWRlZFxuICAgICAgZnVuY3Rpb24oZW5jb2RlcnMsIGNiKSB7XG4gICAgICAgIHZhciB1bmF2YWlsYWJsZTtcblxuICAgICAgICAvLyBBdWRpbyBjb2RlYyhzKVxuICAgICAgICB1bmF2YWlsYWJsZSA9IHNlbGYuX291dHB1dHMucmVkdWNlKGZ1bmN0aW9uKGNkY3MsIG91dHB1dCkge1xuICAgICAgICAgIHZhciBhY29kZWMgPSBvdXRwdXQuYXVkaW8uZmluZCgnLWFjb2RlYycsIDEpO1xuICAgICAgICAgIGlmIChhY29kZWMgJiYgYWNvZGVjWzBdICE9PSAnY29weScpIHtcbiAgICAgICAgICAgIGlmICghKGFjb2RlY1swXSBpbiBlbmNvZGVycykgfHwgZW5jb2RlcnNbYWNvZGVjWzBdXS50eXBlICE9PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICAgIGNkY3MucHVzaChhY29kZWNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjZGNzO1xuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgaWYgKHVuYXZhaWxhYmxlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ0F1ZGlvIGNvZGVjICcgKyB1bmF2YWlsYWJsZVswXSArICcgaXMgbm90IGF2YWlsYWJsZScpKTtcbiAgICAgICAgfSBlbHNlIGlmICh1bmF2YWlsYWJsZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignQXVkaW8gY29kZWNzICcgKyB1bmF2YWlsYWJsZS5qb2luKCcsICcpICsgJyBhcmUgbm90IGF2YWlsYWJsZScpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZpZGVvIGNvZGVjKHMpXG4gICAgICAgIHVuYXZhaWxhYmxlID0gc2VsZi5fb3V0cHV0cy5yZWR1Y2UoZnVuY3Rpb24oY2Rjcywgb3V0cHV0KSB7XG4gICAgICAgICAgdmFyIHZjb2RlYyA9IG91dHB1dC52aWRlby5maW5kKCctdmNvZGVjJywgMSk7XG4gICAgICAgICAgaWYgKHZjb2RlYyAmJiB2Y29kZWNbMF0gIT09ICdjb3B5Jykge1xuICAgICAgICAgICAgaWYgKCEodmNvZGVjWzBdIGluIGVuY29kZXJzKSB8fCBlbmNvZGVyc1t2Y29kZWNbMF1dLnR5cGUgIT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgICAgY2Rjcy5wdXNoKHZjb2RlY1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNkY3M7XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBpZiAodW5hdmFpbGFibGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignVmlkZW8gY29kZWMgJyArIHVuYXZhaWxhYmxlWzBdICsgJyBpcyBub3QgYXZhaWxhYmxlJykpO1xuICAgICAgICB9IGVsc2UgaWYgKHVuYXZhaWxhYmxlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdWaWRlbyBjb2RlY3MgJyArIHVuYXZhaWxhYmxlLmpvaW4oJywgJykgKyAnIGFyZSBub3QgYXZhaWxhYmxlJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2IoKTtcbiAgICAgIH1cbiAgICBdLCBjYWxsYmFjayk7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/capabilities.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/ffprobe.js":
/*!***************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/ffprobe.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true, laxcomma:true*/\n\n\nvar spawn = (__webpack_require__(/*! child_process */ \"child_process\").spawn);\n\n\nfunction legacyTag(key) { return key.match(/^TAG:/); }\nfunction legacyDisposition(key) { return key.match(/^DISPOSITION:/); }\n\nfunction parseFfprobeOutput(out) {\n  var lines = out.split(/\\r\\n|\\r|\\n/);\n\n  lines = lines.filter(function (line) {\n    return line.length > 0;\n  });\n\n  var data = {\n    streams: [],\n    format: {},\n    chapters: []\n  };\n\n  function parseBlock(name) {\n    var data = {};\n\n    var line = lines.shift();\n    while (typeof line !== 'undefined') {\n      if (line.toLowerCase() == '[/'+name+']') {\n        return data;\n      } else if (line.match(/^\\[/)) {\n        line = lines.shift();\n        continue;\n      }\n\n      var kv = line.match(/^([^=]+)=(.*)$/);\n      if (kv) {\n        if (!(kv[1].match(/^TAG:/)) && kv[2].match(/^[0-9]+(\\.[0-9]+)?$/)) {\n          data[kv[1]] = Number(kv[2]);\n        } else {\n          data[kv[1]] = kv[2];\n        }\n      }\n\n      line = lines.shift();\n    }\n\n    return data;\n  }\n\n  var line = lines.shift();\n  while (typeof line !== 'undefined') {\n    if (line.match(/^\\[stream/i)) {\n      var stream = parseBlock('stream');\n      data.streams.push(stream);\n    } else if (line.match(/^\\[chapter/i)) {\n      var chapter = parseBlock('chapter');\n      data.chapters.push(chapter);\n    } else if (line.toLowerCase() === '[format]') {\n      data.format = parseBlock('format');\n    }\n\n    line = lines.shift();\n  }\n\n  return data;\n}\n\n\n\nmodule.exports = function(proto) {\n  /**\n   * A callback passed to the {@link FfmpegCommand#ffprobe} method.\n   *\n   * @callback FfmpegCommand~ffprobeCallback\n   *\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} ffprobeData ffprobe output data; this object\n   *   has the same format as what the following command returns:\n   *\n   *     `ffprobe -print_format json -show_streams -show_format INPUTFILE`\n   * @param {Array} ffprobeData.streams stream information\n   * @param {Object} ffprobeData.format format information\n   */\n\n  /**\n   * Run ffprobe on last specified input\n   *\n   * @method FfmpegCommand#ffprobe\n   * @category Metadata\n   *\n   * @param {?Number} [index] 0-based index of input to probe (defaults to last input)\n   * @param {?String[]} [options] array of output options to return\n   * @param {FfmpegCommand~ffprobeCallback} callback callback function\n   *\n   */\n  proto.ffprobe = function() {\n    var input, index = null, options = [], callback;\n\n    // the last argument should be the callback\n    var callback = arguments[arguments.length - 1];\n\n    var ended = false\n    function handleCallback(err, data) {\n      if (!ended) {\n        ended = true;\n        callback(err, data);\n      }\n    };\n\n    // map the arguments to the correct variable names\n    switch (arguments.length) {\n      case 3:\n        index = arguments[0];\n        options = arguments[1];\n        break;\n      case 2:\n        if (typeof arguments[0] === 'number') {\n          index = arguments[0];\n        } else if (Array.isArray(arguments[0])) {\n          options = arguments[0];\n        }\n        break;\n    }\n\n\n    if (index === null) {\n      if (!this._currentInput) {\n        return handleCallback(new Error('No input specified'));\n      }\n\n      input = this._currentInput;\n    } else {\n      input = this._inputs[index];\n\n      if (!input) {\n        return handleCallback(new Error('Invalid input index'));\n      }\n    }\n\n    // Find ffprobe\n    this._getFfprobePath(function(err, path) {\n      if (err) {\n        return handleCallback(err);\n      } else if (!path) {\n        return handleCallback(new Error('Cannot find ffprobe'));\n      }\n\n      var stdout = '';\n      var stdoutClosed = false;\n      var stderr = '';\n      var stderrClosed = false;\n\n      // Spawn ffprobe\n      var src = input.isStream ? 'pipe:0' : input.source;\n      var ffprobe = spawn(path, ['-show_streams', '-show_format'].concat(options, src), {windowsHide: true});\n\n      if (input.isStream) {\n        // Skip errors on stdin. These get thrown when ffprobe is complete and\n        // there seems to be no way hook in and close stdin before it throws.\n        ffprobe.stdin.on('error', function(err) {\n          if (['ECONNRESET', 'EPIPE', 'EOF'].indexOf(err.code) >= 0) { return; }\n          handleCallback(err);\n        });\n\n        // Once ffprobe's input stream closes, we need no more data from the\n        // input\n        ffprobe.stdin.on('close', function() {\n            input.source.pause();\n            input.source.unpipe(ffprobe.stdin);\n        });\n\n        input.source.pipe(ffprobe.stdin);\n      }\n\n      ffprobe.on('error', callback);\n\n      // Ensure we wait for captured streams to end before calling callback\n      var exitError = null;\n      function handleExit(err) {\n        if (err) {\n          exitError = err;\n        }\n\n        if (processExited && stdoutClosed && stderrClosed) {\n          if (exitError) {\n            if (stderr) {\n              exitError.message += '\\n' + stderr;\n            }\n\n            return handleCallback(exitError);\n          }\n\n          // Process output\n          var data = parseFfprobeOutput(stdout);\n\n          // Handle legacy output with \"TAG:x\" and \"DISPOSITION:x\" keys\n          [data.format].concat(data.streams).forEach(function(target) {\n            if (target) {\n              var legacyTagKeys = Object.keys(target).filter(legacyTag);\n\n              if (legacyTagKeys.length) {\n                target.tags = target.tags || {};\n\n                legacyTagKeys.forEach(function(tagKey) {\n                  target.tags[tagKey.substr(4)] = target[tagKey];\n                  delete target[tagKey];\n                });\n              }\n\n              var legacyDispositionKeys = Object.keys(target).filter(legacyDisposition);\n\n              if (legacyDispositionKeys.length) {\n                target.disposition = target.disposition || {};\n\n                legacyDispositionKeys.forEach(function(dispositionKey) {\n                  target.disposition[dispositionKey.substr(12)] = target[dispositionKey];\n                  delete target[dispositionKey];\n                });\n              }\n            }\n          });\n\n          handleCallback(null, data);\n        }\n      }\n\n      // Handle ffprobe exit\n      var processExited = false;\n      ffprobe.on('exit', function(code, signal) {\n        processExited = true;\n\n        if (code) {\n          handleExit(new Error('ffprobe exited with code ' + code));\n        } else if (signal) {\n          handleExit(new Error('ffprobe was killed with signal ' + signal));\n        } else {\n          handleExit();\n        }\n      });\n\n      // Handle stdout/stderr streams\n      ffprobe.stdout.on('data', function(data) {\n        stdout += data;\n      });\n\n      ffprobe.stdout.on('close', function() {\n        stdoutClosed = true;\n        handleExit();\n      });\n\n      ffprobe.stderr.on('data', function(data) {\n        stderr += data;\n      });\n\n      ffprobe.stderr.on('close', function() {\n        stderrClosed = true;\n        handleExit();\n      });\n    });\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvZmZwcm9iZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOztBQUViLFlBQVksaUVBQThCOzs7QUFHMUMsMEJBQTBCO0FBQzFCLGtDQUFrQzs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsK0JBQStCLDZCQUE2QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxRQUFRLGlDQUFpQztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFdBQVc7QUFDeEIsYUFBYSwrQkFBK0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlGQUF5RixrQkFBa0I7O0FBRTNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWZpcmViYXNlLWFwaS8uL25vZGVfbW9kdWxlcy9mbHVlbnQtZmZtcGVnL2xpYi9mZnByb2JlLmpzPzBjZGEiXSwic291cmNlc0NvbnRlbnQiOlsiLypqc2hpbnQgbm9kZTp0cnVlLCBsYXhjb21tYTp0cnVlKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHNwYXduID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLnNwYXduO1xuXG5cbmZ1bmN0aW9uIGxlZ2FjeVRhZyhrZXkpIHsgcmV0dXJuIGtleS5tYXRjaCgvXlRBRzovKTsgfVxuZnVuY3Rpb24gbGVnYWN5RGlzcG9zaXRpb24oa2V5KSB7IHJldHVybiBrZXkubWF0Y2goL15ESVNQT1NJVElPTjovKTsgfVxuXG5mdW5jdGlvbiBwYXJzZUZmcHJvYmVPdXRwdXQob3V0KSB7XG4gIHZhciBsaW5lcyA9IG91dC5zcGxpdCgvXFxyXFxufFxccnxcXG4vKTtcblxuICBsaW5lcyA9IGxpbmVzLmZpbHRlcihmdW5jdGlvbiAobGluZSkge1xuICAgIHJldHVybiBsaW5lLmxlbmd0aCA+IDA7XG4gIH0pO1xuXG4gIHZhciBkYXRhID0ge1xuICAgIHN0cmVhbXM6IFtdLFxuICAgIGZvcm1hdDoge30sXG4gICAgY2hhcHRlcnM6IFtdXG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VCbG9jayhuYW1lKSB7XG4gICAgdmFyIGRhdGEgPSB7fTtcblxuICAgIHZhciBsaW5lID0gbGluZXMuc2hpZnQoKTtcbiAgICB3aGlsZSAodHlwZW9mIGxpbmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAobGluZS50b0xvd2VyQ2FzZSgpID09ICdbLycrbmFtZSsnXScpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9IGVsc2UgaWYgKGxpbmUubWF0Y2goL15cXFsvKSkge1xuICAgICAgICBsaW5lID0gbGluZXMuc2hpZnQoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBrdiA9IGxpbmUubWF0Y2goL14oW149XSspPSguKikkLyk7XG4gICAgICBpZiAoa3YpIHtcbiAgICAgICAgaWYgKCEoa3ZbMV0ubWF0Y2goL15UQUc6LykpICYmIGt2WzJdLm1hdGNoKC9eWzAtOV0rKFxcLlswLTldKyk/JC8pKSB7XG4gICAgICAgICAgZGF0YVtrdlsxXV0gPSBOdW1iZXIoa3ZbMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFba3ZbMV1dID0ga3ZbMl07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGluZSA9IGxpbmVzLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgbGluZSA9IGxpbmVzLnNoaWZ0KCk7XG4gIHdoaWxlICh0eXBlb2YgbGluZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAobGluZS5tYXRjaCgvXlxcW3N0cmVhbS9pKSkge1xuICAgICAgdmFyIHN0cmVhbSA9IHBhcnNlQmxvY2soJ3N0cmVhbScpO1xuICAgICAgZGF0YS5zdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICB9IGVsc2UgaWYgKGxpbmUubWF0Y2goL15cXFtjaGFwdGVyL2kpKSB7XG4gICAgICB2YXIgY2hhcHRlciA9IHBhcnNlQmxvY2soJ2NoYXB0ZXInKTtcbiAgICAgIGRhdGEuY2hhcHRlcnMucHVzaChjaGFwdGVyKTtcbiAgICB9IGVsc2UgaWYgKGxpbmUudG9Mb3dlckNhc2UoKSA9PT0gJ1tmb3JtYXRdJykge1xuICAgICAgZGF0YS5mb3JtYXQgPSBwYXJzZUJsb2NrKCdmb3JtYXQnKTtcbiAgICB9XG5cbiAgICBsaW5lID0gbGluZXMuc2hpZnQoKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwcm90bykge1xuICAvKipcbiAgICogQSBjYWxsYmFjayBwYXNzZWQgdG8gdGhlIHtAbGluayBGZm1wZWdDb21tYW5kI2ZmcHJvYmV9IG1ldGhvZC5cbiAgICpcbiAgICogQGNhbGxiYWNrIEZmbXBlZ0NvbW1hbmR+ZmZwcm9iZUNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyIGVycm9yIG9iamVjdCBvciBudWxsIGlmIG5vIGVycm9yIGhhcHBlbmVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmZnByb2JlRGF0YSBmZnByb2JlIG91dHB1dCBkYXRhOyB0aGlzIG9iamVjdFxuICAgKiAgIGhhcyB0aGUgc2FtZSBmb3JtYXQgYXMgd2hhdCB0aGUgZm9sbG93aW5nIGNvbW1hbmQgcmV0dXJuczpcbiAgICpcbiAgICogICAgIGBmZnByb2JlIC1wcmludF9mb3JtYXQganNvbiAtc2hvd19zdHJlYW1zIC1zaG93X2Zvcm1hdCBJTlBVVEZJTEVgXG4gICAqIEBwYXJhbSB7QXJyYXl9IGZmcHJvYmVEYXRhLnN0cmVhbXMgc3RyZWFtIGluZm9ybWF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmZnByb2JlRGF0YS5mb3JtYXQgZm9ybWF0IGluZm9ybWF0aW9uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSdW4gZmZwcm9iZSBvbiBsYXN0IHNwZWNpZmllZCBpbnB1dFxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjZmZwcm9iZVxuICAgKiBAY2F0ZWdvcnkgTWV0YWRhdGFcbiAgICpcbiAgICogQHBhcmFtIHs/TnVtYmVyfSBbaW5kZXhdIDAtYmFzZWQgaW5kZXggb2YgaW5wdXQgdG8gcHJvYmUgKGRlZmF1bHRzIHRvIGxhc3QgaW5wdXQpXG4gICAqIEBwYXJhbSB7P1N0cmluZ1tdfSBbb3B0aW9uc10gYXJyYXkgb2Ygb3V0cHV0IG9wdGlvbnMgdG8gcmV0dXJuXG4gICAqIEBwYXJhbSB7RmZtcGVnQ29tbWFuZH5mZnByb2JlQ2FsbGJhY2t9IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqXG4gICAqL1xuICBwcm90by5mZnByb2JlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlucHV0LCBpbmRleCA9IG51bGwsIG9wdGlvbnMgPSBbXSwgY2FsbGJhY2s7XG5cbiAgICAvLyB0aGUgbGFzdCBhcmd1bWVudCBzaG91bGQgYmUgdGhlIGNhbGxiYWNrXG4gICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcblxuICAgIHZhciBlbmRlZCA9IGZhbHNlXG4gICAgZnVuY3Rpb24gaGFuZGxlQ2FsbGJhY2soZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoIWVuZGVkKSB7XG4gICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gbWFwIHRoZSBhcmd1bWVudHMgdG8gdGhlIGNvcnJlY3QgdmFyaWFibGUgbmFtZXNcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBpbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICBvcHRpb25zID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuXG4gICAgaWYgKGluZGV4ID09PSBudWxsKSB7XG4gICAgICBpZiAoIXRoaXMuX2N1cnJlbnRJbnB1dCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlQ2FsbGJhY2sobmV3IEVycm9yKCdObyBpbnB1dCBzcGVjaWZpZWQnKSk7XG4gICAgICB9XG5cbiAgICAgIGlucHV0ID0gdGhpcy5fY3VycmVudElucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnB1dCA9IHRoaXMuX2lucHV0c1tpbmRleF07XG5cbiAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUNhbGxiYWNrKG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBpbmRleCcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaW5kIGZmcHJvYmVcbiAgICB0aGlzLl9nZXRGZnByb2JlUGF0aChmdW5jdGlvbihlcnIsIHBhdGgpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUNhbGxiYWNrKGVycik7XG4gICAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVDYWxsYmFjayhuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGZmcHJvYmUnKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGRvdXQgPSAnJztcbiAgICAgIHZhciBzdGRvdXRDbG9zZWQgPSBmYWxzZTtcbiAgICAgIHZhciBzdGRlcnIgPSAnJztcbiAgICAgIHZhciBzdGRlcnJDbG9zZWQgPSBmYWxzZTtcblxuICAgICAgLy8gU3Bhd24gZmZwcm9iZVxuICAgICAgdmFyIHNyYyA9IGlucHV0LmlzU3RyZWFtID8gJ3BpcGU6MCcgOiBpbnB1dC5zb3VyY2U7XG4gICAgICB2YXIgZmZwcm9iZSA9IHNwYXduKHBhdGgsIFsnLXNob3dfc3RyZWFtcycsICctc2hvd19mb3JtYXQnXS5jb25jYXQob3B0aW9ucywgc3JjKSwge3dpbmRvd3NIaWRlOiB0cnVlfSk7XG5cbiAgICAgIGlmIChpbnB1dC5pc1N0cmVhbSkge1xuICAgICAgICAvLyBTa2lwIGVycm9ycyBvbiBzdGRpbi4gVGhlc2UgZ2V0IHRocm93biB3aGVuIGZmcHJvYmUgaXMgY29tcGxldGUgYW5kXG4gICAgICAgIC8vIHRoZXJlIHNlZW1zIHRvIGJlIG5vIHdheSBob29rIGluIGFuZCBjbG9zZSBzdGRpbiBiZWZvcmUgaXQgdGhyb3dzLlxuICAgICAgICBmZnByb2JlLnN0ZGluLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIGlmIChbJ0VDT05OUkVTRVQnLCAnRVBJUEUnLCAnRU9GJ10uaW5kZXhPZihlcnIuY29kZSkgPj0gMCkgeyByZXR1cm47IH1cbiAgICAgICAgICBoYW5kbGVDYWxsYmFjayhlcnIpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBPbmNlIGZmcHJvYmUncyBpbnB1dCBzdHJlYW0gY2xvc2VzLCB3ZSBuZWVkIG5vIG1vcmUgZGF0YSBmcm9tIHRoZVxuICAgICAgICAvLyBpbnB1dFxuICAgICAgICBmZnByb2JlLnN0ZGluLm9uKCdjbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaW5wdXQuc291cmNlLnBhdXNlKCk7XG4gICAgICAgICAgICBpbnB1dC5zb3VyY2UudW5waXBlKGZmcHJvYmUuc3RkaW4pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpbnB1dC5zb3VyY2UucGlwZShmZnByb2JlLnN0ZGluKTtcbiAgICAgIH1cblxuICAgICAgZmZwcm9iZS5vbignZXJyb3InLCBjYWxsYmFjayk7XG5cbiAgICAgIC8vIEVuc3VyZSB3ZSB3YWl0IGZvciBjYXB0dXJlZCBzdHJlYW1zIHRvIGVuZCBiZWZvcmUgY2FsbGluZyBjYWxsYmFja1xuICAgICAgdmFyIGV4aXRFcnJvciA9IG51bGw7XG4gICAgICBmdW5jdGlvbiBoYW5kbGVFeGl0KGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZXhpdEVycm9yID0gZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb2Nlc3NFeGl0ZWQgJiYgc3Rkb3V0Q2xvc2VkICYmIHN0ZGVyckNsb3NlZCkge1xuICAgICAgICAgIGlmIChleGl0RXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChzdGRlcnIpIHtcbiAgICAgICAgICAgICAgZXhpdEVycm9yLm1lc3NhZ2UgKz0gJ1xcbicgKyBzdGRlcnI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVDYWxsYmFjayhleGl0RXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFByb2Nlc3Mgb3V0cHV0XG4gICAgICAgICAgdmFyIGRhdGEgPSBwYXJzZUZmcHJvYmVPdXRwdXQoc3Rkb3V0KTtcblxuICAgICAgICAgIC8vIEhhbmRsZSBsZWdhY3kgb3V0cHV0IHdpdGggXCJUQUc6eFwiIGFuZCBcIkRJU1BPU0lUSU9OOnhcIiBrZXlzXG4gICAgICAgICAgW2RhdGEuZm9ybWF0XS5jb25jYXQoZGF0YS5zdHJlYW1zKS5mb3JFYWNoKGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICB2YXIgbGVnYWN5VGFnS2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCkuZmlsdGVyKGxlZ2FjeVRhZyk7XG5cbiAgICAgICAgICAgICAgaWYgKGxlZ2FjeVRhZ0tleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnRhZ3MgPSB0YXJnZXQudGFncyB8fCB7fTtcblxuICAgICAgICAgICAgICAgIGxlZ2FjeVRhZ0tleXMuZm9yRWFjaChmdW5jdGlvbih0YWdLZXkpIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldC50YWdzW3RhZ0tleS5zdWJzdHIoNCldID0gdGFyZ2V0W3RhZ0tleV07XG4gICAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0W3RhZ0tleV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgbGVnYWN5RGlzcG9zaXRpb25LZXlzID0gT2JqZWN0LmtleXModGFyZ2V0KS5maWx0ZXIobGVnYWN5RGlzcG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgIGlmIChsZWdhY3lEaXNwb3NpdGlvbktleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmRpc3Bvc2l0aW9uID0gdGFyZ2V0LmRpc3Bvc2l0aW9uIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgbGVnYWN5RGlzcG9zaXRpb25LZXlzLmZvckVhY2goZnVuY3Rpb24oZGlzcG9zaXRpb25LZXkpIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldC5kaXNwb3NpdGlvbltkaXNwb3NpdGlvbktleS5zdWJzdHIoMTIpXSA9IHRhcmdldFtkaXNwb3NpdGlvbktleV07XG4gICAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0W2Rpc3Bvc2l0aW9uS2V5XTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaGFuZGxlQ2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIGZmcHJvYmUgZXhpdFxuICAgICAgdmFyIHByb2Nlc3NFeGl0ZWQgPSBmYWxzZTtcbiAgICAgIGZmcHJvYmUub24oJ2V4aXQnLCBmdW5jdGlvbihjb2RlLCBzaWduYWwpIHtcbiAgICAgICAgcHJvY2Vzc0V4aXRlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICBoYW5kbGVFeGl0KG5ldyBFcnJvcignZmZwcm9iZSBleGl0ZWQgd2l0aCBjb2RlICcgKyBjb2RlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgaGFuZGxlRXhpdChuZXcgRXJyb3IoJ2ZmcHJvYmUgd2FzIGtpbGxlZCB3aXRoIHNpZ25hbCAnICsgc2lnbmFsKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlRXhpdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gSGFuZGxlIHN0ZG91dC9zdGRlcnIgc3RyZWFtc1xuICAgICAgZmZwcm9iZS5zdGRvdXQub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHN0ZG91dCArPSBkYXRhO1xuICAgICAgfSk7XG5cbiAgICAgIGZmcHJvYmUuc3Rkb3V0Lm9uKCdjbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzdGRvdXRDbG9zZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVFeGl0KCk7XG4gICAgICB9KTtcblxuICAgICAgZmZwcm9iZS5zdGRlcnIub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHN0ZGVyciArPSBkYXRhO1xuICAgICAgfSk7XG5cbiAgICAgIGZmcHJvYmUuc3RkZXJyLm9uKCdjbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzdGRlcnJDbG9zZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVFeGl0KCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/ffprobe.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/fluent-ffmpeg.js":
/*!*********************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/fluent-ffmpeg.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar path = __webpack_require__(/*! path */ \"path?8ff8\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\");\nvar ARGLISTS = ['_global', '_audio', '_audioFilters', '_video', '_videoFilters', '_sizeFilters', '_complexFilters'];\n\n\n/**\n * Create an ffmpeg command\n *\n * Can be called with or without the 'new' operator, and the 'input' parameter\n * may be specified as 'options.source' instead (or passed later with the\n * addInput method).\n *\n * @constructor\n * @param {String|ReadableStream} [input] input file path or readable stream\n * @param {Object} [options] command options\n * @param {Object} [options.logger=<no logging>] logger object with 'error', 'warning', 'info' and 'debug' methods\n * @param {Number} [options.niceness=0] ffmpeg process niceness, ignored on Windows\n * @param {Number} [options.priority=0] alias for `niceness`\n * @param {String} [options.presets=\"fluent-ffmpeg/lib/presets\"] directory to load presets from\n * @param {String} [options.preset=\"fluent-ffmpeg/lib/presets\"] alias for `presets`\n * @param {String} [options.stdoutLines=100] maximum lines of ffmpeg output to keep in memory, use 0 for unlimited\n * @param {Number} [options.timeout=<no timeout>] ffmpeg processing timeout in seconds\n * @param {String|ReadableStream} [options.source=<no input>] alias for the `input` parameter\n */\nfunction FfmpegCommand(input, options) {\n  // Make 'new' optional\n  if (!(this instanceof FfmpegCommand)) {\n    return new FfmpegCommand(input, options);\n  }\n\n  EventEmitter.call(this);\n\n  if (typeof input === 'object' && !('readable' in input)) {\n    // Options object passed directly\n    options = input;\n  } else {\n    // Input passed first\n    options = options || {};\n    options.source = input;\n  }\n\n  // Add input if present\n  this._inputs = [];\n  if (options.source) {\n    this.input(options.source);\n  }\n\n  // Add target-less output for backwards compatibility\n  this._outputs = [];\n  this.output();\n\n  // Create argument lists\n  var self = this;\n  ['_global', '_complexFilters'].forEach(function(prop) {\n    self[prop] = utils.args();\n  });\n\n  // Set default option values\n  options.stdoutLines = 'stdoutLines' in options ? options.stdoutLines : 100;\n  options.presets = options.presets || options.preset || path.join(__dirname, 'presets');\n  options.niceness = options.niceness || options.priority || 0;\n\n  // Save options\n  this.options = options;\n\n  // Setup logger\n  this.logger = options.logger || {\n    debug: function() {},\n    info: function() {},\n    warn: function() {},\n    error: function() {}\n  };\n}\nutil.inherits(FfmpegCommand, EventEmitter);\nmodule.exports = FfmpegCommand;\n\n\n/**\n * Clone an ffmpeg command\n *\n * This method is useful when you want to process the same input multiple times.\n * It returns a new FfmpegCommand instance with the exact same options.\n *\n * All options set _after_ the clone() call will only be applied to the instance\n * it has been called on.\n *\n * @example\n *   var command = ffmpeg('/path/to/source.avi')\n *     .audioCodec('libfaac')\n *     .videoCodec('libx264')\n *     .format('mp4');\n *\n *   command.clone()\n *     .size('320x200')\n *     .save('/path/to/output-small.mp4');\n *\n *   command.clone()\n *     .size('640x400')\n *     .save('/path/to/output-medium.mp4');\n *\n *   command.save('/path/to/output-original-size.mp4');\n *\n * @method FfmpegCommand#clone\n * @return FfmpegCommand\n */\nFfmpegCommand.prototype.clone = function() {\n  var clone = new FfmpegCommand();\n  var self = this;\n\n  // Clone options and logger\n  clone.options = this.options;\n  clone.logger = this.logger;\n\n  // Clone inputs\n  clone._inputs = this._inputs.map(function(input) {\n    return {\n      source: input.source,\n      options: input.options.clone()\n    };\n  });\n\n  // Create first output\n  if ('target' in this._outputs[0]) {\n    // We have outputs set, don't clone them and create first output\n    clone._outputs = [];\n    clone.output();\n  } else {\n    // No outputs set, clone first output options\n    clone._outputs = [\n      clone._currentOutput = {\n        flags: {}\n      }\n    ];\n\n    ['audio', 'audioFilters', 'video', 'videoFilters', 'sizeFilters', 'options'].forEach(function(key) {\n      clone._currentOutput[key] = self._currentOutput[key].clone();\n    });\n\n    if (this._currentOutput.sizeData) {\n      clone._currentOutput.sizeData = {};\n      utils.copy(this._currentOutput.sizeData, clone._currentOutput.sizeData);\n    }\n\n    utils.copy(this._currentOutput.flags, clone._currentOutput.flags);\n  }\n\n  // Clone argument lists\n  ['_global', '_complexFilters'].forEach(function(prop) {\n    clone[prop] = self[prop].clone();\n  });\n\n  return clone;\n};\n\n\n/* Add methods from options submodules */\n\n__webpack_require__(/*! ./options/inputs */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/options/inputs.js\")(FfmpegCommand.prototype);\n__webpack_require__(/*! ./options/audio */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/options/audio.js\")(FfmpegCommand.prototype);\n__webpack_require__(/*! ./options/video */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/options/video.js\")(FfmpegCommand.prototype);\n__webpack_require__(/*! ./options/videosize */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/options/videosize.js\")(FfmpegCommand.prototype);\n__webpack_require__(/*! ./options/output */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/options/output.js\")(FfmpegCommand.prototype);\n__webpack_require__(/*! ./options/custom */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/options/custom.js\")(FfmpegCommand.prototype);\n__webpack_require__(/*! ./options/misc */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/options/misc.js\")(FfmpegCommand.prototype);\n\n\n/* Add processor methods */\n\n__webpack_require__(/*! ./processor */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/processor.js\")(FfmpegCommand.prototype);\n\n\n/* Add capabilities methods */\n\n__webpack_require__(/*! ./capabilities */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/capabilities.js\")(FfmpegCommand.prototype);\n\nFfmpegCommand.setFfmpegPath = function(path) {\n  (new FfmpegCommand()).setFfmpegPath(path);\n};\n\nFfmpegCommand.setFfprobePath = function(path) {\n  (new FfmpegCommand()).setFfprobePath(path);\n};\n\nFfmpegCommand.setFlvtoolPath = function(path) {\n  (new FfmpegCommand()).setFlvtoolPath(path);\n};\n\nFfmpegCommand.availableFilters =\nFfmpegCommand.getAvailableFilters = function(callback) {\n  (new FfmpegCommand()).availableFilters(callback);\n};\n\nFfmpegCommand.availableCodecs =\nFfmpegCommand.getAvailableCodecs = function(callback) {\n  (new FfmpegCommand()).availableCodecs(callback);\n};\n\nFfmpegCommand.availableFormats =\nFfmpegCommand.getAvailableFormats = function(callback) {\n  (new FfmpegCommand()).availableFormats(callback);\n};\n\nFfmpegCommand.availableEncoders =\nFfmpegCommand.getAvailableEncoders = function(callback) {\n  (new FfmpegCommand()).availableEncoders(callback);\n};\n\n\n/* Add ffprobe methods */\n\n__webpack_require__(/*! ./ffprobe */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/ffprobe.js\")(FfmpegCommand.prototype);\n\nFfmpegCommand.ffprobe = function(file) {\n  var instance = new FfmpegCommand(file);\n  instance.ffprobe.apply(instance, Array.prototype.slice.call(arguments, 1));\n};\n\n/* Add processing recipes */\n\n__webpack_require__(/*! ./recipes */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/recipes.js\")(FfmpegCommand.prototype);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvZmx1ZW50LWZmbXBlZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyx1QkFBTTtBQUN6QixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsbUJBQW1CLDBEQUE4Qjs7QUFFakQsWUFBWSxtQkFBTyxDQUFDLGdFQUFTO0FBQzdCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7O0FBRUEsbUJBQU8sQ0FBQyxrRkFBa0I7QUFDMUIsbUJBQU8sQ0FBQyxnRkFBaUI7QUFDekIsbUJBQU8sQ0FBQyxnRkFBaUI7QUFDekIsbUJBQU8sQ0FBQyx3RkFBcUI7QUFDN0IsbUJBQU8sQ0FBQyxrRkFBa0I7QUFDMUIsbUJBQU8sQ0FBQyxrRkFBa0I7QUFDMUIsbUJBQU8sQ0FBQyw4RUFBZ0I7OztBQUd4Qjs7QUFFQSxtQkFBTyxDQUFDLHdFQUFhOzs7QUFHckI7O0FBRUEsbUJBQU8sQ0FBQyw4RUFBZ0I7O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxtQkFBTyxDQUFDLG9FQUFXOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBTyxDQUFDLG9FQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWZpcmViYXNlLWFwaS8uL25vZGVfbW9kdWxlcy9mbHVlbnQtZmZtcGVnL2xpYi9mbHVlbnQtZmZtcGVnLmpzPzQ0ODgiXSwic291cmNlc0NvbnRlbnQiOlsiLypqc2hpbnQgbm9kZTp0cnVlKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBBUkdMSVNUUyA9IFsnX2dsb2JhbCcsICdfYXVkaW8nLCAnX2F1ZGlvRmlsdGVycycsICdfdmlkZW8nLCAnX3ZpZGVvRmlsdGVycycsICdfc2l6ZUZpbHRlcnMnLCAnX2NvbXBsZXhGaWx0ZXJzJ107XG5cblxuLyoqXG4gKiBDcmVhdGUgYW4gZmZtcGVnIGNvbW1hbmRcbiAqXG4gKiBDYW4gYmUgY2FsbGVkIHdpdGggb3Igd2l0aG91dCB0aGUgJ25ldycgb3BlcmF0b3IsIGFuZCB0aGUgJ2lucHV0JyBwYXJhbWV0ZXJcbiAqIG1heSBiZSBzcGVjaWZpZWQgYXMgJ29wdGlvbnMuc291cmNlJyBpbnN0ZWFkIChvciBwYXNzZWQgbGF0ZXIgd2l0aCB0aGVcbiAqIGFkZElucHV0IG1ldGhvZCkuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWFkYWJsZVN0cmVhbX0gW2lucHV0XSBpbnB1dCBmaWxlIHBhdGggb3IgcmVhZGFibGUgc3RyZWFtXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIGNvbW1hbmQgb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmxvZ2dlcj08bm8gbG9nZ2luZz5dIGxvZ2dlciBvYmplY3Qgd2l0aCAnZXJyb3InLCAnd2FybmluZycsICdpbmZvJyBhbmQgJ2RlYnVnJyBtZXRob2RzXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubmljZW5lc3M9MF0gZmZtcGVnIHByb2Nlc3MgbmljZW5lc3MsIGlnbm9yZWQgb24gV2luZG93c1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnByaW9yaXR5PTBdIGFsaWFzIGZvciBgbmljZW5lc3NgXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJlc2V0cz1cImZsdWVudC1mZm1wZWcvbGliL3ByZXNldHNcIl0gZGlyZWN0b3J5IHRvIGxvYWQgcHJlc2V0cyBmcm9tXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJlc2V0PVwiZmx1ZW50LWZmbXBlZy9saWIvcHJlc2V0c1wiXSBhbGlhcyBmb3IgYHByZXNldHNgXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3Rkb3V0TGluZXM9MTAwXSBtYXhpbXVtIGxpbmVzIG9mIGZmbXBlZyBvdXRwdXQgdG8ga2VlcCBpbiBtZW1vcnksIHVzZSAwIGZvciB1bmxpbWl0ZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aW1lb3V0PTxubyB0aW1lb3V0Pl0gZmZtcGVnIHByb2Nlc3NpbmcgdGltZW91dCBpbiBzZWNvbmRzXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWFkYWJsZVN0cmVhbX0gW29wdGlvbnMuc291cmNlPTxubyBpbnB1dD5dIGFsaWFzIGZvciB0aGUgYGlucHV0YCBwYXJhbWV0ZXJcbiAqL1xuZnVuY3Rpb24gRmZtcGVnQ29tbWFuZChpbnB1dCwgb3B0aW9ucykge1xuICAvLyBNYWtlICduZXcnIG9wdGlvbmFsXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGZm1wZWdDb21tYW5kKSkge1xuICAgIHJldHVybiBuZXcgRmZtcGVnQ29tbWFuZChpbnB1dCwgb3B0aW9ucyk7XG4gIH1cblxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiAhKCdyZWFkYWJsZScgaW4gaW5wdXQpKSB7XG4gICAgLy8gT3B0aW9ucyBvYmplY3QgcGFzc2VkIGRpcmVjdGx5XG4gICAgb3B0aW9ucyA9IGlucHV0O1xuICB9IGVsc2Uge1xuICAgIC8vIElucHV0IHBhc3NlZCBmaXJzdFxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuc291cmNlID0gaW5wdXQ7XG4gIH1cblxuICAvLyBBZGQgaW5wdXQgaWYgcHJlc2VudFxuICB0aGlzLl9pbnB1dHMgPSBbXTtcbiAgaWYgKG9wdGlvbnMuc291cmNlKSB7XG4gICAgdGhpcy5pbnB1dChvcHRpb25zLnNvdXJjZSk7XG4gIH1cblxuICAvLyBBZGQgdGFyZ2V0LWxlc3Mgb3V0cHV0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICB0aGlzLl9vdXRwdXRzID0gW107XG4gIHRoaXMub3V0cHV0KCk7XG5cbiAgLy8gQ3JlYXRlIGFyZ3VtZW50IGxpc3RzXG4gIHZhciBzZWxmID0gdGhpcztcbiAgWydfZ2xvYmFsJywgJ19jb21wbGV4RmlsdGVycyddLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgIHNlbGZbcHJvcF0gPSB1dGlscy5hcmdzKCk7XG4gIH0pO1xuXG4gIC8vIFNldCBkZWZhdWx0IG9wdGlvbiB2YWx1ZXNcbiAgb3B0aW9ucy5zdGRvdXRMaW5lcyA9ICdzdGRvdXRMaW5lcycgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3Rkb3V0TGluZXMgOiAxMDA7XG4gIG9wdGlvbnMucHJlc2V0cyA9IG9wdGlvbnMucHJlc2V0cyB8fCBvcHRpb25zLnByZXNldCB8fCBwYXRoLmpvaW4oX19kaXJuYW1lLCAncHJlc2V0cycpO1xuICBvcHRpb25zLm5pY2VuZXNzID0gb3B0aW9ucy5uaWNlbmVzcyB8fCBvcHRpb25zLnByaW9yaXR5IHx8IDA7XG5cbiAgLy8gU2F2ZSBvcHRpb25zXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgLy8gU2V0dXAgbG9nZ2VyXG4gIHRoaXMubG9nZ2VyID0gb3B0aW9ucy5sb2dnZXIgfHwge1xuICAgIGRlYnVnOiBmdW5jdGlvbigpIHt9LFxuICAgIGluZm86IGZ1bmN0aW9uKCkge30sXG4gICAgd2FybjogZnVuY3Rpb24oKSB7fSxcbiAgICBlcnJvcjogZnVuY3Rpb24oKSB7fVxuICB9O1xufVxudXRpbC5pbmhlcml0cyhGZm1wZWdDb21tYW5kLCBFdmVudEVtaXR0ZXIpO1xubW9kdWxlLmV4cG9ydHMgPSBGZm1wZWdDb21tYW5kO1xuXG5cbi8qKlxuICogQ2xvbmUgYW4gZmZtcGVnIGNvbW1hbmRcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBwcm9jZXNzIHRoZSBzYW1lIGlucHV0IG11bHRpcGxlIHRpbWVzLlxuICogSXQgcmV0dXJucyBhIG5ldyBGZm1wZWdDb21tYW5kIGluc3RhbmNlIHdpdGggdGhlIGV4YWN0IHNhbWUgb3B0aW9ucy5cbiAqXG4gKiBBbGwgb3B0aW9ucyBzZXQgX2FmdGVyXyB0aGUgY2xvbmUoKSBjYWxsIHdpbGwgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBpbnN0YW5jZVxuICogaXQgaGFzIGJlZW4gY2FsbGVkIG9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIHZhciBjb21tYW5kID0gZmZtcGVnKCcvcGF0aC90by9zb3VyY2UuYXZpJylcbiAqICAgICAuYXVkaW9Db2RlYygnbGliZmFhYycpXG4gKiAgICAgLnZpZGVvQ29kZWMoJ2xpYngyNjQnKVxuICogICAgIC5mb3JtYXQoJ21wNCcpO1xuICpcbiAqICAgY29tbWFuZC5jbG9uZSgpXG4gKiAgICAgLnNpemUoJzMyMHgyMDAnKVxuICogICAgIC5zYXZlKCcvcGF0aC90by9vdXRwdXQtc21hbGwubXA0Jyk7XG4gKlxuICogICBjb21tYW5kLmNsb25lKClcbiAqICAgICAuc2l6ZSgnNjQweDQwMCcpXG4gKiAgICAgLnNhdmUoJy9wYXRoL3RvL291dHB1dC1tZWRpdW0ubXA0Jyk7XG4gKlxuICogICBjb21tYW5kLnNhdmUoJy9wYXRoL3RvL291dHB1dC1vcmlnaW5hbC1zaXplLm1wNCcpO1xuICpcbiAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNjbG9uZVxuICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gKi9cbkZmbXBlZ0NvbW1hbmQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjbG9uZSA9IG5ldyBGZm1wZWdDb21tYW5kKCk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBDbG9uZSBvcHRpb25zIGFuZCBsb2dnZXJcbiAgY2xvbmUub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgY2xvbmUubG9nZ2VyID0gdGhpcy5sb2dnZXI7XG5cbiAgLy8gQ2xvbmUgaW5wdXRzXG4gIGNsb25lLl9pbnB1dHMgPSB0aGlzLl9pbnB1dHMubWFwKGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNvdXJjZTogaW5wdXQuc291cmNlLFxuICAgICAgb3B0aW9uczogaW5wdXQub3B0aW9ucy5jbG9uZSgpXG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIGZpcnN0IG91dHB1dFxuICBpZiAoJ3RhcmdldCcgaW4gdGhpcy5fb3V0cHV0c1swXSkge1xuICAgIC8vIFdlIGhhdmUgb3V0cHV0cyBzZXQsIGRvbid0IGNsb25lIHRoZW0gYW5kIGNyZWF0ZSBmaXJzdCBvdXRwdXRcbiAgICBjbG9uZS5fb3V0cHV0cyA9IFtdO1xuICAgIGNsb25lLm91dHB1dCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIE5vIG91dHB1dHMgc2V0LCBjbG9uZSBmaXJzdCBvdXRwdXQgb3B0aW9uc1xuICAgIGNsb25lLl9vdXRwdXRzID0gW1xuICAgICAgY2xvbmUuX2N1cnJlbnRPdXRwdXQgPSB7XG4gICAgICAgIGZsYWdzOiB7fVxuICAgICAgfVxuICAgIF07XG5cbiAgICBbJ2F1ZGlvJywgJ2F1ZGlvRmlsdGVycycsICd2aWRlbycsICd2aWRlb0ZpbHRlcnMnLCAnc2l6ZUZpbHRlcnMnLCAnb3B0aW9ucyddLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBjbG9uZS5fY3VycmVudE91dHB1dFtrZXldID0gc2VsZi5fY3VycmVudE91dHB1dFtrZXldLmNsb25lKCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5fY3VycmVudE91dHB1dC5zaXplRGF0YSkge1xuICAgICAgY2xvbmUuX2N1cnJlbnRPdXRwdXQuc2l6ZURhdGEgPSB7fTtcbiAgICAgIHV0aWxzLmNvcHkodGhpcy5fY3VycmVudE91dHB1dC5zaXplRGF0YSwgY2xvbmUuX2N1cnJlbnRPdXRwdXQuc2l6ZURhdGEpO1xuICAgIH1cblxuICAgIHV0aWxzLmNvcHkodGhpcy5fY3VycmVudE91dHB1dC5mbGFncywgY2xvbmUuX2N1cnJlbnRPdXRwdXQuZmxhZ3MpO1xuICB9XG5cbiAgLy8gQ2xvbmUgYXJndW1lbnQgbGlzdHNcbiAgWydfZ2xvYmFsJywgJ19jb21wbGV4RmlsdGVycyddLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgIGNsb25lW3Byb3BdID0gc2VsZltwcm9wXS5jbG9uZSgpO1xuICB9KTtcblxuICByZXR1cm4gY2xvbmU7XG59O1xuXG5cbi8qIEFkZCBtZXRob2RzIGZyb20gb3B0aW9ucyBzdWJtb2R1bGVzICovXG5cbnJlcXVpcmUoJy4vb3B0aW9ucy9pbnB1dHMnKShGZm1wZWdDb21tYW5kLnByb3RvdHlwZSk7XG5yZXF1aXJlKCcuL29wdGlvbnMvYXVkaW8nKShGZm1wZWdDb21tYW5kLnByb3RvdHlwZSk7XG5yZXF1aXJlKCcuL29wdGlvbnMvdmlkZW8nKShGZm1wZWdDb21tYW5kLnByb3RvdHlwZSk7XG5yZXF1aXJlKCcuL29wdGlvbnMvdmlkZW9zaXplJykoRmZtcGVnQ29tbWFuZC5wcm90b3R5cGUpO1xucmVxdWlyZSgnLi9vcHRpb25zL291dHB1dCcpKEZmbXBlZ0NvbW1hbmQucHJvdG90eXBlKTtcbnJlcXVpcmUoJy4vb3B0aW9ucy9jdXN0b20nKShGZm1wZWdDb21tYW5kLnByb3RvdHlwZSk7XG5yZXF1aXJlKCcuL29wdGlvbnMvbWlzYycpKEZmbXBlZ0NvbW1hbmQucHJvdG90eXBlKTtcblxuXG4vKiBBZGQgcHJvY2Vzc29yIG1ldGhvZHMgKi9cblxucmVxdWlyZSgnLi9wcm9jZXNzb3InKShGZm1wZWdDb21tYW5kLnByb3RvdHlwZSk7XG5cblxuLyogQWRkIGNhcGFiaWxpdGllcyBtZXRob2RzICovXG5cbnJlcXVpcmUoJy4vY2FwYWJpbGl0aWVzJykoRmZtcGVnQ29tbWFuZC5wcm90b3R5cGUpO1xuXG5GZm1wZWdDb21tYW5kLnNldEZmbXBlZ1BhdGggPSBmdW5jdGlvbihwYXRoKSB7XG4gIChuZXcgRmZtcGVnQ29tbWFuZCgpKS5zZXRGZm1wZWdQYXRoKHBhdGgpO1xufTtcblxuRmZtcGVnQ29tbWFuZC5zZXRGZnByb2JlUGF0aCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgKG5ldyBGZm1wZWdDb21tYW5kKCkpLnNldEZmcHJvYmVQYXRoKHBhdGgpO1xufTtcblxuRmZtcGVnQ29tbWFuZC5zZXRGbHZ0b29sUGF0aCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgKG5ldyBGZm1wZWdDb21tYW5kKCkpLnNldEZsdnRvb2xQYXRoKHBhdGgpO1xufTtcblxuRmZtcGVnQ29tbWFuZC5hdmFpbGFibGVGaWx0ZXJzID1cbkZmbXBlZ0NvbW1hbmQuZ2V0QXZhaWxhYmxlRmlsdGVycyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIChuZXcgRmZtcGVnQ29tbWFuZCgpKS5hdmFpbGFibGVGaWx0ZXJzKGNhbGxiYWNrKTtcbn07XG5cbkZmbXBlZ0NvbW1hbmQuYXZhaWxhYmxlQ29kZWNzID1cbkZmbXBlZ0NvbW1hbmQuZ2V0QXZhaWxhYmxlQ29kZWNzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgKG5ldyBGZm1wZWdDb21tYW5kKCkpLmF2YWlsYWJsZUNvZGVjcyhjYWxsYmFjayk7XG59O1xuXG5GZm1wZWdDb21tYW5kLmF2YWlsYWJsZUZvcm1hdHMgPVxuRmZtcGVnQ29tbWFuZC5nZXRBdmFpbGFibGVGb3JtYXRzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgKG5ldyBGZm1wZWdDb21tYW5kKCkpLmF2YWlsYWJsZUZvcm1hdHMoY2FsbGJhY2spO1xufTtcblxuRmZtcGVnQ29tbWFuZC5hdmFpbGFibGVFbmNvZGVycyA9XG5GZm1wZWdDb21tYW5kLmdldEF2YWlsYWJsZUVuY29kZXJzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgKG5ldyBGZm1wZWdDb21tYW5kKCkpLmF2YWlsYWJsZUVuY29kZXJzKGNhbGxiYWNrKTtcbn07XG5cblxuLyogQWRkIGZmcHJvYmUgbWV0aG9kcyAqL1xuXG5yZXF1aXJlKCcuL2ZmcHJvYmUnKShGZm1wZWdDb21tYW5kLnByb3RvdHlwZSk7XG5cbkZmbXBlZ0NvbW1hbmQuZmZwcm9iZSA9IGZ1bmN0aW9uKGZpbGUpIHtcbiAgdmFyIGluc3RhbmNlID0gbmV3IEZmbXBlZ0NvbW1hbmQoZmlsZSk7XG4gIGluc3RhbmNlLmZmcHJvYmUuYXBwbHkoaW5zdGFuY2UsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xufTtcblxuLyogQWRkIHByb2Nlc3NpbmcgcmVjaXBlcyAqL1xuXG5yZXF1aXJlKCcuL3JlY2lwZXMnKShGZm1wZWdDb21tYW5kLnByb3RvdHlwZSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/fluent-ffmpeg.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/options/audio.js":
/*!*********************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/options/audio.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\");\n\n\n/*\n *! Audio-related methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Disable audio in the output\n   *\n   * @method FfmpegCommand#noAudio\n   * @category Audio\n   * @aliases withNoAudio\n   * @return FfmpegCommand\n   */\n  proto.withNoAudio =\n  proto.noAudio = function() {\n    this._currentOutput.audio.clear();\n    this._currentOutput.audioFilters.clear();\n    this._currentOutput.audio('-an');\n\n    return this;\n  };\n\n\n  /**\n   * Specify audio codec\n   *\n   * @method FfmpegCommand#audioCodec\n   * @category Audio\n   * @aliases withAudioCodec\n   *\n   * @param {String} codec audio codec name\n   * @return FfmpegCommand\n   */\n  proto.withAudioCodec =\n  proto.audioCodec = function(codec) {\n    this._currentOutput.audio('-acodec', codec);\n\n    return this;\n  };\n\n\n  /**\n   * Specify audio bitrate\n   *\n   * @method FfmpegCommand#audioBitrate\n   * @category Audio\n   * @aliases withAudioBitrate\n   *\n   * @param {String|Number} bitrate audio bitrate in kbps (with an optional 'k' suffix)\n   * @return FfmpegCommand\n   */\n  proto.withAudioBitrate =\n  proto.audioBitrate = function(bitrate) {\n    this._currentOutput.audio('-b:a', ('' + bitrate).replace(/k?$/, 'k'));\n    return this;\n  };\n\n\n  /**\n   * Specify audio channel count\n   *\n   * @method FfmpegCommand#audioChannels\n   * @category Audio\n   * @aliases withAudioChannels\n   *\n   * @param {Number} channels channel count\n   * @return FfmpegCommand\n   */\n  proto.withAudioChannels =\n  proto.audioChannels = function(channels) {\n    this._currentOutput.audio('-ac', channels);\n    return this;\n  };\n\n\n  /**\n   * Specify audio frequency\n   *\n   * @method FfmpegCommand#audioFrequency\n   * @category Audio\n   * @aliases withAudioFrequency\n   *\n   * @param {Number} freq audio frequency in Hz\n   * @return FfmpegCommand\n   */\n  proto.withAudioFrequency =\n  proto.audioFrequency = function(freq) {\n    this._currentOutput.audio('-ar', freq);\n    return this;\n  };\n\n\n  /**\n   * Specify audio quality\n   *\n   * @method FfmpegCommand#audioQuality\n   * @category Audio\n   * @aliases withAudioQuality\n   *\n   * @param {Number} quality audio quality factor\n   * @return FfmpegCommand\n   */\n  proto.withAudioQuality =\n  proto.audioQuality = function(quality) {\n    this._currentOutput.audio('-aq', quality);\n    return this;\n  };\n\n\n  /**\n   * Specify custom audio filter(s)\n   *\n   * Can be called both with one or many filters, or a filter array.\n   *\n   * @example\n   * command.audioFilters('filter1');\n   *\n   * @example\n   * command.audioFilters('filter1', 'filter2=param1=value1:param2=value2');\n   *\n   * @example\n   * command.audioFilters(['filter1', 'filter2']);\n   *\n   * @example\n   * command.audioFilters([\n   *   {\n   *     filter: 'filter1'\n   *   },\n   *   {\n   *     filter: 'filter2',\n   *     options: 'param=value:param=value'\n   *   }\n   * ]);\n   *\n   * @example\n   * command.audioFilters(\n   *   {\n   *     filter: 'filter1',\n   *     options: ['value1', 'value2']\n   *   },\n   *   {\n   *     filter: 'filter2',\n   *     options: { param1: 'value1', param2: 'value2' }\n   *   }\n   * );\n   *\n   * @method FfmpegCommand#audioFilters\n   * @aliases withAudioFilter,withAudioFilters,audioFilter\n   * @category Audio\n   *\n   * @param {...String|String[]|Object[]} filters audio filter strings, string array or\n   *   filter specification array, each with the following properties:\n   * @param {String} filters.filter filter name\n   * @param {String|String[]|Object} [filters.options] filter option string, array, or object\n   * @return FfmpegCommand\n   */\n  proto.withAudioFilter =\n  proto.withAudioFilters =\n  proto.audioFilter =\n  proto.audioFilters = function(filters) {\n    if (arguments.length > 1) {\n      filters = [].slice.call(arguments);\n    }\n\n    if (!Array.isArray(filters)) {\n      filters = [filters];\n    }\n\n    this._currentOutput.audioFilters(utils.makeFilterStrings(filters));\n    return this;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvb3B0aW9ucy9hdWRpby5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxpRUFBVTs7O0FBRzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQztBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLHdCQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWZpcmViYXNlLWFwaS8uL25vZGVfbW9kdWxlcy9mbHVlbnQtZmZtcGVnL2xpYi9vcHRpb25zL2F1ZGlvLmpzP2YzYjUiXSwic291cmNlc0NvbnRlbnQiOlsiLypqc2hpbnQgbm9kZTp0cnVlKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuXG4vKlxuICohIEF1ZGlvLXJlbGF0ZWQgbWV0aG9kc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocHJvdG8pIHtcbiAgLyoqXG4gICAqIERpc2FibGUgYXVkaW8gaW4gdGhlIG91dHB1dFxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjbm9BdWRpb1xuICAgKiBAY2F0ZWdvcnkgQXVkaW9cbiAgICogQGFsaWFzZXMgd2l0aE5vQXVkaW9cbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by53aXRoTm9BdWRpbyA9XG4gIHByb3RvLm5vQXVkaW8gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LmF1ZGlvLmNsZWFyKCk7XG4gICAgdGhpcy5fY3VycmVudE91dHB1dC5hdWRpb0ZpbHRlcnMuY2xlYXIoKTtcbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LmF1ZGlvKCctYW4nKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgYXVkaW8gY29kZWNcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2F1ZGlvQ29kZWNcbiAgICogQGNhdGVnb3J5IEF1ZGlvXG4gICAqIEBhbGlhc2VzIHdpdGhBdWRpb0NvZGVjXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2RlYyBhdWRpbyBjb2RlYyBuYW1lXG4gICAqIEByZXR1cm4gRmZtcGVnQ29tbWFuZFxuICAgKi9cbiAgcHJvdG8ud2l0aEF1ZGlvQ29kZWMgPVxuICBwcm90by5hdWRpb0NvZGVjID0gZnVuY3Rpb24oY29kZWMpIHtcbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LmF1ZGlvKCctYWNvZGVjJywgY29kZWMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogU3BlY2lmeSBhdWRpbyBiaXRyYXRlXG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNhdWRpb0JpdHJhdGVcbiAgICogQGNhdGVnb3J5IEF1ZGlvXG4gICAqIEBhbGlhc2VzIHdpdGhBdWRpb0JpdHJhdGVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBiaXRyYXRlIGF1ZGlvIGJpdHJhdGUgaW4ga2JwcyAod2l0aCBhbiBvcHRpb25hbCAnaycgc3VmZml4KVxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLndpdGhBdWRpb0JpdHJhdGUgPVxuICBwcm90by5hdWRpb0JpdHJhdGUgPSBmdW5jdGlvbihiaXRyYXRlKSB7XG4gICAgdGhpcy5fY3VycmVudE91dHB1dC5hdWRpbygnLWI6YScsICgnJyArIGJpdHJhdGUpLnJlcGxhY2UoL2s/JC8sICdrJykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgYXVkaW8gY2hhbm5lbCBjb3VudFxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjYXVkaW9DaGFubmVsc1xuICAgKiBAY2F0ZWdvcnkgQXVkaW9cbiAgICogQGFsaWFzZXMgd2l0aEF1ZGlvQ2hhbm5lbHNcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5uZWxzIGNoYW5uZWwgY291bnRcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by53aXRoQXVkaW9DaGFubmVscyA9XG4gIHByb3RvLmF1ZGlvQ2hhbm5lbHMgPSBmdW5jdGlvbihjaGFubmVscykge1xuICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQuYXVkaW8oJy1hYycsIGNoYW5uZWxzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGF1ZGlvIGZyZXF1ZW5jeVxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjYXVkaW9GcmVxdWVuY3lcbiAgICogQGNhdGVnb3J5IEF1ZGlvXG4gICAqIEBhbGlhc2VzIHdpdGhBdWRpb0ZyZXF1ZW5jeVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJlcSBhdWRpbyBmcmVxdWVuY3kgaW4gSHpcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by53aXRoQXVkaW9GcmVxdWVuY3kgPVxuICBwcm90by5hdWRpb0ZyZXF1ZW5jeSA9IGZ1bmN0aW9uKGZyZXEpIHtcbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LmF1ZGlvKCctYXInLCBmcmVxKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGF1ZGlvIHF1YWxpdHlcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2F1ZGlvUXVhbGl0eVxuICAgKiBAY2F0ZWdvcnkgQXVkaW9cbiAgICogQGFsaWFzZXMgd2l0aEF1ZGlvUXVhbGl0eVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gcXVhbGl0eSBhdWRpbyBxdWFsaXR5IGZhY3RvclxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLndpdGhBdWRpb1F1YWxpdHkgPVxuICBwcm90by5hdWRpb1F1YWxpdHkgPSBmdW5jdGlvbihxdWFsaXR5KSB7XG4gICAgdGhpcy5fY3VycmVudE91dHB1dC5hdWRpbygnLWFxJywgcXVhbGl0eSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogU3BlY2lmeSBjdXN0b20gYXVkaW8gZmlsdGVyKHMpXG4gICAqXG4gICAqIENhbiBiZSBjYWxsZWQgYm90aCB3aXRoIG9uZSBvciBtYW55IGZpbHRlcnMsIG9yIGEgZmlsdGVyIGFycmF5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb21tYW5kLmF1ZGlvRmlsdGVycygnZmlsdGVyMScpO1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb21tYW5kLmF1ZGlvRmlsdGVycygnZmlsdGVyMScsICdmaWx0ZXIyPXBhcmFtMT12YWx1ZTE6cGFyYW0yPXZhbHVlMicpO1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb21tYW5kLmF1ZGlvRmlsdGVycyhbJ2ZpbHRlcjEnLCAnZmlsdGVyMiddKTtcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29tbWFuZC5hdWRpb0ZpbHRlcnMoW1xuICAgKiAgIHtcbiAgICogICAgIGZpbHRlcjogJ2ZpbHRlcjEnXG4gICAqICAgfSxcbiAgICogICB7XG4gICAqICAgICBmaWx0ZXI6ICdmaWx0ZXIyJyxcbiAgICogICAgIG9wdGlvbnM6ICdwYXJhbT12YWx1ZTpwYXJhbT12YWx1ZSdcbiAgICogICB9XG4gICAqIF0pO1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb21tYW5kLmF1ZGlvRmlsdGVycyhcbiAgICogICB7XG4gICAqICAgICBmaWx0ZXI6ICdmaWx0ZXIxJyxcbiAgICogICAgIG9wdGlvbnM6IFsndmFsdWUxJywgJ3ZhbHVlMiddXG4gICAqICAgfSxcbiAgICogICB7XG4gICAqICAgICBmaWx0ZXI6ICdmaWx0ZXIyJyxcbiAgICogICAgIG9wdGlvbnM6IHsgcGFyYW0xOiAndmFsdWUxJywgcGFyYW0yOiAndmFsdWUyJyB9XG4gICAqICAgfVxuICAgKiApO1xuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjYXVkaW9GaWx0ZXJzXG4gICAqIEBhbGlhc2VzIHdpdGhBdWRpb0ZpbHRlcix3aXRoQXVkaW9GaWx0ZXJzLGF1ZGlvRmlsdGVyXG4gICAqIEBjYXRlZ29yeSBBdWRpb1xuICAgKlxuICAgKiBAcGFyYW0gey4uLlN0cmluZ3xTdHJpbmdbXXxPYmplY3RbXX0gZmlsdGVycyBhdWRpbyBmaWx0ZXIgc3RyaW5ncywgc3RyaW5nIGFycmF5IG9yXG4gICAqICAgZmlsdGVyIHNwZWNpZmljYXRpb24gYXJyYXksIGVhY2ggd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaWx0ZXJzLmZpbHRlciBmaWx0ZXIgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXXxPYmplY3R9IFtmaWx0ZXJzLm9wdGlvbnNdIGZpbHRlciBvcHRpb24gc3RyaW5nLCBhcnJheSwgb3Igb2JqZWN0XG4gICAqIEByZXR1cm4gRmZtcGVnQ29tbWFuZFxuICAgKi9cbiAgcHJvdG8ud2l0aEF1ZGlvRmlsdGVyID1cbiAgcHJvdG8ud2l0aEF1ZGlvRmlsdGVycyA9XG4gIHByb3RvLmF1ZGlvRmlsdGVyID1cbiAgcHJvdG8uYXVkaW9GaWx0ZXJzID0gZnVuY3Rpb24oZmlsdGVycykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgZmlsdGVycyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsdGVycykpIHtcbiAgICAgIGZpbHRlcnMgPSBbZmlsdGVyc107XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudE91dHB1dC5hdWRpb0ZpbHRlcnModXRpbHMubWFrZUZpbHRlclN0cmluZ3MoZmlsdGVycykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/options/audio.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/options/custom.js":
/*!**********************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/options/custom.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\");\n\n\n/*\n *! Custom options methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Add custom input option(s)\n   *\n   * When passing a single string or an array, each string containing two\n   * words is split (eg. inputOptions('-option value') is supported) for\n   * compatibility reasons.  This is not the case when passing more than\n   * one argument.\n   *\n   * @example\n   * command.inputOptions('option1');\n   *\n   * @example\n   * command.inputOptions('option1', 'option2');\n   *\n   * @example\n   * command.inputOptions(['option1', 'option2']);\n   *\n   * @method FfmpegCommand#inputOptions\n   * @category Custom options\n   * @aliases addInputOption,addInputOptions,withInputOption,withInputOptions,inputOption\n   *\n   * @param {...String} options option string(s) or string array\n   * @return FfmpegCommand\n   */\n  proto.addInputOption =\n  proto.addInputOptions =\n  proto.withInputOption =\n  proto.withInputOptions =\n  proto.inputOption =\n  proto.inputOptions = function(options) {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n\n    var doSplit = true;\n\n    if (arguments.length > 1) {\n      options = [].slice.call(arguments);\n      doSplit = false;\n    }\n\n    if (!Array.isArray(options)) {\n      options = [options];\n    }\n\n    this._currentInput.options(options.reduce(function(options, option) {\n      var split = String(option).split(' ');\n\n      if (doSplit && split.length === 2) {\n        options.push(split[0], split[1]);\n      } else {\n        options.push(option);\n      }\n\n      return options;\n    }, []));\n    return this;\n  };\n\n\n  /**\n   * Add custom output option(s)\n   *\n   * @example\n   * command.outputOptions('option1');\n   *\n   * @example\n   * command.outputOptions('option1', 'option2');\n   *\n   * @example\n   * command.outputOptions(['option1', 'option2']);\n   *\n   * @method FfmpegCommand#outputOptions\n   * @category Custom options\n   * @aliases addOutputOption,addOutputOptions,addOption,addOptions,withOutputOption,withOutputOptions,withOption,withOptions,outputOption\n   *\n   * @param {...String} options option string(s) or string array\n   * @return FfmpegCommand\n   */\n  proto.addOutputOption =\n  proto.addOutputOptions =\n  proto.addOption =\n  proto.addOptions =\n  proto.withOutputOption =\n  proto.withOutputOptions =\n  proto.withOption =\n  proto.withOptions =\n  proto.outputOption =\n  proto.outputOptions = function(options) {\n    var doSplit = true;\n\n    if (arguments.length > 1) {\n      options = [].slice.call(arguments);\n      doSplit = false;\n    }\n\n    if (!Array.isArray(options)) {\n      options = [options];\n    }\n\n    this._currentOutput.options(options.reduce(function(options, option) {\n      var split = String(option).split(' ');\n\n      if (doSplit && split.length === 2) {\n        options.push(split[0], split[1]);\n      } else {\n        options.push(option);\n      }\n\n      return options;\n    }, []));\n    return this;\n  };\n\n\n  /**\n   * Specify a complex filtergraph\n   *\n   * Calling this method will override any previously set filtergraph, but you can set\n   * as many filters as needed in one call.\n   *\n   * @example <caption>Overlay an image over a video (using a filtergraph string)</caption>\n   *   ffmpeg()\n   *     .input('video.avi')\n   *     .input('image.png')\n   *     .complexFilter('[0:v][1:v]overlay[out]', ['out']);\n   *\n   * @example <caption>Overlay an image over a video (using a filter array)</caption>\n   *   ffmpeg()\n   *     .input('video.avi')\n   *     .input('image.png')\n   *     .complexFilter([{\n   *       filter: 'overlay',\n   *       inputs: ['0:v', '1:v'],\n   *       outputs: ['out']\n   *     }], ['out']);\n   *\n   * @example <caption>Split video into RGB channels and output a 3x1 video with channels side to side</caption>\n   *  ffmpeg()\n   *    .input('video.avi')\n   *    .complexFilter([\n   *      // Duplicate video stream 3 times into streams a, b, and c\n   *      { filter: 'split', options: '3', outputs: ['a', 'b', 'c'] },\n   *\n   *      // Create stream 'red' by cancelling green and blue channels from stream 'a'\n   *      { filter: 'lutrgb', options: { g: 0, b: 0 }, inputs: 'a', outputs: 'red' },\n   *\n   *      // Create stream 'green' by cancelling red and blue channels from stream 'b'\n   *      { filter: 'lutrgb', options: { r: 0, b: 0 }, inputs: 'b', outputs: 'green' },\n   *\n   *      // Create stream 'blue' by cancelling red and green channels from stream 'c'\n   *      { filter: 'lutrgb', options: { r: 0, g: 0 }, inputs: 'c', outputs: 'blue' },\n   *\n   *      // Pad stream 'red' to 3x width, keeping the video on the left, and name output 'padded'\n   *      { filter: 'pad', options: { w: 'iw*3', h: 'ih' }, inputs: 'red', outputs: 'padded' },\n   *\n   *      // Overlay 'green' onto 'padded', moving it to the center, and name output 'redgreen'\n   *      { filter: 'overlay', options: { x: 'w', y: 0 }, inputs: ['padded', 'green'], outputs: 'redgreen'},\n   *\n   *      // Overlay 'blue' onto 'redgreen', moving it to the right\n   *      { filter: 'overlay', options: { x: '2*w', y: 0 }, inputs: ['redgreen', 'blue']},\n   *    ]);\n   *\n   * @method FfmpegCommand#complexFilter\n   * @category Custom options\n   * @aliases filterGraph\n   *\n   * @param {String|Array} spec filtergraph string or array of filter specification\n   *   objects, each having the following properties:\n   * @param {String} spec.filter filter name\n   * @param {String|Array} [spec.inputs] (array of) input stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically choosing the first unused matching streams\n   * @param {String|Array} [spec.outputs] (array of) output stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically assigning the output to the output file\n   * @param {Object|String|Array} [spec.options] filter options, can be omitted to not set any options\n   * @param {Array} [map] (array of) stream specifier(s) from the graph to include in\n   *   ffmpeg output, defaults to ffmpeg automatically choosing the first matching streams.\n   * @return FfmpegCommand\n   */\n  proto.filterGraph =\n  proto.complexFilter = function(spec, map) {\n    this._complexFilters.clear();\n\n    if (!Array.isArray(spec)) {\n      spec = [spec];\n    }\n\n    this._complexFilters('-filter_complex', utils.makeFilterStrings(spec).join(';'));\n\n    if (Array.isArray(map)) {\n      var self = this;\n      map.forEach(function(streamSpec) {\n        self._complexFilters('-map', streamSpec.replace(utils.streamRegexp, '[$1]'));\n      });\n    } else if (typeof map === 'string') {\n      this._complexFilters('-map', map.replace(utils.streamRegexp, '[$1]'));\n    }\n\n    return this;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvb3B0aW9ucy9jdXN0b20uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsaUVBQVU7OztBQUc5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBeUQ7QUFDckU7QUFDQTtBQUNBLFlBQVksNkJBQTZCLFlBQVksK0JBQStCO0FBQ3BGO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QixZQUFZLGlDQUFpQztBQUN0RjtBQUNBO0FBQ0EsWUFBWSw2QkFBNkIsWUFBWSxnQ0FBZ0M7QUFDckY7QUFDQTtBQUNBLFlBQVksMEJBQTBCLG9CQUFvQixvQ0FBb0M7QUFDOUY7QUFDQTtBQUNBLFlBQVksOEJBQThCLGNBQWMsbURBQW1EO0FBQzNHO0FBQ0E7QUFDQSxZQUFZLDhCQUE4QixnQkFBZ0IsK0JBQStCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGNBQWM7QUFDM0I7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQyxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRkFBaUY7O0FBRWpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1maXJlYmFzZS1hcGkvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvb3B0aW9ucy9jdXN0b20uanM/OGY3OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzaGludCBub2RlOnRydWUqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5cbi8qXG4gKiEgQ3VzdG9tIG9wdGlvbnMgbWV0aG9kc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocHJvdG8pIHtcbiAgLyoqXG4gICAqIEFkZCBjdXN0b20gaW5wdXQgb3B0aW9uKHMpXG4gICAqXG4gICAqIFdoZW4gcGFzc2luZyBhIHNpbmdsZSBzdHJpbmcgb3IgYW4gYXJyYXksIGVhY2ggc3RyaW5nIGNvbnRhaW5pbmcgdHdvXG4gICAqIHdvcmRzIGlzIHNwbGl0IChlZy4gaW5wdXRPcHRpb25zKCctb3B0aW9uIHZhbHVlJykgaXMgc3VwcG9ydGVkKSBmb3JcbiAgICogY29tcGF0aWJpbGl0eSByZWFzb25zLiAgVGhpcyBpcyBub3QgdGhlIGNhc2Ugd2hlbiBwYXNzaW5nIG1vcmUgdGhhblxuICAgKiBvbmUgYXJndW1lbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbW1hbmQuaW5wdXRPcHRpb25zKCdvcHRpb24xJyk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbW1hbmQuaW5wdXRPcHRpb25zKCdvcHRpb24xJywgJ29wdGlvbjInKTtcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29tbWFuZC5pbnB1dE9wdGlvbnMoWydvcHRpb24xJywgJ29wdGlvbjInXSk7XG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNpbnB1dE9wdGlvbnNcbiAgICogQGNhdGVnb3J5IEN1c3RvbSBvcHRpb25zXG4gICAqIEBhbGlhc2VzIGFkZElucHV0T3B0aW9uLGFkZElucHV0T3B0aW9ucyx3aXRoSW5wdXRPcHRpb24sd2l0aElucHV0T3B0aW9ucyxpbnB1dE9wdGlvblxuICAgKlxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gb3B0aW9ucyBvcHRpb24gc3RyaW5nKHMpIG9yIHN0cmluZyBhcnJheVxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLmFkZElucHV0T3B0aW9uID1cbiAgcHJvdG8uYWRkSW5wdXRPcHRpb25zID1cbiAgcHJvdG8ud2l0aElucHV0T3B0aW9uID1cbiAgcHJvdG8ud2l0aElucHV0T3B0aW9ucyA9XG4gIHByb3RvLmlucHV0T3B0aW9uID1cbiAgcHJvdG8uaW5wdXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5fY3VycmVudElucHV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGlucHV0IHNwZWNpZmllZCcpO1xuICAgIH1cblxuICAgIHZhciBkb1NwbGl0ID0gdHJ1ZTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgb3B0aW9ucyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGRvU3BsaXQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMgPSBbb3B0aW9uc107XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudElucHV0Lm9wdGlvbnMob3B0aW9ucy5yZWR1Y2UoZnVuY3Rpb24ob3B0aW9ucywgb3B0aW9uKSB7XG4gICAgICB2YXIgc3BsaXQgPSBTdHJpbmcob3B0aW9uKS5zcGxpdCgnICcpO1xuXG4gICAgICBpZiAoZG9TcGxpdCAmJiBzcGxpdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgb3B0aW9ucy5wdXNoKHNwbGl0WzBdLCBzcGxpdFsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnB1c2gob3B0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfSwgW10pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBBZGQgY3VzdG9tIG91dHB1dCBvcHRpb24ocylcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29tbWFuZC5vdXRwdXRPcHRpb25zKCdvcHRpb24xJyk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbW1hbmQub3V0cHV0T3B0aW9ucygnb3B0aW9uMScsICdvcHRpb24yJyk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbW1hbmQub3V0cHV0T3B0aW9ucyhbJ29wdGlvbjEnLCAnb3B0aW9uMiddKTtcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI291dHB1dE9wdGlvbnNcbiAgICogQGNhdGVnb3J5IEN1c3RvbSBvcHRpb25zXG4gICAqIEBhbGlhc2VzIGFkZE91dHB1dE9wdGlvbixhZGRPdXRwdXRPcHRpb25zLGFkZE9wdGlvbixhZGRPcHRpb25zLHdpdGhPdXRwdXRPcHRpb24sd2l0aE91dHB1dE9wdGlvbnMsd2l0aE9wdGlvbix3aXRoT3B0aW9ucyxvdXRwdXRPcHRpb25cbiAgICpcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd9IG9wdGlvbnMgb3B0aW9uIHN0cmluZyhzKSBvciBzdHJpbmcgYXJyYXlcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by5hZGRPdXRwdXRPcHRpb24gPVxuICBwcm90by5hZGRPdXRwdXRPcHRpb25zID1cbiAgcHJvdG8uYWRkT3B0aW9uID1cbiAgcHJvdG8uYWRkT3B0aW9ucyA9XG4gIHByb3RvLndpdGhPdXRwdXRPcHRpb24gPVxuICBwcm90by53aXRoT3V0cHV0T3B0aW9ucyA9XG4gIHByb3RvLndpdGhPcHRpb24gPVxuICBwcm90by53aXRoT3B0aW9ucyA9XG4gIHByb3RvLm91dHB1dE9wdGlvbiA9XG4gIHByb3RvLm91dHB1dE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGRvU3BsaXQgPSB0cnVlO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBvcHRpb25zID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgZG9TcGxpdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucyA9IFtvcHRpb25zXTtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0Lm9wdGlvbnMob3B0aW9ucy5yZWR1Y2UoZnVuY3Rpb24ob3B0aW9ucywgb3B0aW9uKSB7XG4gICAgICB2YXIgc3BsaXQgPSBTdHJpbmcob3B0aW9uKS5zcGxpdCgnICcpO1xuXG4gICAgICBpZiAoZG9TcGxpdCAmJiBzcGxpdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgb3B0aW9ucy5wdXNoKHNwbGl0WzBdLCBzcGxpdFsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnB1c2gob3B0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfSwgW10pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGEgY29tcGxleCBmaWx0ZXJncmFwaFxuICAgKlxuICAgKiBDYWxsaW5nIHRoaXMgbWV0aG9kIHdpbGwgb3ZlcnJpZGUgYW55IHByZXZpb3VzbHkgc2V0IGZpbHRlcmdyYXBoLCBidXQgeW91IGNhbiBzZXRcbiAgICogYXMgbWFueSBmaWx0ZXJzIGFzIG5lZWRlZCBpbiBvbmUgY2FsbC5cbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+T3ZlcmxheSBhbiBpbWFnZSBvdmVyIGEgdmlkZW8gKHVzaW5nIGEgZmlsdGVyZ3JhcGggc3RyaW5nKTwvY2FwdGlvbj5cbiAgICogICBmZm1wZWcoKVxuICAgKiAgICAgLmlucHV0KCd2aWRlby5hdmknKVxuICAgKiAgICAgLmlucHV0KCdpbWFnZS5wbmcnKVxuICAgKiAgICAgLmNvbXBsZXhGaWx0ZXIoJ1swOnZdWzE6dl1vdmVybGF5W291dF0nLCBbJ291dCddKTtcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+T3ZlcmxheSBhbiBpbWFnZSBvdmVyIGEgdmlkZW8gKHVzaW5nIGEgZmlsdGVyIGFycmF5KTwvY2FwdGlvbj5cbiAgICogICBmZm1wZWcoKVxuICAgKiAgICAgLmlucHV0KCd2aWRlby5hdmknKVxuICAgKiAgICAgLmlucHV0KCdpbWFnZS5wbmcnKVxuICAgKiAgICAgLmNvbXBsZXhGaWx0ZXIoW3tcbiAgICogICAgICAgZmlsdGVyOiAnb3ZlcmxheScsXG4gICAqICAgICAgIGlucHV0czogWycwOnYnLCAnMTp2J10sXG4gICAqICAgICAgIG91dHB1dHM6IFsnb3V0J11cbiAgICogICAgIH1dLCBbJ291dCddKTtcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+U3BsaXQgdmlkZW8gaW50byBSR0IgY2hhbm5lbHMgYW5kIG91dHB1dCBhIDN4MSB2aWRlbyB3aXRoIGNoYW5uZWxzIHNpZGUgdG8gc2lkZTwvY2FwdGlvbj5cbiAgICogIGZmbXBlZygpXG4gICAqICAgIC5pbnB1dCgndmlkZW8uYXZpJylcbiAgICogICAgLmNvbXBsZXhGaWx0ZXIoW1xuICAgKiAgICAgIC8vIER1cGxpY2F0ZSB2aWRlbyBzdHJlYW0gMyB0aW1lcyBpbnRvIHN0cmVhbXMgYSwgYiwgYW5kIGNcbiAgICogICAgICB7IGZpbHRlcjogJ3NwbGl0Jywgb3B0aW9uczogJzMnLCBvdXRwdXRzOiBbJ2EnLCAnYicsICdjJ10gfSxcbiAgICpcbiAgICogICAgICAvLyBDcmVhdGUgc3RyZWFtICdyZWQnIGJ5IGNhbmNlbGxpbmcgZ3JlZW4gYW5kIGJsdWUgY2hhbm5lbHMgZnJvbSBzdHJlYW0gJ2EnXG4gICAqICAgICAgeyBmaWx0ZXI6ICdsdXRyZ2InLCBvcHRpb25zOiB7IGc6IDAsIGI6IDAgfSwgaW5wdXRzOiAnYScsIG91dHB1dHM6ICdyZWQnIH0sXG4gICAqXG4gICAqICAgICAgLy8gQ3JlYXRlIHN0cmVhbSAnZ3JlZW4nIGJ5IGNhbmNlbGxpbmcgcmVkIGFuZCBibHVlIGNoYW5uZWxzIGZyb20gc3RyZWFtICdiJ1xuICAgKiAgICAgIHsgZmlsdGVyOiAnbHV0cmdiJywgb3B0aW9uczogeyByOiAwLCBiOiAwIH0sIGlucHV0czogJ2InLCBvdXRwdXRzOiAnZ3JlZW4nIH0sXG4gICAqXG4gICAqICAgICAgLy8gQ3JlYXRlIHN0cmVhbSAnYmx1ZScgYnkgY2FuY2VsbGluZyByZWQgYW5kIGdyZWVuIGNoYW5uZWxzIGZyb20gc3RyZWFtICdjJ1xuICAgKiAgICAgIHsgZmlsdGVyOiAnbHV0cmdiJywgb3B0aW9uczogeyByOiAwLCBnOiAwIH0sIGlucHV0czogJ2MnLCBvdXRwdXRzOiAnYmx1ZScgfSxcbiAgICpcbiAgICogICAgICAvLyBQYWQgc3RyZWFtICdyZWQnIHRvIDN4IHdpZHRoLCBrZWVwaW5nIHRoZSB2aWRlbyBvbiB0aGUgbGVmdCwgYW5kIG5hbWUgb3V0cHV0ICdwYWRkZWQnXG4gICAqICAgICAgeyBmaWx0ZXI6ICdwYWQnLCBvcHRpb25zOiB7IHc6ICdpdyozJywgaDogJ2loJyB9LCBpbnB1dHM6ICdyZWQnLCBvdXRwdXRzOiAncGFkZGVkJyB9LFxuICAgKlxuICAgKiAgICAgIC8vIE92ZXJsYXkgJ2dyZWVuJyBvbnRvICdwYWRkZWQnLCBtb3ZpbmcgaXQgdG8gdGhlIGNlbnRlciwgYW5kIG5hbWUgb3V0cHV0ICdyZWRncmVlbidcbiAgICogICAgICB7IGZpbHRlcjogJ292ZXJsYXknLCBvcHRpb25zOiB7IHg6ICd3JywgeTogMCB9LCBpbnB1dHM6IFsncGFkZGVkJywgJ2dyZWVuJ10sIG91dHB1dHM6ICdyZWRncmVlbid9LFxuICAgKlxuICAgKiAgICAgIC8vIE92ZXJsYXkgJ2JsdWUnIG9udG8gJ3JlZGdyZWVuJywgbW92aW5nIGl0IHRvIHRoZSByaWdodFxuICAgKiAgICAgIHsgZmlsdGVyOiAnb3ZlcmxheScsIG9wdGlvbnM6IHsgeDogJzIqdycsIHk6IDAgfSwgaW5wdXRzOiBbJ3JlZGdyZWVuJywgJ2JsdWUnXX0sXG4gICAqICAgIF0pO1xuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjY29tcGxleEZpbHRlclxuICAgKiBAY2F0ZWdvcnkgQ3VzdG9tIG9wdGlvbnNcbiAgICogQGFsaWFzZXMgZmlsdGVyR3JhcGhcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHNwZWMgZmlsdGVyZ3JhcGggc3RyaW5nIG9yIGFycmF5IG9mIGZpbHRlciBzcGVjaWZpY2F0aW9uXG4gICAqICAgb2JqZWN0cywgZWFjaCBoYXZpbmcgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy5maWx0ZXIgZmlsdGVyIG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IFtzcGVjLmlucHV0c10gKGFycmF5IG9mKSBpbnB1dCBzdHJlYW0gc3BlY2lmaWVyKHMpIGZvciB0aGUgZmlsdGVyLFxuICAgKiAgIGRlZmF1bHRzIHRvIGZmbXBlZyBhdXRvbWF0aWNhbGx5IGNob29zaW5nIHRoZSBmaXJzdCB1bnVzZWQgbWF0Y2hpbmcgc3RyZWFtc1xuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gW3NwZWMub3V0cHV0c10gKGFycmF5IG9mKSBvdXRwdXQgc3RyZWFtIHNwZWNpZmllcihzKSBmb3IgdGhlIGZpbHRlcixcbiAgICogICBkZWZhdWx0cyB0byBmZm1wZWcgYXV0b21hdGljYWxseSBhc3NpZ25pbmcgdGhlIG91dHB1dCB0byB0aGUgb3V0cHV0IGZpbGVcbiAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfEFycmF5fSBbc3BlYy5vcHRpb25zXSBmaWx0ZXIgb3B0aW9ucywgY2FuIGJlIG9taXR0ZWQgdG8gbm90IHNldCBhbnkgb3B0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fSBbbWFwXSAoYXJyYXkgb2YpIHN0cmVhbSBzcGVjaWZpZXIocykgZnJvbSB0aGUgZ3JhcGggdG8gaW5jbHVkZSBpblxuICAgKiAgIGZmbXBlZyBvdXRwdXQsIGRlZmF1bHRzIHRvIGZmbXBlZyBhdXRvbWF0aWNhbGx5IGNob29zaW5nIHRoZSBmaXJzdCBtYXRjaGluZyBzdHJlYW1zLlxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLmZpbHRlckdyYXBoID1cbiAgcHJvdG8uY29tcGxleEZpbHRlciA9IGZ1bmN0aW9uKHNwZWMsIG1hcCkge1xuICAgIHRoaXMuX2NvbXBsZXhGaWx0ZXJzLmNsZWFyKCk7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3BlYykpIHtcbiAgICAgIHNwZWMgPSBbc3BlY107XG4gICAgfVxuXG4gICAgdGhpcy5fY29tcGxleEZpbHRlcnMoJy1maWx0ZXJfY29tcGxleCcsIHV0aWxzLm1ha2VGaWx0ZXJTdHJpbmdzKHNwZWMpLmpvaW4oJzsnKSk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXApKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBtYXAuZm9yRWFjaChmdW5jdGlvbihzdHJlYW1TcGVjKSB7XG4gICAgICAgIHNlbGYuX2NvbXBsZXhGaWx0ZXJzKCctbWFwJywgc3RyZWFtU3BlYy5yZXBsYWNlKHV0aWxzLnN0cmVhbVJlZ2V4cCwgJ1skMV0nKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9jb21wbGV4RmlsdGVycygnLW1hcCcsIG1hcC5yZXBsYWNlKHV0aWxzLnN0cmVhbVJlZ2V4cCwgJ1skMV0nKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/options/custom.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/options/inputs.js":
/*!**********************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/options/inputs.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\");\n\n/*\n *! Input-related methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Add an input to command\n   *\n   * Also switches \"current input\", that is the input that will be affected\n   * by subsequent input-related methods.\n   *\n   * Note: only one stream input is supported for now.\n   *\n   * @method FfmpegCommand#input\n   * @category Input\n   * @aliases mergeAdd,addInput\n   *\n   * @param {String|Readable} source input file path or readable stream\n   * @return FfmpegCommand\n   */\n  proto.mergeAdd =\n  proto.addInput =\n  proto.input = function(source) {\n    var isFile = false;\n    var isStream = false;\n\n    if (typeof source !== 'string') {\n      if (!('readable' in source) || !(source.readable)) {\n        throw new Error('Invalid input');\n      }\n\n      var hasInputStream = this._inputs.some(function(input) {\n        return input.isStream;\n      });\n\n      if (hasInputStream) {\n        throw new Error('Only one input stream is supported');\n      }\n\n      isStream = true;\n      source.pause();\n    } else {\n      var protocol = source.match(/^([a-z]{2,}):/i);\n      isFile = !protocol || protocol[0] === 'file';\n    }\n\n    this._inputs.push(this._currentInput = {\n      source: source,\n      isFile: isFile,\n      isStream: isStream,\n      options: utils.args()\n    });\n\n    return this;\n  };\n\n\n  /**\n   * Specify input format for the last specified input\n   *\n   * @method FfmpegCommand#inputFormat\n   * @category Input\n   * @aliases withInputFormat,fromFormat\n   *\n   * @param {String} format input format\n   * @return FfmpegCommand\n   */\n  proto.withInputFormat =\n  proto.inputFormat =\n  proto.fromFormat = function(format) {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n\n    this._currentInput.options('-f', format);\n    return this;\n  };\n\n\n  /**\n   * Specify input FPS for the last specified input\n   * (only valid for raw video formats)\n   *\n   * @method FfmpegCommand#inputFps\n   * @category Input\n   * @aliases withInputFps,withInputFPS,withFpsInput,withFPSInput,inputFPS,inputFps,fpsInput\n   *\n   * @param {Number} fps input FPS\n   * @return FfmpegCommand\n   */\n  proto.withInputFps =\n  proto.withInputFPS =\n  proto.withFpsInput =\n  proto.withFPSInput =\n  proto.inputFPS =\n  proto.inputFps =\n  proto.fpsInput =\n  proto.FPSInput = function(fps) {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n\n    this._currentInput.options('-r', fps);\n    return this;\n  };\n\n\n  /**\n   * Use native framerate for the last specified input\n   *\n   * @method FfmpegCommand#native\n   * @category Input\n   * @aliases nativeFramerate,withNativeFramerate\n   *\n   * @return FfmmegCommand\n   */\n  proto.nativeFramerate =\n  proto.withNativeFramerate =\n  proto.native = function() {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n\n    this._currentInput.options('-re');\n    return this;\n  };\n\n\n  /**\n   * Specify input seek time for the last specified input\n   *\n   * @method FfmpegCommand#seekInput\n   * @category Input\n   * @aliases setStartTime,seekTo\n   *\n   * @param {String|Number} seek seek time in seconds or as a '[hh:[mm:]]ss[.xxx]' string\n   * @return FfmpegCommand\n   */\n  proto.setStartTime =\n  proto.seekInput = function(seek) {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n\n    this._currentInput.options('-ss', seek);\n\n    return this;\n  };\n\n\n  /**\n   * Loop over the last specified input\n   *\n   * @method FfmpegCommand#loop\n   * @category Input\n   *\n   * @param {String|Number} [duration] loop duration in seconds or as a '[[hh:]mm:]ss[.xxx]' string\n   * @return FfmpegCommand\n   */\n  proto.loop = function(duration) {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n\n    this._currentInput.options('-loop', '1');\n\n    if (typeof duration !== 'undefined') {\n      this.duration(duration);\n    }\n\n    return this;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvb3B0aW9ucy9pbnB1dHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsaUVBQVU7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJDQUEyQyxHQUFHO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtZmlyZWJhc2UtYXBpLy4vbm9kZV9tb2R1bGVzL2ZsdWVudC1mZm1wZWcvbGliL29wdGlvbnMvaW5wdXRzLmpzPzZhYmMiXSwic291cmNlc0NvbnRlbnQiOlsiLypqc2hpbnQgbm9kZTp0cnVlKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLypcbiAqISBJbnB1dC1yZWxhdGVkIG1ldGhvZHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHByb3RvKSB7XG4gIC8qKlxuICAgKiBBZGQgYW4gaW5wdXQgdG8gY29tbWFuZFxuICAgKlxuICAgKiBBbHNvIHN3aXRjaGVzIFwiY3VycmVudCBpbnB1dFwiLCB0aGF0IGlzIHRoZSBpbnB1dCB0aGF0IHdpbGwgYmUgYWZmZWN0ZWRcbiAgICogYnkgc3Vic2VxdWVudCBpbnB1dC1yZWxhdGVkIG1ldGhvZHMuXG4gICAqXG4gICAqIE5vdGU6IG9ubHkgb25lIHN0cmVhbSBpbnB1dCBpcyBzdXBwb3J0ZWQgZm9yIG5vdy5cbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2lucHV0XG4gICAqIEBjYXRlZ29yeSBJbnB1dFxuICAgKiBAYWxpYXNlcyBtZXJnZUFkZCxhZGRJbnB1dFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xSZWFkYWJsZX0gc291cmNlIGlucHV0IGZpbGUgcGF0aCBvciByZWFkYWJsZSBzdHJlYW1cbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by5tZXJnZUFkZCA9XG4gIHByb3RvLmFkZElucHV0ID1cbiAgcHJvdG8uaW5wdXQgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICB2YXIgaXNGaWxlID0gZmFsc2U7XG4gICAgdmFyIGlzU3RyZWFtID0gZmFsc2U7XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICghKCdyZWFkYWJsZScgaW4gc291cmNlKSB8fCAhKHNvdXJjZS5yZWFkYWJsZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0Jyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNJbnB1dFN0cmVhbSA9IHRoaXMuX2lucHV0cy5zb21lKGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5pc1N0cmVhbTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGFzSW5wdXRTdHJlYW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG9uZSBpbnB1dCBzdHJlYW0gaXMgc3VwcG9ydGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGlzU3RyZWFtID0gdHJ1ZTtcbiAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSBzb3VyY2UubWF0Y2goL14oW2Etel17Mix9KTovaSk7XG4gICAgICBpc0ZpbGUgPSAhcHJvdG9jb2wgfHwgcHJvdG9jb2xbMF0gPT09ICdmaWxlJztcbiAgICB9XG5cbiAgICB0aGlzLl9pbnB1dHMucHVzaCh0aGlzLl9jdXJyZW50SW5wdXQgPSB7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIGlzRmlsZTogaXNGaWxlLFxuICAgICAgaXNTdHJlYW06IGlzU3RyZWFtLFxuICAgICAgb3B0aW9uczogdXRpbHMuYXJncygpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGlucHV0IGZvcm1hdCBmb3IgdGhlIGxhc3Qgc3BlY2lmaWVkIGlucHV0XG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNpbnB1dEZvcm1hdFxuICAgKiBAY2F0ZWdvcnkgSW5wdXRcbiAgICogQGFsaWFzZXMgd2l0aElucHV0Rm9ybWF0LGZyb21Gb3JtYXRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdCBpbnB1dCBmb3JtYXRcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by53aXRoSW5wdXRGb3JtYXQgPVxuICBwcm90by5pbnB1dEZvcm1hdCA9XG4gIHByb3RvLmZyb21Gb3JtYXQgPSBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICBpZiAoIXRoaXMuX2N1cnJlbnRJbnB1dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbnB1dCBzcGVjaWZpZWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50SW5wdXQub3B0aW9ucygnLWYnLCBmb3JtYXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgaW5wdXQgRlBTIGZvciB0aGUgbGFzdCBzcGVjaWZpZWQgaW5wdXRcbiAgICogKG9ubHkgdmFsaWQgZm9yIHJhdyB2aWRlbyBmb3JtYXRzKVxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjaW5wdXRGcHNcbiAgICogQGNhdGVnb3J5IElucHV0XG4gICAqIEBhbGlhc2VzIHdpdGhJbnB1dEZwcyx3aXRoSW5wdXRGUFMsd2l0aEZwc0lucHV0LHdpdGhGUFNJbnB1dCxpbnB1dEZQUyxpbnB1dEZwcyxmcHNJbnB1dFxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnBzIGlucHV0IEZQU1xuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLndpdGhJbnB1dEZwcyA9XG4gIHByb3RvLndpdGhJbnB1dEZQUyA9XG4gIHByb3RvLndpdGhGcHNJbnB1dCA9XG4gIHByb3RvLndpdGhGUFNJbnB1dCA9XG4gIHByb3RvLmlucHV0RlBTID1cbiAgcHJvdG8uaW5wdXRGcHMgPVxuICBwcm90by5mcHNJbnB1dCA9XG4gIHByb3RvLkZQU0lucHV0ID0gZnVuY3Rpb24oZnBzKSB7XG4gICAgaWYgKCF0aGlzLl9jdXJyZW50SW5wdXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5wdXQgc3BlY2lmaWVkJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudElucHV0Lm9wdGlvbnMoJy1yJywgZnBzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBVc2UgbmF0aXZlIGZyYW1lcmF0ZSBmb3IgdGhlIGxhc3Qgc3BlY2lmaWVkIGlucHV0XG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNuYXRpdmVcbiAgICogQGNhdGVnb3J5IElucHV0XG4gICAqIEBhbGlhc2VzIG5hdGl2ZUZyYW1lcmF0ZSx3aXRoTmF0aXZlRnJhbWVyYXRlXG4gICAqXG4gICAqIEByZXR1cm4gRmZtbWVnQ29tbWFuZFxuICAgKi9cbiAgcHJvdG8ubmF0aXZlRnJhbWVyYXRlID1cbiAgcHJvdG8ud2l0aE5hdGl2ZUZyYW1lcmF0ZSA9XG4gIHByb3RvLm5hdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fY3VycmVudElucHV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGlucHV0IHNwZWNpZmllZCcpO1xuICAgIH1cblxuICAgIHRoaXMuX2N1cnJlbnRJbnB1dC5vcHRpb25zKCctcmUnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGlucHV0IHNlZWsgdGltZSBmb3IgdGhlIGxhc3Qgc3BlY2lmaWVkIGlucHV0XG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNzZWVrSW5wdXRcbiAgICogQGNhdGVnb3J5IElucHV0XG4gICAqIEBhbGlhc2VzIHNldFN0YXJ0VGltZSxzZWVrVG9cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBzZWVrIHNlZWsgdGltZSBpbiBzZWNvbmRzIG9yIGFzIGEgJ1toaDpbbW06XV1zc1sueHh4XScgc3RyaW5nXG4gICAqIEByZXR1cm4gRmZtcGVnQ29tbWFuZFxuICAgKi9cbiAgcHJvdG8uc2V0U3RhcnRUaW1lID1cbiAgcHJvdG8uc2Vla0lucHV0ID0gZnVuY3Rpb24oc2Vlaykge1xuICAgIGlmICghdGhpcy5fY3VycmVudElucHV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGlucHV0IHNwZWNpZmllZCcpO1xuICAgIH1cblxuICAgIHRoaXMuX2N1cnJlbnRJbnB1dC5vcHRpb25zKCctc3MnLCBzZWVrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIExvb3Agb3ZlciB0aGUgbGFzdCBzcGVjaWZpZWQgaW5wdXRcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2xvb3BcbiAgICogQGNhdGVnb3J5IElucHV0XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW2R1cmF0aW9uXSBsb29wIGR1cmF0aW9uIGluIHNlY29uZHMgb3IgYXMgYSAnW1toaDpdbW06XXNzWy54eHhdJyBzdHJpbmdcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by5sb29wID0gZnVuY3Rpb24oZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuX2N1cnJlbnRJbnB1dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbnB1dCBzcGVjaWZpZWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50SW5wdXQub3B0aW9ucygnLWxvb3AnLCAnMScpO1xuXG4gICAgaWYgKHR5cGVvZiBkdXJhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/options/inputs.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/options/misc.js":
/*!********************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/options/misc.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar path = __webpack_require__(/*! path */ \"path?8ff8\");\n\n/*\n *! Miscellaneous methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Use preset\n   *\n   * @method FfmpegCommand#preset\n   * @category Miscellaneous\n   * @aliases usingPreset\n   *\n   * @param {String|Function} preset preset name or preset function\n   */\n  proto.usingPreset =\n  proto.preset = function(preset) {\n    if (typeof preset === 'function') {\n      preset(this);\n    } else {\n      try {\n        var modulePath = path.join(this.options.presets, preset);\n        var module = __webpack_require__(\"(rsc)/./node_modules/fluent-ffmpeg/lib/options sync recursive\")(modulePath);\n\n        if (typeof module.load === 'function') {\n          module.load(this);\n        } else {\n          throw new Error('preset ' + modulePath + ' has no load() function');\n        }\n      } catch (err) {\n        throw new Error('preset ' + modulePath + ' could not be loaded: ' + err.message);\n      }\n    }\n\n    return this;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvb3B0aW9ucy9taXNjLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLHVCQUFNOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHFCQUFxQixxRkFBUSxVQUFVLENBQUM7O0FBRXhDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWZpcmViYXNlLWFwaS8uL25vZGVfbW9kdWxlcy9mbHVlbnQtZmZtcGVnL2xpYi9vcHRpb25zL21pc2MuanM/NzcyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzaGludCBub2RlOnRydWUqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuLypcbiAqISBNaXNjZWxsYW5lb3VzIG1ldGhvZHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHByb3RvKSB7XG4gIC8qKlxuICAgKiBVc2UgcHJlc2V0XG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNwcmVzZXRcbiAgICogQGNhdGVnb3J5IE1pc2NlbGxhbmVvdXNcbiAgICogQGFsaWFzZXMgdXNpbmdQcmVzZXRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHByZXNldCBwcmVzZXQgbmFtZSBvciBwcmVzZXQgZnVuY3Rpb25cbiAgICovXG4gIHByb3RvLnVzaW5nUHJlc2V0ID1cbiAgcHJvdG8ucHJlc2V0ID0gZnVuY3Rpb24ocHJlc2V0KSB7XG4gICAgaWYgKHR5cGVvZiBwcmVzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByZXNldCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG1vZHVsZVBhdGggPSBwYXRoLmpvaW4odGhpcy5vcHRpb25zLnByZXNldHMsIHByZXNldCk7XG4gICAgICAgIHZhciBtb2R1bGUgPSByZXF1aXJlKG1vZHVsZVBhdGgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlLmxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBtb2R1bGUubG9hZCh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZXNldCAnICsgbW9kdWxlUGF0aCArICcgaGFzIG5vIGxvYWQoKSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmVzZXQgJyArIG1vZHVsZVBhdGggKyAnIGNvdWxkIG5vdCBiZSBsb2FkZWQ6ICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/options/misc.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/options/output.js":
/*!**********************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/options/output.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\");\n\n\n/*\n *! Output-related methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Add output\n   *\n   * @method FfmpegCommand#output\n   * @category Output\n   * @aliases addOutput\n   *\n   * @param {String|Writable} target target file path or writable stream\n   * @param {Object} [pipeopts={}] pipe options (only applies to streams)\n   * @return FfmpegCommand\n   */\n  proto.addOutput =\n  proto.output = function(target, pipeopts) {\n    var isFile = false;\n\n    if (!target && this._currentOutput) {\n      // No target is only allowed when called from constructor\n      throw new Error('Invalid output');\n    }\n\n    if (target && typeof target !== 'string') {\n      if (!('writable' in target) || !(target.writable)) {\n        throw new Error('Invalid output');\n      }\n    } else if (typeof target === 'string') {\n      var protocol = target.match(/^([a-z]{2,}):/i);\n      isFile = !protocol || protocol[0] === 'file';\n    }\n\n    if (target && !('target' in this._currentOutput)) {\n      // For backwards compatibility, set target for first output\n      this._currentOutput.target = target;\n      this._currentOutput.isFile = isFile;\n      this._currentOutput.pipeopts = pipeopts || {};\n    } else {\n      if (target && typeof target !== 'string') {\n        var hasOutputStream = this._outputs.some(function(output) {\n          return typeof output.target !== 'string';\n        });\n\n        if (hasOutputStream) {\n          throw new Error('Only one output stream is supported');\n        }\n      }\n\n      this._outputs.push(this._currentOutput = {\n        target: target,\n        isFile: isFile,\n        flags: {},\n        pipeopts: pipeopts || {}\n      });\n\n      var self = this;\n      ['audio', 'audioFilters', 'video', 'videoFilters', 'sizeFilters', 'options'].forEach(function(key) {\n        self._currentOutput[key] = utils.args();\n      });\n\n      if (!target) {\n        // Call from constructor: remove target key\n        delete this._currentOutput.target;\n      }\n    }\n\n    return this;\n  };\n\n\n  /**\n   * Specify output seek time\n   *\n   * @method FfmpegCommand#seek\n   * @category Input\n   * @aliases seekOutput\n   *\n   * @param {String|Number} seek seek time in seconds or as a '[hh:[mm:]]ss[.xxx]' string\n   * @return FfmpegCommand\n   */\n  proto.seekOutput =\n  proto.seek = function(seek) {\n    this._currentOutput.options('-ss', seek);\n    return this;\n  };\n\n\n  /**\n   * Set output duration\n   *\n   * @method FfmpegCommand#duration\n   * @category Output\n   * @aliases withDuration,setDuration\n   *\n   * @param {String|Number} duration duration in seconds or as a '[[hh:]mm:]ss[.xxx]' string\n   * @return FfmpegCommand\n   */\n  proto.withDuration =\n  proto.setDuration =\n  proto.duration = function(duration) {\n    this._currentOutput.options('-t', duration);\n    return this;\n  };\n\n\n  /**\n   * Set output format\n   *\n   * @method FfmpegCommand#format\n   * @category Output\n   * @aliases toFormat,withOutputFormat,outputFormat\n   *\n   * @param {String} format output format name\n   * @return FfmpegCommand\n   */\n  proto.toFormat =\n  proto.withOutputFormat =\n  proto.outputFormat =\n  proto.format = function(format) {\n    this._currentOutput.options('-f', format);\n    return this;\n  };\n\n\n  /**\n   * Add stream mapping to output\n   *\n   * @method FfmpegCommand#map\n   * @category Output\n   *\n   * @param {String} spec stream specification string, with optional square brackets\n   * @return FfmpegCommand\n   */\n  proto.map = function(spec) {\n    this._currentOutput.options('-map', spec.replace(utils.streamRegexp, '[$1]'));\n    return this;\n  };\n\n\n  /**\n   * Run flvtool2/flvmeta on output\n   *\n   * @method FfmpegCommand#flvmeta\n   * @category Output\n   * @aliases updateFlvMetadata\n   *\n   * @return FfmpegCommand\n   */\n  proto.updateFlvMetadata =\n  proto.flvmeta = function() {\n    this._currentOutput.flags.flvmeta = true;\n    return this;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvb3B0aW9ucy9vdXRwdXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsaUVBQVU7OztBQUc5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsUUFBUSxZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkNBQTJDLEdBQUc7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWZpcmViYXNlLWFwaS8uL25vZGVfbW9kdWxlcy9mbHVlbnQtZmZtcGVnL2xpYi9vcHRpb25zL291dHB1dC5qcz80YmJlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qanNoaW50IG5vZGU6dHJ1ZSovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cblxuLypcbiAqISBPdXRwdXQtcmVsYXRlZCBtZXRob2RzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwcm90bykge1xuICAvKipcbiAgICogQWRkIG91dHB1dFxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjb3V0cHV0XG4gICAqIEBjYXRlZ29yeSBPdXRwdXRcbiAgICogQGFsaWFzZXMgYWRkT3V0cHV0XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfFdyaXRhYmxlfSB0YXJnZXQgdGFyZ2V0IGZpbGUgcGF0aCBvciB3cml0YWJsZSBzdHJlYW1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwaXBlb3B0cz17fV0gcGlwZSBvcHRpb25zIChvbmx5IGFwcGxpZXMgdG8gc3RyZWFtcylcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by5hZGRPdXRwdXQgPVxuICBwcm90by5vdXRwdXQgPSBmdW5jdGlvbih0YXJnZXQsIHBpcGVvcHRzKSB7XG4gICAgdmFyIGlzRmlsZSA9IGZhbHNlO1xuXG4gICAgaWYgKCF0YXJnZXQgJiYgdGhpcy5fY3VycmVudE91dHB1dCkge1xuICAgICAgLy8gTm8gdGFyZ2V0IGlzIG9ubHkgYWxsb3dlZCB3aGVuIGNhbGxlZCBmcm9tIGNvbnN0cnVjdG9yXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3V0cHV0Jyk7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0ICE9PSAnc3RyaW5nJykge1xuICAgICAgaWYgKCEoJ3dyaXRhYmxlJyBpbiB0YXJnZXQpIHx8ICEodGFyZ2V0LndyaXRhYmxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3V0cHV0Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHByb3RvY29sID0gdGFyZ2V0Lm1hdGNoKC9eKFthLXpdezIsfSk6L2kpO1xuICAgICAgaXNGaWxlID0gIXByb3RvY29sIHx8IHByb3RvY29sWzBdID09PSAnZmlsZSc7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldCAmJiAhKCd0YXJnZXQnIGluIHRoaXMuX2N1cnJlbnRPdXRwdXQpKSB7XG4gICAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHNldCB0YXJnZXQgZm9yIGZpcnN0IG91dHB1dFxuICAgICAgdGhpcy5fY3VycmVudE91dHB1dC50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICB0aGlzLl9jdXJyZW50T3V0cHV0LmlzRmlsZSA9IGlzRmlsZTtcbiAgICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQucGlwZW9wdHMgPSBwaXBlb3B0cyB8fCB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgaGFzT3V0cHV0U3RyZWFtID0gdGhpcy5fb3V0cHV0cy5zb21lKGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2Ygb3V0cHV0LnRhcmdldCAhPT0gJ3N0cmluZyc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChoYXNPdXRwdXRTdHJlYW0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIG91dHB1dCBzdHJlYW0gaXMgc3VwcG9ydGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fb3V0cHV0cy5wdXNoKHRoaXMuX2N1cnJlbnRPdXRwdXQgPSB7XG4gICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICBpc0ZpbGU6IGlzRmlsZSxcbiAgICAgICAgZmxhZ3M6IHt9LFxuICAgICAgICBwaXBlb3B0czogcGlwZW9wdHMgfHwge31cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBbJ2F1ZGlvJywgJ2F1ZGlvRmlsdGVycycsICd2aWRlbycsICd2aWRlb0ZpbHRlcnMnLCAnc2l6ZUZpbHRlcnMnLCAnb3B0aW9ucyddLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHNlbGYuX2N1cnJlbnRPdXRwdXRba2V5XSA9IHV0aWxzLmFyZ3MoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAvLyBDYWxsIGZyb20gY29uc3RydWN0b3I6IHJlbW92ZSB0YXJnZXQga2V5XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9jdXJyZW50T3V0cHV0LnRhcmdldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IG91dHB1dCBzZWVrIHRpbWVcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI3NlZWtcbiAgICogQGNhdGVnb3J5IElucHV0XG4gICAqIEBhbGlhc2VzIHNlZWtPdXRwdXRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBzZWVrIHNlZWsgdGltZSBpbiBzZWNvbmRzIG9yIGFzIGEgJ1toaDpbbW06XV1zc1sueHh4XScgc3RyaW5nXG4gICAqIEByZXR1cm4gRmZtcGVnQ29tbWFuZFxuICAgKi9cbiAgcHJvdG8uc2Vla091dHB1dCA9XG4gIHByb3RvLnNlZWsgPSBmdW5jdGlvbihzZWVrKSB7XG4gICAgdGhpcy5fY3VycmVudE91dHB1dC5vcHRpb25zKCctc3MnLCBzZWVrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBTZXQgb3V0cHV0IGR1cmF0aW9uXG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNkdXJhdGlvblxuICAgKiBAY2F0ZWdvcnkgT3V0cHV0XG4gICAqIEBhbGlhc2VzIHdpdGhEdXJhdGlvbixzZXREdXJhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGR1cmF0aW9uIGR1cmF0aW9uIGluIHNlY29uZHMgb3IgYXMgYSAnW1toaDpdbW06XXNzWy54eHhdJyBzdHJpbmdcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by53aXRoRHVyYXRpb24gPVxuICBwcm90by5zZXREdXJhdGlvbiA9XG4gIHByb3RvLmR1cmF0aW9uID0gZnVuY3Rpb24oZHVyYXRpb24pIHtcbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0Lm9wdGlvbnMoJy10JywgZHVyYXRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNldCBvdXRwdXQgZm9ybWF0XG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNmb3JtYXRcbiAgICogQGNhdGVnb3J5IE91dHB1dFxuICAgKiBAYWxpYXNlcyB0b0Zvcm1hdCx3aXRoT3V0cHV0Rm9ybWF0LG91dHB1dEZvcm1hdFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0IG91dHB1dCBmb3JtYXQgbmFtZVxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLnRvRm9ybWF0ID1cbiAgcHJvdG8ud2l0aE91dHB1dEZvcm1hdCA9XG4gIHByb3RvLm91dHB1dEZvcm1hdCA9XG4gIHByb3RvLmZvcm1hdCA9IGZ1bmN0aW9uKGZvcm1hdCkge1xuICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQub3B0aW9ucygnLWYnLCBmb3JtYXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEFkZCBzdHJlYW0gbWFwcGluZyB0byBvdXRwdXRcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI21hcFxuICAgKiBAY2F0ZWdvcnkgT3V0cHV0XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjIHN0cmVhbSBzcGVjaWZpY2F0aW9uIHN0cmluZywgd2l0aCBvcHRpb25hbCBzcXVhcmUgYnJhY2tldHNcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by5tYXAgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgdGhpcy5fY3VycmVudE91dHB1dC5vcHRpb25zKCctbWFwJywgc3BlYy5yZXBsYWNlKHV0aWxzLnN0cmVhbVJlZ2V4cCwgJ1skMV0nKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogUnVuIGZsdnRvb2wyL2Zsdm1ldGEgb24gb3V0cHV0XG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNmbHZtZXRhXG4gICAqIEBjYXRlZ29yeSBPdXRwdXRcbiAgICogQGFsaWFzZXMgdXBkYXRlRmx2TWV0YWRhdGFcbiAgICpcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by51cGRhdGVGbHZNZXRhZGF0YSA9XG4gIHByb3RvLmZsdm1ldGEgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LmZsYWdzLmZsdm1ldGEgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/options/output.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/options/video.js":
/*!*********************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/options/video.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\");\n\n\n/*\n *! Video-related methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Disable video in the output\n   *\n   * @method FfmpegCommand#noVideo\n   * @category Video\n   * @aliases withNoVideo\n   *\n   * @return FfmpegCommand\n   */\n  proto.withNoVideo =\n  proto.noVideo = function() {\n    this._currentOutput.video.clear();\n    this._currentOutput.videoFilters.clear();\n    this._currentOutput.video('-vn');\n\n    return this;\n  };\n\n\n  /**\n   * Specify video codec\n   *\n   * @method FfmpegCommand#videoCodec\n   * @category Video\n   * @aliases withVideoCodec\n   *\n   * @param {String} codec video codec name\n   * @return FfmpegCommand\n   */\n  proto.withVideoCodec =\n  proto.videoCodec = function(codec) {\n    this._currentOutput.video('-vcodec', codec);\n    return this;\n  };\n\n\n  /**\n   * Specify video bitrate\n   *\n   * @method FfmpegCommand#videoBitrate\n   * @category Video\n   * @aliases withVideoBitrate\n   *\n   * @param {String|Number} bitrate video bitrate in kbps (with an optional 'k' suffix)\n   * @param {Boolean} [constant=false] enforce constant bitrate\n   * @return FfmpegCommand\n   */\n  proto.withVideoBitrate =\n  proto.videoBitrate = function(bitrate, constant) {\n    bitrate = ('' + bitrate).replace(/k?$/, 'k');\n\n    this._currentOutput.video('-b:v', bitrate);\n    if (constant) {\n      this._currentOutput.video(\n        '-maxrate', bitrate,\n        '-minrate', bitrate,\n        '-bufsize', '3M'\n      );\n    }\n\n    return this;\n  };\n\n\n  /**\n   * Specify custom video filter(s)\n   *\n   * Can be called both with one or many filters, or a filter array.\n   *\n   * @example\n   * command.videoFilters('filter1');\n   *\n   * @example\n   * command.videoFilters('filter1', 'filter2=param1=value1:param2=value2');\n   *\n   * @example\n   * command.videoFilters(['filter1', 'filter2']);\n   *\n   * @example\n   * command.videoFilters([\n   *   {\n   *     filter: 'filter1'\n   *   },\n   *   {\n   *     filter: 'filter2',\n   *     options: 'param=value:param=value'\n   *   }\n   * ]);\n   *\n   * @example\n   * command.videoFilters(\n   *   {\n   *     filter: 'filter1',\n   *     options: ['value1', 'value2']\n   *   },\n   *   {\n   *     filter: 'filter2',\n   *     options: { param1: 'value1', param2: 'value2' }\n   *   }\n   * );\n   *\n   * @method FfmpegCommand#videoFilters\n   * @category Video\n   * @aliases withVideoFilter,withVideoFilters,videoFilter\n   *\n   * @param {...String|String[]|Object[]} filters video filter strings, string array or\n   *   filter specification array, each with the following properties:\n   * @param {String} filters.filter filter name\n   * @param {String|String[]|Object} [filters.options] filter option string, array, or object\n   * @return FfmpegCommand\n   */\n  proto.withVideoFilter =\n  proto.withVideoFilters =\n  proto.videoFilter =\n  proto.videoFilters = function(filters) {\n    if (arguments.length > 1) {\n      filters = [].slice.call(arguments);\n    }\n\n    if (!Array.isArray(filters)) {\n      filters = [filters];\n    }\n\n    this._currentOutput.videoFilters(utils.makeFilterStrings(filters));\n\n    return this;\n  };\n\n\n  /**\n   * Specify output FPS\n   *\n   * @method FfmpegCommand#fps\n   * @category Video\n   * @aliases withOutputFps,withOutputFPS,withFpsOutput,withFPSOutput,withFps,withFPS,outputFPS,outputFps,fpsOutput,FPSOutput,FPS\n   *\n   * @param {Number} fps output FPS\n   * @return FfmpegCommand\n   */\n  proto.withOutputFps =\n  proto.withOutputFPS =\n  proto.withFpsOutput =\n  proto.withFPSOutput =\n  proto.withFps =\n  proto.withFPS =\n  proto.outputFPS =\n  proto.outputFps =\n  proto.fpsOutput =\n  proto.FPSOutput =\n  proto.fps =\n  proto.FPS = function(fps) {\n    this._currentOutput.video('-r', fps);\n    return this;\n  };\n\n\n  /**\n   * Only transcode a certain number of frames\n   *\n   * @method FfmpegCommand#frames\n   * @category Video\n   * @aliases takeFrames,withFrames\n   *\n   * @param {Number} frames frame count\n   * @return FfmpegCommand\n   */\n  proto.takeFrames =\n  proto.withFrames =\n  proto.frames = function(frames) {\n    this._currentOutput.video('-vframes', frames);\n    return this;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvb3B0aW9ucy92aWRlby5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxpRUFBVTs7O0FBRzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWZpcmViYXNlLWFwaS8uL25vZGVfbW9kdWxlcy9mbHVlbnQtZmZtcGVnL2xpYi9vcHRpb25zL3ZpZGVvLmpzPzIzODUiXSwic291cmNlc0NvbnRlbnQiOlsiLypqc2hpbnQgbm9kZTp0cnVlKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuXG4vKlxuICohIFZpZGVvLXJlbGF0ZWQgbWV0aG9kc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocHJvdG8pIHtcbiAgLyoqXG4gICAqIERpc2FibGUgdmlkZW8gaW4gdGhlIG91dHB1dFxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjbm9WaWRlb1xuICAgKiBAY2F0ZWdvcnkgVmlkZW9cbiAgICogQGFsaWFzZXMgd2l0aE5vVmlkZW9cbiAgICpcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by53aXRoTm9WaWRlbyA9XG4gIHByb3RvLm5vVmlkZW8gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LnZpZGVvLmNsZWFyKCk7XG4gICAgdGhpcy5fY3VycmVudE91dHB1dC52aWRlb0ZpbHRlcnMuY2xlYXIoKTtcbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LnZpZGVvKCctdm4nKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgdmlkZW8gY29kZWNcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI3ZpZGVvQ29kZWNcbiAgICogQGNhdGVnb3J5IFZpZGVvXG4gICAqIEBhbGlhc2VzIHdpdGhWaWRlb0NvZGVjXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2RlYyB2aWRlbyBjb2RlYyBuYW1lXG4gICAqIEByZXR1cm4gRmZtcGVnQ29tbWFuZFxuICAgKi9cbiAgcHJvdG8ud2l0aFZpZGVvQ29kZWMgPVxuICBwcm90by52aWRlb0NvZGVjID0gZnVuY3Rpb24oY29kZWMpIHtcbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LnZpZGVvKCctdmNvZGVjJywgY29kZWMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgdmlkZW8gYml0cmF0ZVxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjdmlkZW9CaXRyYXRlXG4gICAqIEBjYXRlZ29yeSBWaWRlb1xuICAgKiBAYWxpYXNlcyB3aXRoVmlkZW9CaXRyYXRlXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gYml0cmF0ZSB2aWRlbyBiaXRyYXRlIGluIGticHMgKHdpdGggYW4gb3B0aW9uYWwgJ2snIHN1ZmZpeClcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY29uc3RhbnQ9ZmFsc2VdIGVuZm9yY2UgY29uc3RhbnQgYml0cmF0ZVxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLndpdGhWaWRlb0JpdHJhdGUgPVxuICBwcm90by52aWRlb0JpdHJhdGUgPSBmdW5jdGlvbihiaXRyYXRlLCBjb25zdGFudCkge1xuICAgIGJpdHJhdGUgPSAoJycgKyBiaXRyYXRlKS5yZXBsYWNlKC9rPyQvLCAnaycpO1xuXG4gICAgdGhpcy5fY3VycmVudE91dHB1dC52aWRlbygnLWI6dicsIGJpdHJhdGUpO1xuICAgIGlmIChjb25zdGFudCkge1xuICAgICAgdGhpcy5fY3VycmVudE91dHB1dC52aWRlbyhcbiAgICAgICAgJy1tYXhyYXRlJywgYml0cmF0ZSxcbiAgICAgICAgJy1taW5yYXRlJywgYml0cmF0ZSxcbiAgICAgICAgJy1idWZzaXplJywgJzNNJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGN1c3RvbSB2aWRlbyBmaWx0ZXIocylcbiAgICpcbiAgICogQ2FuIGJlIGNhbGxlZCBib3RoIHdpdGggb25lIG9yIG1hbnkgZmlsdGVycywgb3IgYSBmaWx0ZXIgYXJyYXkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbW1hbmQudmlkZW9GaWx0ZXJzKCdmaWx0ZXIxJyk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbW1hbmQudmlkZW9GaWx0ZXJzKCdmaWx0ZXIxJywgJ2ZpbHRlcjI9cGFyYW0xPXZhbHVlMTpwYXJhbTI9dmFsdWUyJyk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbW1hbmQudmlkZW9GaWx0ZXJzKFsnZmlsdGVyMScsICdmaWx0ZXIyJ10pO1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb21tYW5kLnZpZGVvRmlsdGVycyhbXG4gICAqICAge1xuICAgKiAgICAgZmlsdGVyOiAnZmlsdGVyMSdcbiAgICogICB9LFxuICAgKiAgIHtcbiAgICogICAgIGZpbHRlcjogJ2ZpbHRlcjInLFxuICAgKiAgICAgb3B0aW9uczogJ3BhcmFtPXZhbHVlOnBhcmFtPXZhbHVlJ1xuICAgKiAgIH1cbiAgICogXSk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbW1hbmQudmlkZW9GaWx0ZXJzKFxuICAgKiAgIHtcbiAgICogICAgIGZpbHRlcjogJ2ZpbHRlcjEnLFxuICAgKiAgICAgb3B0aW9uczogWyd2YWx1ZTEnLCAndmFsdWUyJ11cbiAgICogICB9LFxuICAgKiAgIHtcbiAgICogICAgIGZpbHRlcjogJ2ZpbHRlcjInLFxuICAgKiAgICAgb3B0aW9uczogeyBwYXJhbTE6ICd2YWx1ZTEnLCBwYXJhbTI6ICd2YWx1ZTInIH1cbiAgICogICB9XG4gICAqICk7XG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCN2aWRlb0ZpbHRlcnNcbiAgICogQGNhdGVnb3J5IFZpZGVvXG4gICAqIEBhbGlhc2VzIHdpdGhWaWRlb0ZpbHRlcix3aXRoVmlkZW9GaWx0ZXJzLHZpZGVvRmlsdGVyXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfFN0cmluZ1tdfE9iamVjdFtdfSBmaWx0ZXJzIHZpZGVvIGZpbHRlciBzdHJpbmdzLCBzdHJpbmcgYXJyYXkgb3JcbiAgICogICBmaWx0ZXIgc3BlY2lmaWNhdGlvbiBhcnJheSwgZWFjaCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbHRlcnMuZmlsdGVyIGZpbHRlciBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfE9iamVjdH0gW2ZpbHRlcnMub3B0aW9uc10gZmlsdGVyIG9wdGlvbiBzdHJpbmcsIGFycmF5LCBvciBvYmplY3RcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by53aXRoVmlkZW9GaWx0ZXIgPVxuICBwcm90by53aXRoVmlkZW9GaWx0ZXJzID1cbiAgcHJvdG8udmlkZW9GaWx0ZXIgPVxuICBwcm90by52aWRlb0ZpbHRlcnMgPSBmdW5jdGlvbihmaWx0ZXJzKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBmaWx0ZXJzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShmaWx0ZXJzKSkge1xuICAgICAgZmlsdGVycyA9IFtmaWx0ZXJzXTtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LnZpZGVvRmlsdGVycyh1dGlscy5tYWtlRmlsdGVyU3RyaW5ncyhmaWx0ZXJzKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IG91dHB1dCBGUFNcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2Zwc1xuICAgKiBAY2F0ZWdvcnkgVmlkZW9cbiAgICogQGFsaWFzZXMgd2l0aE91dHB1dEZwcyx3aXRoT3V0cHV0RlBTLHdpdGhGcHNPdXRwdXQsd2l0aEZQU091dHB1dCx3aXRoRnBzLHdpdGhGUFMsb3V0cHV0RlBTLG91dHB1dEZwcyxmcHNPdXRwdXQsRlBTT3V0cHV0LEZQU1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnBzIG91dHB1dCBGUFNcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by53aXRoT3V0cHV0RnBzID1cbiAgcHJvdG8ud2l0aE91dHB1dEZQUyA9XG4gIHByb3RvLndpdGhGcHNPdXRwdXQgPVxuICBwcm90by53aXRoRlBTT3V0cHV0ID1cbiAgcHJvdG8ud2l0aEZwcyA9XG4gIHByb3RvLndpdGhGUFMgPVxuICBwcm90by5vdXRwdXRGUFMgPVxuICBwcm90by5vdXRwdXRGcHMgPVxuICBwcm90by5mcHNPdXRwdXQgPVxuICBwcm90by5GUFNPdXRwdXQgPVxuICBwcm90by5mcHMgPVxuICBwcm90by5GUFMgPSBmdW5jdGlvbihmcHMpIHtcbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LnZpZGVvKCctcicsIGZwcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogT25seSB0cmFuc2NvZGUgYSBjZXJ0YWluIG51bWJlciBvZiBmcmFtZXNcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2ZyYW1lc1xuICAgKiBAY2F0ZWdvcnkgVmlkZW9cbiAgICogQGFsaWFzZXMgdGFrZUZyYW1lcyx3aXRoRnJhbWVzXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZXMgZnJhbWUgY291bnRcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by50YWtlRnJhbWVzID1cbiAgcHJvdG8ud2l0aEZyYW1lcyA9XG4gIHByb3RvLmZyYW1lcyA9IGZ1bmN0aW9uKGZyYW1lcykge1xuICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQudmlkZW8oJy12ZnJhbWVzJywgZnJhbWVzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/options/video.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/options/videosize.js":
/*!*************************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/options/videosize.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("/*jshint node:true*/\n\n\n/*\n *! Size helpers\n */\n\n\n/**\n * Return filters to pad video to width*height,\n *\n * @param {Number} width output width\n * @param {Number} height output height\n * @param {Number} aspect video aspect ratio (without padding)\n * @param {Number} color padding color\n * @return scale/pad filters\n * @private\n */\nfunction getScalePadFilters(width, height, aspect, color) {\n  /*\n    let a be the input aspect ratio, A be the requested aspect ratio\n\n    if a > A, padding is done on top and bottom\n    if a < A, padding is done on left and right\n   */\n\n  return [\n    /*\n      In both cases, we first have to scale the input to match the requested size.\n      When using computed width/height, we truncate them to multiples of 2\n     */\n    {\n      filter: 'scale',\n      options: {\n        w: 'if(gt(a,' + aspect + '),' + width + ',trunc(' + height + '*a/2)*2)',\n        h: 'if(lt(a,' + aspect + '),' + height + ',trunc(' + width + '/a/2)*2)'\n      }\n    },\n\n    /*\n      Then we pad the scaled input to match the target size\n      (here iw and ih refer to the padding input, i.e the scaled output)\n     */\n\n    {\n      filter: 'pad',\n      options: {\n        w: width,\n        h: height,\n        x: 'if(gt(a,' + aspect + '),0,(' + width + '-iw)/2)',\n        y: 'if(lt(a,' + aspect + '),0,(' + height + '-ih)/2)',\n        color: color\n      }\n    }\n  ];\n}\n\n\n/**\n * Recompute size filters\n *\n * @param {Object} output\n * @param {String} key newly-added parameter name ('size', 'aspect' or 'pad')\n * @param {String} value newly-added parameter value\n * @return filter string array\n * @private\n */\nfunction createSizeFilters(output, key, value) {\n  // Store parameters\n  var data = output.sizeData = output.sizeData || {};\n  data[key] = value;\n\n  if (!('size' in data)) {\n    // No size requested, keep original size\n    return [];\n  }\n\n  // Try to match the different size string formats\n  var fixedSize = data.size.match(/([0-9]+)x([0-9]+)/);\n  var fixedWidth = data.size.match(/([0-9]+)x\\?/);\n  var fixedHeight = data.size.match(/\\?x([0-9]+)/);\n  var percentRatio = data.size.match(/\\b([0-9]{1,3})%/);\n  var width, height, aspect;\n\n  if (percentRatio) {\n    var ratio = Number(percentRatio[1]) / 100;\n    return [{\n      filter: 'scale',\n      options: {\n        w: 'trunc(iw*' + ratio + '/2)*2',\n        h: 'trunc(ih*' + ratio + '/2)*2'\n      }\n    }];\n  } else if (fixedSize) {\n    // Round target size to multiples of 2\n    width = Math.round(Number(fixedSize[1]) / 2) * 2;\n    height = Math.round(Number(fixedSize[2]) / 2) * 2;\n\n    aspect = width / height;\n\n    if (data.pad) {\n      return getScalePadFilters(width, height, aspect, data.pad);\n    } else {\n      // No autopad requested, rescale to target size\n      return [{ filter: 'scale', options: { w: width, h: height }}];\n    }\n  } else if (fixedWidth || fixedHeight) {\n    if ('aspect' in data) {\n      // Specified aspect ratio\n      width = fixedWidth ? fixedWidth[1] : Math.round(Number(fixedHeight[1]) * data.aspect);\n      height = fixedHeight ? fixedHeight[1] : Math.round(Number(fixedWidth[1]) / data.aspect);\n\n      // Round to multiples of 2\n      width = Math.round(width / 2) * 2;\n      height = Math.round(height / 2) * 2;\n\n      if (data.pad) {\n        return getScalePadFilters(width, height, data.aspect, data.pad);\n      } else {\n        // No autopad requested, rescale to target size\n        return [{ filter: 'scale', options: { w: width, h: height }}];\n      }\n    } else {\n      // Keep input aspect ratio\n\n      if (fixedWidth) {\n        return [{\n          filter: 'scale',\n          options: {\n            w: Math.round(Number(fixedWidth[1]) / 2) * 2,\n            h: 'trunc(ow/a/2)*2'\n          }\n        }];\n      } else {\n        return [{\n          filter: 'scale',\n          options: {\n            w: 'trunc(oh*a/2)*2',\n            h: Math.round(Number(fixedHeight[1]) / 2) * 2\n          }\n        }];\n      }\n    }\n  } else {\n    throw new Error('Invalid size specified: ' + data.size);\n  }\n}\n\n\n/*\n *! Video size-related methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Keep display aspect ratio\n   *\n   * This method is useful when converting an input with non-square pixels to an output format\n   * that does not support non-square pixels.  It rescales the input so that the display aspect\n   * ratio is the same.\n   *\n   * @method FfmpegCommand#keepDAR\n   * @category Video size\n   * @aliases keepPixelAspect,keepDisplayAspect,keepDisplayAspectRatio\n   *\n   * @return FfmpegCommand\n   */\n  proto.keepPixelAspect = // Only for compatibility, this is not about keeping _pixel_ aspect ratio\n  proto.keepDisplayAspect =\n  proto.keepDisplayAspectRatio =\n  proto.keepDAR = function() {\n    return this.videoFilters([\n      {\n        filter: 'scale',\n        options: {\n          w: 'if(gt(sar,1),iw*sar,iw)',\n          h: 'if(lt(sar,1),ih/sar,ih)'\n        }\n      },\n      {\n        filter: 'setsar',\n        options: '1'\n      }\n    ]);\n  };\n\n\n  /**\n   * Set output size\n   *\n   * The 'size' parameter can have one of 4 forms:\n   * - 'X%': rescale to xx % of the original size\n   * - 'WxH': specify width and height\n   * - 'Wx?': specify width and compute height from input aspect ratio\n   * - '?xH': specify height and compute width from input aspect ratio\n   *\n   * Note: both dimensions will be truncated to multiples of 2.\n   *\n   * @method FfmpegCommand#size\n   * @category Video size\n   * @aliases withSize,setSize\n   *\n   * @param {String} size size string, eg. '33%', '320x240', '320x?', '?x240'\n   * @return FfmpegCommand\n   */\n  proto.withSize =\n  proto.setSize =\n  proto.size = function(size) {\n    var filters = createSizeFilters(this._currentOutput, 'size', size);\n\n    this._currentOutput.sizeFilters.clear();\n    this._currentOutput.sizeFilters(filters);\n\n    return this;\n  };\n\n\n  /**\n   * Set output aspect ratio\n   *\n   * @method FfmpegCommand#aspect\n   * @category Video size\n   * @aliases withAspect,withAspectRatio,setAspect,setAspectRatio,aspectRatio\n   *\n   * @param {String|Number} aspect aspect ratio (number or 'X:Y' string)\n   * @return FfmpegCommand\n   */\n  proto.withAspect =\n  proto.withAspectRatio =\n  proto.setAspect =\n  proto.setAspectRatio =\n  proto.aspect =\n  proto.aspectRatio = function(aspect) {\n    var a = Number(aspect);\n    if (isNaN(a)) {\n      var match = aspect.match(/^(\\d+):(\\d+)$/);\n      if (match) {\n        a = Number(match[1]) / Number(match[2]);\n      } else {\n        throw new Error('Invalid aspect ratio: ' + aspect);\n      }\n    }\n\n    var filters = createSizeFilters(this._currentOutput, 'aspect', a);\n\n    this._currentOutput.sizeFilters.clear();\n    this._currentOutput.sizeFilters(filters);\n\n    return this;\n  };\n\n\n  /**\n   * Enable auto-padding the output\n   *\n   * @method FfmpegCommand#autopad\n   * @category Video size\n   * @aliases applyAutopadding,applyAutoPadding,applyAutopad,applyAutoPad,withAutopadding,withAutoPadding,withAutopad,withAutoPad,autoPad\n   *\n   * @param {Boolean} [pad=true] enable/disable auto-padding\n   * @param {String} [color='black'] pad color\n   */\n  proto.applyAutopadding =\n  proto.applyAutoPadding =\n  proto.applyAutopad =\n  proto.applyAutoPad =\n  proto.withAutopadding =\n  proto.withAutoPadding =\n  proto.withAutopad =\n  proto.withAutoPad =\n  proto.autoPad =\n  proto.autopad = function(pad, color) {\n    // Allow autopad(color)\n    if (typeof pad === 'string') {\n      color = pad;\n      pad = true;\n    }\n\n    // Allow autopad() and autopad(undefined, color)\n    if (typeof pad === 'undefined') {\n      pad = true;\n    }\n\n    var filters = createSizeFilters(this._currentOutput, 'pad', pad ? color || 'black' : false);\n\n    this._currentOutput.sizeFilters.clear();\n    this._currentOutput.sizeFilters(filters);\n\n    return this;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvb3B0aW9ucy92aWRlb3NpemUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTs7QUFFYjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsSUFBSTtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGdCQUFnQiw0QkFBNEIsc0JBQXNCO0FBQ2xFO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0JBQWtCLDRCQUE0QixzQkFBc0I7QUFDcEU7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1maXJlYmFzZS1hcGkvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvb3B0aW9ucy92aWRlb3NpemUuanM/OWMwZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzaGludCBub2RlOnRydWUqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKlxuICohIFNpemUgaGVscGVyc1xuICovXG5cblxuLyoqXG4gKiBSZXR1cm4gZmlsdGVycyB0byBwYWQgdmlkZW8gdG8gd2lkdGgqaGVpZ2h0LFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBvdXRwdXQgd2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgb3V0cHV0IGhlaWdodFxuICogQHBhcmFtIHtOdW1iZXJ9IGFzcGVjdCB2aWRlbyBhc3BlY3QgcmF0aW8gKHdpdGhvdXQgcGFkZGluZylcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2xvciBwYWRkaW5nIGNvbG9yXG4gKiBAcmV0dXJuIHNjYWxlL3BhZCBmaWx0ZXJzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRTY2FsZVBhZEZpbHRlcnMod2lkdGgsIGhlaWdodCwgYXNwZWN0LCBjb2xvcikge1xuICAvKlxuICAgIGxldCBhIGJlIHRoZSBpbnB1dCBhc3BlY3QgcmF0aW8sIEEgYmUgdGhlIHJlcXVlc3RlZCBhc3BlY3QgcmF0aW9cblxuICAgIGlmIGEgPiBBLCBwYWRkaW5nIGlzIGRvbmUgb24gdG9wIGFuZCBib3R0b21cbiAgICBpZiBhIDwgQSwgcGFkZGluZyBpcyBkb25lIG9uIGxlZnQgYW5kIHJpZ2h0XG4gICAqL1xuXG4gIHJldHVybiBbXG4gICAgLypcbiAgICAgIEluIGJvdGggY2FzZXMsIHdlIGZpcnN0IGhhdmUgdG8gc2NhbGUgdGhlIGlucHV0IHRvIG1hdGNoIHRoZSByZXF1ZXN0ZWQgc2l6ZS5cbiAgICAgIFdoZW4gdXNpbmcgY29tcHV0ZWQgd2lkdGgvaGVpZ2h0LCB3ZSB0cnVuY2F0ZSB0aGVtIHRvIG11bHRpcGxlcyBvZiAyXG4gICAgICovXG4gICAge1xuICAgICAgZmlsdGVyOiAnc2NhbGUnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICB3OiAnaWYoZ3QoYSwnICsgYXNwZWN0ICsgJyksJyArIHdpZHRoICsgJyx0cnVuYygnICsgaGVpZ2h0ICsgJyphLzIpKjIpJyxcbiAgICAgICAgaDogJ2lmKGx0KGEsJyArIGFzcGVjdCArICcpLCcgKyBoZWlnaHQgKyAnLHRydW5jKCcgKyB3aWR0aCArICcvYS8yKSoyKSdcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLypcbiAgICAgIFRoZW4gd2UgcGFkIHRoZSBzY2FsZWQgaW5wdXQgdG8gbWF0Y2ggdGhlIHRhcmdldCBzaXplXG4gICAgICAoaGVyZSBpdyBhbmQgaWggcmVmZXIgdG8gdGhlIHBhZGRpbmcgaW5wdXQsIGkuZSB0aGUgc2NhbGVkIG91dHB1dClcbiAgICAgKi9cblxuICAgIHtcbiAgICAgIGZpbHRlcjogJ3BhZCcsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHc6IHdpZHRoLFxuICAgICAgICBoOiBoZWlnaHQsXG4gICAgICAgIHg6ICdpZihndChhLCcgKyBhc3BlY3QgKyAnKSwwLCgnICsgd2lkdGggKyAnLWl3KS8yKScsXG4gICAgICAgIHk6ICdpZihsdChhLCcgKyBhc3BlY3QgKyAnKSwwLCgnICsgaGVpZ2h0ICsgJy1paCkvMiknLFxuICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgIH1cbiAgICB9XG4gIF07XG59XG5cblxuLyoqXG4gKiBSZWNvbXB1dGUgc2l6ZSBmaWx0ZXJzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG91dHB1dFxuICogQHBhcmFtIHtTdHJpbmd9IGtleSBuZXdseS1hZGRlZCBwYXJhbWV0ZXIgbmFtZSAoJ3NpemUnLCAnYXNwZWN0JyBvciAncGFkJylcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBuZXdseS1hZGRlZCBwYXJhbWV0ZXIgdmFsdWVcbiAqIEByZXR1cm4gZmlsdGVyIHN0cmluZyBhcnJheVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2l6ZUZpbHRlcnMob3V0cHV0LCBrZXksIHZhbHVlKSB7XG4gIC8vIFN0b3JlIHBhcmFtZXRlcnNcbiAgdmFyIGRhdGEgPSBvdXRwdXQuc2l6ZURhdGEgPSBvdXRwdXQuc2l6ZURhdGEgfHwge307XG4gIGRhdGFba2V5XSA9IHZhbHVlO1xuXG4gIGlmICghKCdzaXplJyBpbiBkYXRhKSkge1xuICAgIC8vIE5vIHNpemUgcmVxdWVzdGVkLCBrZWVwIG9yaWdpbmFsIHNpemVcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvLyBUcnkgdG8gbWF0Y2ggdGhlIGRpZmZlcmVudCBzaXplIHN0cmluZyBmb3JtYXRzXG4gIHZhciBmaXhlZFNpemUgPSBkYXRhLnNpemUubWF0Y2goLyhbMC05XSspeChbMC05XSspLyk7XG4gIHZhciBmaXhlZFdpZHRoID0gZGF0YS5zaXplLm1hdGNoKC8oWzAtOV0rKXhcXD8vKTtcbiAgdmFyIGZpeGVkSGVpZ2h0ID0gZGF0YS5zaXplLm1hdGNoKC9cXD94KFswLTldKykvKTtcbiAgdmFyIHBlcmNlbnRSYXRpbyA9IGRhdGEuc2l6ZS5tYXRjaCgvXFxiKFswLTldezEsM30pJS8pO1xuICB2YXIgd2lkdGgsIGhlaWdodCwgYXNwZWN0O1xuXG4gIGlmIChwZXJjZW50UmF0aW8pIHtcbiAgICB2YXIgcmF0aW8gPSBOdW1iZXIocGVyY2VudFJhdGlvWzFdKSAvIDEwMDtcbiAgICByZXR1cm4gW3tcbiAgICAgIGZpbHRlcjogJ3NjYWxlJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdzogJ3RydW5jKGl3KicgKyByYXRpbyArICcvMikqMicsXG4gICAgICAgIGg6ICd0cnVuYyhpaConICsgcmF0aW8gKyAnLzIpKjInXG4gICAgICB9XG4gICAgfV07XG4gIH0gZWxzZSBpZiAoZml4ZWRTaXplKSB7XG4gICAgLy8gUm91bmQgdGFyZ2V0IHNpemUgdG8gbXVsdGlwbGVzIG9mIDJcbiAgICB3aWR0aCA9IE1hdGgucm91bmQoTnVtYmVyKGZpeGVkU2l6ZVsxXSkgLyAyKSAqIDI7XG4gICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChOdW1iZXIoZml4ZWRTaXplWzJdKSAvIDIpICogMjtcblxuICAgIGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuXG4gICAgaWYgKGRhdGEucGFkKSB7XG4gICAgICByZXR1cm4gZ2V0U2NhbGVQYWRGaWx0ZXJzKHdpZHRoLCBoZWlnaHQsIGFzcGVjdCwgZGF0YS5wYWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBhdXRvcGFkIHJlcXVlc3RlZCwgcmVzY2FsZSB0byB0YXJnZXQgc2l6ZVxuICAgICAgcmV0dXJuIFt7IGZpbHRlcjogJ3NjYWxlJywgb3B0aW9uczogeyB3OiB3aWR0aCwgaDogaGVpZ2h0IH19XTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZml4ZWRXaWR0aCB8fCBmaXhlZEhlaWdodCkge1xuICAgIGlmICgnYXNwZWN0JyBpbiBkYXRhKSB7XG4gICAgICAvLyBTcGVjaWZpZWQgYXNwZWN0IHJhdGlvXG4gICAgICB3aWR0aCA9IGZpeGVkV2lkdGggPyBmaXhlZFdpZHRoWzFdIDogTWF0aC5yb3VuZChOdW1iZXIoZml4ZWRIZWlnaHRbMV0pICogZGF0YS5hc3BlY3QpO1xuICAgICAgaGVpZ2h0ID0gZml4ZWRIZWlnaHQgPyBmaXhlZEhlaWdodFsxXSA6IE1hdGgucm91bmQoTnVtYmVyKGZpeGVkV2lkdGhbMV0pIC8gZGF0YS5hc3BlY3QpO1xuXG4gICAgICAvLyBSb3VuZCB0byBtdWx0aXBsZXMgb2YgMlxuICAgICAgd2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoIC8gMikgKiAyO1xuICAgICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQgLyAyKSAqIDI7XG5cbiAgICAgIGlmIChkYXRhLnBhZCkge1xuICAgICAgICByZXR1cm4gZ2V0U2NhbGVQYWRGaWx0ZXJzKHdpZHRoLCBoZWlnaHQsIGRhdGEuYXNwZWN0LCBkYXRhLnBhZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyBhdXRvcGFkIHJlcXVlc3RlZCwgcmVzY2FsZSB0byB0YXJnZXQgc2l6ZVxuICAgICAgICByZXR1cm4gW3sgZmlsdGVyOiAnc2NhbGUnLCBvcHRpb25zOiB7IHc6IHdpZHRoLCBoOiBoZWlnaHQgfX1dO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBLZWVwIGlucHV0IGFzcGVjdCByYXRpb1xuXG4gICAgICBpZiAoZml4ZWRXaWR0aCkge1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICBmaWx0ZXI6ICdzY2FsZScsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgdzogTWF0aC5yb3VuZChOdW1iZXIoZml4ZWRXaWR0aFsxXSkgLyAyKSAqIDIsXG4gICAgICAgICAgICBoOiAndHJ1bmMob3cvYS8yKSoyJ1xuICAgICAgICAgIH1cbiAgICAgICAgfV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICBmaWx0ZXI6ICdzY2FsZScsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgdzogJ3RydW5jKG9oKmEvMikqMicsXG4gICAgICAgICAgICBoOiBNYXRoLnJvdW5kKE51bWJlcihmaXhlZEhlaWdodFsxXSkgLyAyKSAqIDJcbiAgICAgICAgICB9XG4gICAgICAgIH1dO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2l6ZSBzcGVjaWZpZWQ6ICcgKyBkYXRhLnNpemUpO1xuICB9XG59XG5cblxuLypcbiAqISBWaWRlbyBzaXplLXJlbGF0ZWQgbWV0aG9kc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocHJvdG8pIHtcbiAgLyoqXG4gICAqIEtlZXAgZGlzcGxheSBhc3BlY3QgcmF0aW9cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZnVsIHdoZW4gY29udmVydGluZyBhbiBpbnB1dCB3aXRoIG5vbi1zcXVhcmUgcGl4ZWxzIHRvIGFuIG91dHB1dCBmb3JtYXRcbiAgICogdGhhdCBkb2VzIG5vdCBzdXBwb3J0IG5vbi1zcXVhcmUgcGl4ZWxzLiAgSXQgcmVzY2FsZXMgdGhlIGlucHV0IHNvIHRoYXQgdGhlIGRpc3BsYXkgYXNwZWN0XG4gICAqIHJhdGlvIGlzIHRoZSBzYW1lLlxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQja2VlcERBUlxuICAgKiBAY2F0ZWdvcnkgVmlkZW8gc2l6ZVxuICAgKiBAYWxpYXNlcyBrZWVwUGl4ZWxBc3BlY3Qsa2VlcERpc3BsYXlBc3BlY3Qsa2VlcERpc3BsYXlBc3BlY3RSYXRpb1xuICAgKlxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLmtlZXBQaXhlbEFzcGVjdCA9IC8vIE9ubHkgZm9yIGNvbXBhdGliaWxpdHksIHRoaXMgaXMgbm90IGFib3V0IGtlZXBpbmcgX3BpeGVsXyBhc3BlY3QgcmF0aW9cbiAgcHJvdG8ua2VlcERpc3BsYXlBc3BlY3QgPVxuICBwcm90by5rZWVwRGlzcGxheUFzcGVjdFJhdGlvID1cbiAgcHJvdG8ua2VlcERBUiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnZpZGVvRmlsdGVycyhbXG4gICAgICB7XG4gICAgICAgIGZpbHRlcjogJ3NjYWxlJyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHc6ICdpZihndChzYXIsMSksaXcqc2FyLGl3KScsXG4gICAgICAgICAgaDogJ2lmKGx0KHNhciwxKSxpaC9zYXIsaWgpJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBmaWx0ZXI6ICdzZXRzYXInLFxuICAgICAgICBvcHRpb25zOiAnMSdcbiAgICAgIH1cbiAgICBdKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBTZXQgb3V0cHV0IHNpemVcbiAgICpcbiAgICogVGhlICdzaXplJyBwYXJhbWV0ZXIgY2FuIGhhdmUgb25lIG9mIDQgZm9ybXM6XG4gICAqIC0gJ1glJzogcmVzY2FsZSB0byB4eCAlIG9mIHRoZSBvcmlnaW5hbCBzaXplXG4gICAqIC0gJ1d4SCc6IHNwZWNpZnkgd2lkdGggYW5kIGhlaWdodFxuICAgKiAtICdXeD8nOiBzcGVjaWZ5IHdpZHRoIGFuZCBjb21wdXRlIGhlaWdodCBmcm9tIGlucHV0IGFzcGVjdCByYXRpb1xuICAgKiAtICc/eEgnOiBzcGVjaWZ5IGhlaWdodCBhbmQgY29tcHV0ZSB3aWR0aCBmcm9tIGlucHV0IGFzcGVjdCByYXRpb1xuICAgKlxuICAgKiBOb3RlOiBib3RoIGRpbWVuc2lvbnMgd2lsbCBiZSB0cnVuY2F0ZWQgdG8gbXVsdGlwbGVzIG9mIDIuXG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNzaXplXG4gICAqIEBjYXRlZ29yeSBWaWRlbyBzaXplXG4gICAqIEBhbGlhc2VzIHdpdGhTaXplLHNldFNpemVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpemUgc2l6ZSBzdHJpbmcsIGVnLiAnMzMlJywgJzMyMHgyNDAnLCAnMzIweD8nLCAnP3gyNDAnXG4gICAqIEByZXR1cm4gRmZtcGVnQ29tbWFuZFxuICAgKi9cbiAgcHJvdG8ud2l0aFNpemUgPVxuICBwcm90by5zZXRTaXplID1cbiAgcHJvdG8uc2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB2YXIgZmlsdGVycyA9IGNyZWF0ZVNpemVGaWx0ZXJzKHRoaXMuX2N1cnJlbnRPdXRwdXQsICdzaXplJywgc2l6ZSk7XG5cbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LnNpemVGaWx0ZXJzLmNsZWFyKCk7XG4gICAgdGhpcy5fY3VycmVudE91dHB1dC5zaXplRmlsdGVycyhmaWx0ZXJzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNldCBvdXRwdXQgYXNwZWN0IHJhdGlvXG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNhc3BlY3RcbiAgICogQGNhdGVnb3J5IFZpZGVvIHNpemVcbiAgICogQGFsaWFzZXMgd2l0aEFzcGVjdCx3aXRoQXNwZWN0UmF0aW8sc2V0QXNwZWN0LHNldEFzcGVjdFJhdGlvLGFzcGVjdFJhdGlvXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gYXNwZWN0IGFzcGVjdCByYXRpbyAobnVtYmVyIG9yICdYOlknIHN0cmluZylcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by53aXRoQXNwZWN0ID1cbiAgcHJvdG8ud2l0aEFzcGVjdFJhdGlvID1cbiAgcHJvdG8uc2V0QXNwZWN0ID1cbiAgcHJvdG8uc2V0QXNwZWN0UmF0aW8gPVxuICBwcm90by5hc3BlY3QgPVxuICBwcm90by5hc3BlY3RSYXRpbyA9IGZ1bmN0aW9uKGFzcGVjdCkge1xuICAgIHZhciBhID0gTnVtYmVyKGFzcGVjdCk7XG4gICAgaWYgKGlzTmFOKGEpKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBhc3BlY3QubWF0Y2goL14oXFxkKyk6KFxcZCspJC8pO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGEgPSBOdW1iZXIobWF0Y2hbMV0pIC8gTnVtYmVyKG1hdGNoWzJdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhc3BlY3QgcmF0aW86ICcgKyBhc3BlY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmaWx0ZXJzID0gY3JlYXRlU2l6ZUZpbHRlcnModGhpcy5fY3VycmVudE91dHB1dCwgJ2FzcGVjdCcsIGEpO1xuXG4gICAgdGhpcy5fY3VycmVudE91dHB1dC5zaXplRmlsdGVycy5jbGVhcigpO1xuICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQuc2l6ZUZpbHRlcnMoZmlsdGVycyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBFbmFibGUgYXV0by1wYWRkaW5nIHRoZSBvdXRwdXRcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2F1dG9wYWRcbiAgICogQGNhdGVnb3J5IFZpZGVvIHNpemVcbiAgICogQGFsaWFzZXMgYXBwbHlBdXRvcGFkZGluZyxhcHBseUF1dG9QYWRkaW5nLGFwcGx5QXV0b3BhZCxhcHBseUF1dG9QYWQsd2l0aEF1dG9wYWRkaW5nLHdpdGhBdXRvUGFkZGluZyx3aXRoQXV0b3BhZCx3aXRoQXV0b1BhZCxhdXRvUGFkXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhZD10cnVlXSBlbmFibGUvZGlzYWJsZSBhdXRvLXBhZGRpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb2xvcj0nYmxhY2snXSBwYWQgY29sb3JcbiAgICovXG4gIHByb3RvLmFwcGx5QXV0b3BhZGRpbmcgPVxuICBwcm90by5hcHBseUF1dG9QYWRkaW5nID1cbiAgcHJvdG8uYXBwbHlBdXRvcGFkID1cbiAgcHJvdG8uYXBwbHlBdXRvUGFkID1cbiAgcHJvdG8ud2l0aEF1dG9wYWRkaW5nID1cbiAgcHJvdG8ud2l0aEF1dG9QYWRkaW5nID1cbiAgcHJvdG8ud2l0aEF1dG9wYWQgPVxuICBwcm90by53aXRoQXV0b1BhZCA9XG4gIHByb3RvLmF1dG9QYWQgPVxuICBwcm90by5hdXRvcGFkID0gZnVuY3Rpb24ocGFkLCBjb2xvcikge1xuICAgIC8vIEFsbG93IGF1dG9wYWQoY29sb3IpXG4gICAgaWYgKHR5cGVvZiBwYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb2xvciA9IHBhZDtcbiAgICAgIHBhZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgYXV0b3BhZCgpIGFuZCBhdXRvcGFkKHVuZGVmaW5lZCwgY29sb3IpXG4gICAgaWYgKHR5cGVvZiBwYWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwYWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBmaWx0ZXJzID0gY3JlYXRlU2l6ZUZpbHRlcnModGhpcy5fY3VycmVudE91dHB1dCwgJ3BhZCcsIHBhZCA/IGNvbG9yIHx8ICdibGFjaycgOiBmYWxzZSk7XG5cbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LnNpemVGaWx0ZXJzLmNsZWFyKCk7XG4gICAgdGhpcy5fY3VycmVudE91dHB1dC5zaXplRmlsdGVycyhmaWx0ZXJzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/options/videosize.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/processor.js":
/*!*****************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/processor.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar spawn = (__webpack_require__(/*! child_process */ \"child_process\").spawn);\nvar path = __webpack_require__(/*! path */ \"path?8ff8\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar async = __webpack_require__(/*! async */ \"(rsc)/./node_modules/async/lib/async.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\");\n\n/*\n *! Processor methods\n */\n\n\n/**\n * Run ffprobe asynchronously and store data in command\n *\n * @param {FfmpegCommand} command\n * @private\n */\nfunction runFfprobe(command) {\n  const inputProbeIndex = 0;\n  if (command._inputs[inputProbeIndex].isStream) {\n    // Don't probe input streams as this will consume them\n    return;\n  }\n  command.ffprobe(inputProbeIndex, function(err, data) {\n    command._ffprobeData = data;\n  });\n}\n\n\nmodule.exports = function(proto) {\n  /**\n   * Emitted just after ffmpeg has been spawned.\n   *\n   * @event FfmpegCommand#start\n   * @param {String} command ffmpeg command line\n   */\n\n  /**\n   * Emitted when ffmpeg reports progress information\n   *\n   * @event FfmpegCommand#progress\n   * @param {Object} progress progress object\n   * @param {Number} progress.frames number of frames transcoded\n   * @param {Number} progress.currentFps current processing speed in frames per second\n   * @param {Number} progress.currentKbps current output generation speed in kilobytes per second\n   * @param {Number} progress.targetSize current output file size\n   * @param {String} progress.timemark current video timemark\n   * @param {Number} [progress.percent] processing progress (may not be available depending on input)\n   */\n\n  /**\n   * Emitted when ffmpeg outputs to stderr\n   *\n   * @event FfmpegCommand#stderr\n   * @param {String} line stderr output line\n   */\n\n  /**\n   * Emitted when ffmpeg reports input codec data\n   *\n   * @event FfmpegCommand#codecData\n   * @param {Object} codecData codec data object\n   * @param {String} codecData.format input format name\n   * @param {String} codecData.audio input audio codec name\n   * @param {String} codecData.audio_details input audio codec parameters\n   * @param {String} codecData.video input video codec name\n   * @param {String} codecData.video_details input video codec parameters\n   */\n\n  /**\n   * Emitted when an error happens when preparing or running a command\n   *\n   * @event FfmpegCommand#error\n   * @param {Error} error error object, with optional properties 'inputStreamError' / 'outputStreamError' for errors on their respective streams\n   * @param {String|null} stdout ffmpeg stdout, unless outputting to a stream\n   * @param {String|null} stderr ffmpeg stderr\n   */\n\n  /**\n   * Emitted when a command finishes processing\n   *\n   * @event FfmpegCommand#end\n   * @param {Array|String|null} [filenames|stdout] generated filenames when taking screenshots, ffmpeg stdout when not outputting to a stream, null otherwise\n   * @param {String|null} stderr ffmpeg stderr\n   */\n\n\n  /**\n   * Spawn an ffmpeg process\n   *\n   * The 'options' argument may contain the following keys:\n   * - 'niceness': specify process niceness, ignored on Windows (default: 0)\n   * - `cwd`: change working directory\n   * - 'captureStdout': capture stdout and pass it to 'endCB' as its 2nd argument (default: false)\n   * - 'stdoutLines': override command limit (default: use command limit)\n   *\n   * The 'processCB' callback, if present, is called as soon as the process is created and\n   * receives a nodejs ChildProcess object.  It may not be called at all if an error happens\n   * before spawning the process.\n   *\n   * The 'endCB' callback is called either when an error occurs or when the ffmpeg process finishes.\n   *\n   * @method FfmpegCommand#_spawnFfmpeg\n   * @param {Array} args ffmpeg command line argument list\n   * @param {Object} [options] spawn options (see above)\n   * @param {Function} [processCB] callback called with process object and stdout/stderr ring buffers when process has been created\n   * @param {Function} endCB callback called with error (if applicable) and stdout/stderr ring buffers when process finished\n   * @private\n   */\n  proto._spawnFfmpeg = function(args, options, processCB, endCB) {\n    // Enable omitting options\n    if (typeof options === 'function') {\n      endCB = processCB;\n      processCB = options;\n      options = {};\n    }\n\n    // Enable omitting processCB\n    if (typeof endCB === 'undefined') {\n      endCB = processCB;\n      processCB = function() {};\n    }\n\n    var maxLines = 'stdoutLines' in options ? options.stdoutLines : this.options.stdoutLines;\n\n    // Find ffmpeg\n    this._getFfmpegPath(function(err, command) {\n      if (err) {\n        return endCB(err);\n      } else if (!command || command.length === 0) {\n        return endCB(new Error('Cannot find ffmpeg'));\n      }\n\n      // Apply niceness\n      if (options.niceness && options.niceness !== 0 && !utils.isWindows) {\n        args.unshift('-n', options.niceness, command);\n        command = 'nice';\n      }\n\n      var stdoutRing = utils.linesRing(maxLines);\n      var stdoutClosed = false;\n\n      var stderrRing = utils.linesRing(maxLines);\n      var stderrClosed = false;\n\n      // Spawn process\n      var ffmpegProc = spawn(command, args, options);\n\n      if (ffmpegProc.stderr) {\n        ffmpegProc.stderr.setEncoding('utf8');\n      }\n\n      ffmpegProc.on('error', function(err) {\n        endCB(err);\n      });\n\n      // Ensure we wait for captured streams to end before calling endCB\n      var exitError = null;\n      function handleExit(err) {\n        if (err) {\n          exitError = err;\n        }\n\n        if (processExited && (stdoutClosed || !options.captureStdout) && stderrClosed) {\n          endCB(exitError, stdoutRing, stderrRing);\n        }\n      }\n\n      // Handle process exit\n      var processExited = false;\n      ffmpegProc.on('exit', function(code, signal) {\n        processExited = true;\n\n        if (signal) {\n          handleExit(new Error('ffmpeg was killed with signal ' + signal));\n        } else if (code) {\n          handleExit(new Error('ffmpeg exited with code ' + code));\n        } else {\n          handleExit();\n        }\n      });\n\n      // Capture stdout if specified\n      if (options.captureStdout) {\n        ffmpegProc.stdout.on('data', function(data) {\n          stdoutRing.append(data);\n        });\n\n        ffmpegProc.stdout.on('close', function() {\n          stdoutRing.close();\n          stdoutClosed = true;\n          handleExit();\n        });\n      }\n\n      // Capture stderr if specified\n      ffmpegProc.stderr.on('data', function(data) {\n        stderrRing.append(data);\n      });\n\n      ffmpegProc.stderr.on('close', function() {\n        stderrRing.close();\n        stderrClosed = true;\n        handleExit();\n      });\n\n      // Call process callback\n      processCB(ffmpegProc, stdoutRing, stderrRing);\n    });\n  };\n\n\n  /**\n   * Build the argument list for an ffmpeg command\n   *\n   * @method FfmpegCommand#_getArguments\n   * @return argument list\n   * @private\n   */\n  proto._getArguments = function() {\n    var complexFilters = this._complexFilters.get();\n\n    var fileOutput = this._outputs.some(function(output) {\n      return output.isFile;\n    });\n\n    return [].concat(\n        // Inputs and input options\n        this._inputs.reduce(function(args, input) {\n          var source = (typeof input.source === 'string') ? input.source : 'pipe:0';\n\n          // For each input, add input options, then '-i <source>'\n          return args.concat(\n            input.options.get(),\n            ['-i', source]\n          );\n        }, []),\n\n        // Global options\n        this._global.get(),\n\n        // Overwrite if we have file outputs\n        fileOutput ? ['-y'] : [],\n\n        // Complex filters\n        complexFilters,\n\n        // Outputs, filters and output options\n        this._outputs.reduce(function(args, output) {\n          var sizeFilters = utils.makeFilterStrings(output.sizeFilters.get());\n          var audioFilters = output.audioFilters.get();\n          var videoFilters = output.videoFilters.get().concat(sizeFilters);\n          var outputArg;\n\n          if (!output.target) {\n            outputArg = [];\n          } else if (typeof output.target === 'string') {\n            outputArg = [output.target];\n          } else {\n            outputArg = ['pipe:1'];\n          }\n\n          return args.concat(\n            output.audio.get(),\n            audioFilters.length ? ['-filter:a', audioFilters.join(',')] : [],\n            output.video.get(),\n            videoFilters.length ? ['-filter:v', videoFilters.join(',')] : [],\n            output.options.get(),\n            outputArg\n          );\n        }, [])\n      );\n  };\n\n\n  /**\n   * Prepare execution of an ffmpeg command\n   *\n   * Checks prerequisites for the execution of the command (codec/format availability, flvtool...),\n   * then builds the argument list for ffmpeg and pass them to 'callback'.\n   *\n   * @method FfmpegCommand#_prepare\n   * @param {Function} callback callback with signature (err, args)\n   * @param {Boolean} [readMetadata=false] read metadata before processing\n   * @private\n   */\n  proto._prepare = function(callback, readMetadata) {\n    var self = this;\n\n    async.waterfall([\n      // Check codecs and formats\n      function(cb) {\n        self._checkCapabilities(cb);\n      },\n\n      // Read metadata if required\n      function(cb) {\n        if (!readMetadata) {\n          return cb();\n        }\n\n        self.ffprobe(0, function(err, data) {\n          if (!err) {\n            self._ffprobeData = data;\n          }\n\n          cb();\n        });\n      },\n\n      // Check for flvtool2/flvmeta if necessary\n      function(cb) {\n        var flvmeta = self._outputs.some(function(output) {\n          // Remove flvmeta flag on non-file output\n          if (output.flags.flvmeta && !output.isFile) {\n            self.logger.warn('Updating flv metadata is only supported for files');\n            output.flags.flvmeta = false;\n          }\n\n          return output.flags.flvmeta;\n        });\n\n        if (flvmeta) {\n          self._getFlvtoolPath(function(err) {\n            cb(err);\n          });\n        } else {\n          cb();\n        }\n      },\n\n      // Build argument list\n      function(cb) {\n        var args;\n        try {\n          args = self._getArguments();\n        } catch(e) {\n          return cb(e);\n        }\n\n        cb(null, args);\n      },\n\n      // Add \"-strict experimental\" option where needed\n      function(args, cb) {\n        self.availableEncoders(function(err, encoders) {\n          for (var i = 0; i < args.length; i++) {\n            if (args[i] === '-acodec' || args[i] === '-vcodec') {\n              i++;\n\n              if ((args[i] in encoders) && encoders[args[i]].experimental) {\n                args.splice(i + 1, 0, '-strict', 'experimental');\n                i += 2;\n              }\n            }\n          }\n\n          cb(null, args);\n        });\n      }\n    ], callback);\n\n    if (!readMetadata) {\n      // Read metadata as soon as 'progress' listeners are added\n\n      if (this.listeners('progress').length > 0) {\n        // Read metadata in parallel\n        runFfprobe(this);\n      } else {\n        // Read metadata as soon as the first 'progress' listener is added\n        this.once('newListener', function(event) {\n          if (event === 'progress') {\n            runFfprobe(this);\n          }\n        });\n      }\n    }\n  };\n\n\n  /**\n   * Run ffmpeg command\n   *\n   * @method FfmpegCommand#run\n   * @category Processing\n   * @aliases exec,execute\n   */\n  proto.exec =\n  proto.execute =\n  proto.run = function() {\n    var self = this;\n\n    // Check if at least one output is present\n    var outputPresent = this._outputs.some(function(output) {\n      return 'target' in output;\n    });\n\n    if (!outputPresent) {\n      throw new Error('No output specified');\n    }\n\n    // Get output stream if any\n    var outputStream = this._outputs.filter(function(output) {\n      return typeof output.target !== 'string';\n    })[0];\n\n    // Get input stream if any\n    var inputStream = this._inputs.filter(function(input) {\n      return typeof input.source !== 'string';\n    })[0];\n\n    // Ensure we send 'end' or 'error' only once\n    var ended = false;\n    function emitEnd(err, stdout, stderr) {\n      if (!ended) {\n        ended = true;\n\n        if (err) {\n          self.emit('error', err, stdout, stderr);\n        } else {\n          self.emit('end', stdout, stderr);\n        }\n      }\n    }\n\n    self._prepare(function(err, args) {\n      if (err) {\n        return emitEnd(err);\n      }\n\n      // Run ffmpeg\n      self._spawnFfmpeg(\n        args,\n        {\n          captureStdout: !outputStream,\n          niceness: self.options.niceness,\n          cwd: self.options.cwd,\n          windowsHide: true\n        }, \n\n        function processCB(ffmpegProc, stdoutRing, stderrRing) {\n          self.ffmpegProc = ffmpegProc;\n          self.emit('start', 'ffmpeg ' + args.join(' '));\n\n          // Pipe input stream if any\n          if (inputStream) {\n            inputStream.source.on('error', function(err) {\n              var reportingErr = new Error('Input stream error: ' + err.message);\n              reportingErr.inputStreamError = err;\n              emitEnd(reportingErr);\n              ffmpegProc.kill();\n            });\n\n            inputStream.source.resume();\n            inputStream.source.pipe(ffmpegProc.stdin);\n\n            // Set stdin error handler on ffmpeg (prevents nodejs catching the error, but\n            // ffmpeg will fail anyway, so no need to actually handle anything)\n            ffmpegProc.stdin.on('error', function() {});\n          }\n\n          // Setup timeout if requested\n          if (self.options.timeout) {\n            self.processTimer = setTimeout(function() {\n              var msg = 'process ran into a timeout (' + self.options.timeout + 's)';\n\n              emitEnd(new Error(msg), stdoutRing.get(), stderrRing.get());\n              ffmpegProc.kill();\n            }, self.options.timeout * 1000);\n          }\n\n\n          if (outputStream) {\n            // Pipe ffmpeg stdout to output stream\n            ffmpegProc.stdout.pipe(outputStream.target, outputStream.pipeopts);\n\n            // Handle output stream events\n            outputStream.target.on('close', function() {\n              self.logger.debug('Output stream closed, scheduling kill for ffmpeg process');\n\n              // Don't kill process yet, to give a chance to ffmpeg to\n              // terminate successfully first  This is necessary because\n              // under load, the process 'exit' event sometimes happens\n              // after the output stream 'close' event.\n              setTimeout(function() {\n                emitEnd(new Error('Output stream closed'));\n                ffmpegProc.kill();\n              }, 20);\n            });\n\n            outputStream.target.on('error', function(err) {\n              self.logger.debug('Output stream error, killing ffmpeg process');\n              var reportingErr = new Error('Output stream error: ' + err.message);\n              reportingErr.outputStreamError = err;\n              emitEnd(reportingErr, stdoutRing.get(), stderrRing.get());\n              ffmpegProc.kill('SIGKILL');\n            });\n          }\n\n          // Setup stderr handling\n          if (stderrRing) {\n\n            // 'stderr' event\n            if (self.listeners('stderr').length) {\n              stderrRing.callback(function(line) {\n                self.emit('stderr', line);\n              });\n            }\n\n            // 'codecData' event\n            if (self.listeners('codecData').length) {\n              var codecDataSent = false;\n              var codecObject = {};\n\n              stderrRing.callback(function(line) {\n                if (!codecDataSent)\n                  codecDataSent = utils.extractCodecData(self, line, codecObject);\n              });\n            }\n\n            // 'progress' event\n            if (self.listeners('progress').length) {\n              stderrRing.callback(function(line) {\n                utils.extractProgress(self, line);\n              });\n            }\n          }\n        },\n\n        function endCB(err, stdoutRing, stderrRing) {\n          clearTimeout(self.processTimer);\n          delete self.ffmpegProc;\n\n          if (err) {\n            if (err.message.match(/ffmpeg exited with code/)) {\n              // Add ffmpeg error message\n              err.message += ': ' + utils.extractError(stderrRing.get());\n            }\n\n            emitEnd(err, stdoutRing.get(), stderrRing.get());\n          } else {\n            // Find out which outputs need flv metadata\n            var flvmeta = self._outputs.filter(function(output) {\n              return output.flags.flvmeta;\n            });\n\n            if (flvmeta.length) {\n              self._getFlvtoolPath(function(err, flvtool) {\n                if (err) {\n                  return emitEnd(err);\n                }\n\n                async.each(\n                  flvmeta,\n                  function(output, cb) {\n                    spawn(flvtool, ['-U', output.target], {windowsHide: true})\n                      .on('error', function(err) {\n                        cb(new Error('Error running ' + flvtool + ' on ' + output.target + ': ' + err.message));\n                      })\n                      .on('exit', function(code, signal) {\n                        if (code !== 0 || signal) {\n                          cb(\n                            new Error(flvtool + ' ' +\n                              (signal ? 'received signal ' + signal\n                                      : 'exited with code ' + code)) +\n                              ' when running on ' + output.target\n                          );\n                        } else {\n                          cb();\n                        }\n                      });\n                  },\n                  function(err) {\n                    if (err) {\n                      emitEnd(err);\n                    } else {\n                      emitEnd(null, stdoutRing.get(), stderrRing.get());\n                    }\n                  }\n                );\n              });\n            } else {\n              emitEnd(null, stdoutRing.get(), stderrRing.get());\n            }\n          }\n        }\n      );\n    });\n\n    return this;\n  };\n\n\n  /**\n   * Renice current and/or future ffmpeg processes\n   *\n   * Ignored on Windows platforms.\n   *\n   * @method FfmpegCommand#renice\n   * @category Processing\n   *\n   * @param {Number} [niceness=0] niceness value between -20 (highest priority) and 20 (lowest priority)\n   * @return FfmpegCommand\n   */\n  proto.renice = function(niceness) {\n    if (!utils.isWindows) {\n      niceness = niceness || 0;\n\n      if (niceness < -20 || niceness > 20) {\n        this.logger.warn('Invalid niceness value: ' + niceness + ', must be between -20 and 20');\n      }\n\n      niceness = Math.min(20, Math.max(-20, niceness));\n      this.options.niceness = niceness;\n\n      if (this.ffmpegProc) {\n        var logger = this.logger;\n        var pid = this.ffmpegProc.pid;\n        var renice = spawn('renice', [niceness, '-p', pid], {windowsHide: true});\n\n        renice.on('error', function(err) {\n          logger.warn('could not renice process ' + pid + ': ' + err.message);\n        });\n\n        renice.on('exit', function(code, signal) {\n          if (signal) {\n            logger.warn('could not renice process ' + pid + ': renice was killed by signal ' + signal);\n          } else if (code) {\n            logger.warn('could not renice process ' + pid + ': renice exited with ' + code);\n          } else {\n            logger.info('successfully reniced process ' + pid + ' to ' + niceness + ' niceness');\n          }\n        });\n      }\n    }\n\n    return this;\n  };\n\n\n  /**\n   * Kill current ffmpeg process, if any\n   *\n   * @method FfmpegCommand#kill\n   * @category Processing\n   *\n   * @param {String} [signal=SIGKILL] signal name\n   * @return FfmpegCommand\n   */\n  proto.kill = function(signal) {\n    if (!this.ffmpegProc) {\n      this.logger.warn('No running ffmpeg process, cannot send signal');\n    } else {\n      this.ffmpegProc.kill(signal || 'SIGKILL');\n    }\n\n    return this;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvcHJvY2Vzc29yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIsWUFBWSxpRUFBOEI7QUFDMUMsV0FBVyxtQkFBTyxDQUFDLHVCQUFNO0FBQ3pCLFNBQVMsbUJBQU8sQ0FBQyxjQUFJO0FBQ3JCLFlBQVksbUJBQU8sQ0FBQyxzREFBTztBQUMzQixZQUFZLG1CQUFPLENBQUMsZ0VBQVM7O0FBRTdCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsYUFBYTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsYUFBYTtBQUMxQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGtCQUFrQjtBQUM3RTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGtCQUFrQjs7QUFFL0U7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1maXJlYmFzZS1hcGkvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvcHJvY2Vzc29yLmpzPzAzNTAiXSwic291cmNlc0NvbnRlbnQiOlsiLypqc2hpbnQgbm9kZTp0cnVlKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHNwYXduID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLnNwYXduO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLypcbiAqISBQcm9jZXNzb3IgbWV0aG9kc1xuICovXG5cblxuLyoqXG4gKiBSdW4gZmZwcm9iZSBhc3luY2hyb25vdXNseSBhbmQgc3RvcmUgZGF0YSBpbiBjb21tYW5kXG4gKlxuICogQHBhcmFtIHtGZm1wZWdDb21tYW5kfSBjb21tYW5kXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5GZnByb2JlKGNvbW1hbmQpIHtcbiAgY29uc3QgaW5wdXRQcm9iZUluZGV4ID0gMDtcbiAgaWYgKGNvbW1hbmQuX2lucHV0c1tpbnB1dFByb2JlSW5kZXhdLmlzU3RyZWFtKSB7XG4gICAgLy8gRG9uJ3QgcHJvYmUgaW5wdXQgc3RyZWFtcyBhcyB0aGlzIHdpbGwgY29uc3VtZSB0aGVtXG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbW1hbmQuZmZwcm9iZShpbnB1dFByb2JlSW5kZXgsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgIGNvbW1hbmQuX2ZmcHJvYmVEYXRhID0gZGF0YTtcbiAgfSk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwcm90bykge1xuICAvKipcbiAgICogRW1pdHRlZCBqdXN0IGFmdGVyIGZmbXBlZyBoYXMgYmVlbiBzcGF3bmVkLlxuICAgKlxuICAgKiBAZXZlbnQgRmZtcGVnQ29tbWFuZCNzdGFydFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29tbWFuZCBmZm1wZWcgY29tbWFuZCBsaW5lXG4gICAqL1xuXG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gZmZtcGVnIHJlcG9ydHMgcHJvZ3Jlc3MgaW5mb3JtYXRpb25cbiAgICpcbiAgICogQGV2ZW50IEZmbXBlZ0NvbW1hbmQjcHJvZ3Jlc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb2dyZXNzIHByb2dyZXNzIG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gcHJvZ3Jlc3MuZnJhbWVzIG51bWJlciBvZiBmcmFtZXMgdHJhbnNjb2RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gcHJvZ3Jlc3MuY3VycmVudEZwcyBjdXJyZW50IHByb2Nlc3Npbmcgc3BlZWQgaW4gZnJhbWVzIHBlciBzZWNvbmRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHByb2dyZXNzLmN1cnJlbnRLYnBzIGN1cnJlbnQgb3V0cHV0IGdlbmVyYXRpb24gc3BlZWQgaW4ga2lsb2J5dGVzIHBlciBzZWNvbmRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHByb2dyZXNzLnRhcmdldFNpemUgY3VycmVudCBvdXRwdXQgZmlsZSBzaXplXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9ncmVzcy50aW1lbWFyayBjdXJyZW50IHZpZGVvIHRpbWVtYXJrXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcHJvZ3Jlc3MucGVyY2VudF0gcHJvY2Vzc2luZyBwcm9ncmVzcyAobWF5IG5vdCBiZSBhdmFpbGFibGUgZGVwZW5kaW5nIG9uIGlucHV0KVxuICAgKi9cblxuICAvKipcbiAgICogRW1pdHRlZCB3aGVuIGZmbXBlZyBvdXRwdXRzIHRvIHN0ZGVyclxuICAgKlxuICAgKiBAZXZlbnQgRmZtcGVnQ29tbWFuZCNzdGRlcnJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmUgc3RkZXJyIG91dHB1dCBsaW5lXG4gICAqL1xuXG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gZmZtcGVnIHJlcG9ydHMgaW5wdXQgY29kZWMgZGF0YVxuICAgKlxuICAgKiBAZXZlbnQgRmZtcGVnQ29tbWFuZCNjb2RlY0RhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvZGVjRGF0YSBjb2RlYyBkYXRhIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29kZWNEYXRhLmZvcm1hdCBpbnB1dCBmb3JtYXQgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29kZWNEYXRhLmF1ZGlvIGlucHV0IGF1ZGlvIGNvZGVjIG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvZGVjRGF0YS5hdWRpb19kZXRhaWxzIGlucHV0IGF1ZGlvIGNvZGVjIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvZGVjRGF0YS52aWRlbyBpbnB1dCB2aWRlbyBjb2RlYyBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2RlY0RhdGEudmlkZW9fZGV0YWlscyBpbnB1dCB2aWRlbyBjb2RlYyBwYXJhbWV0ZXJzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gYW4gZXJyb3IgaGFwcGVucyB3aGVuIHByZXBhcmluZyBvciBydW5uaW5nIGEgY29tbWFuZFxuICAgKlxuICAgKiBAZXZlbnQgRmZtcGVnQ29tbWFuZCNlcnJvclxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBlcnJvciBvYmplY3QsIHdpdGggb3B0aW9uYWwgcHJvcGVydGllcyAnaW5wdXRTdHJlYW1FcnJvcicgLyAnb3V0cHV0U3RyZWFtRXJyb3InIGZvciBlcnJvcnMgb24gdGhlaXIgcmVzcGVjdGl2ZSBzdHJlYW1zXG4gICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHN0ZG91dCBmZm1wZWcgc3Rkb3V0LCB1bmxlc3Mgb3V0cHV0dGluZyB0byBhIHN0cmVhbVxuICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBzdGRlcnIgZmZtcGVnIHN0ZGVyclxuICAgKi9cblxuICAvKipcbiAgICogRW1pdHRlZCB3aGVuIGEgY29tbWFuZCBmaW5pc2hlcyBwcm9jZXNzaW5nXG4gICAqXG4gICAqIEBldmVudCBGZm1wZWdDb21tYW5kI2VuZFxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xudWxsfSBbZmlsZW5hbWVzfHN0ZG91dF0gZ2VuZXJhdGVkIGZpbGVuYW1lcyB3aGVuIHRha2luZyBzY3JlZW5zaG90cywgZmZtcGVnIHN0ZG91dCB3aGVuIG5vdCBvdXRwdXR0aW5nIHRvIGEgc3RyZWFtLCBudWxsIG90aGVyd2lzZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBzdGRlcnIgZmZtcGVnIHN0ZGVyclxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBTcGF3biBhbiBmZm1wZWcgcHJvY2Vzc1xuICAgKlxuICAgKiBUaGUgJ29wdGlvbnMnIGFyZ3VtZW50IG1heSBjb250YWluIHRoZSBmb2xsb3dpbmcga2V5czpcbiAgICogLSAnbmljZW5lc3MnOiBzcGVjaWZ5IHByb2Nlc3MgbmljZW5lc3MsIGlnbm9yZWQgb24gV2luZG93cyAoZGVmYXVsdDogMClcbiAgICogLSBgY3dkYDogY2hhbmdlIHdvcmtpbmcgZGlyZWN0b3J5XG4gICAqIC0gJ2NhcHR1cmVTdGRvdXQnOiBjYXB0dXJlIHN0ZG91dCBhbmQgcGFzcyBpdCB0byAnZW5kQ0InIGFzIGl0cyAybmQgYXJndW1lbnQgKGRlZmF1bHQ6IGZhbHNlKVxuICAgKiAtICdzdGRvdXRMaW5lcyc6IG92ZXJyaWRlIGNvbW1hbmQgbGltaXQgKGRlZmF1bHQ6IHVzZSBjb21tYW5kIGxpbWl0KVxuICAgKlxuICAgKiBUaGUgJ3Byb2Nlc3NDQicgY2FsbGJhY2ssIGlmIHByZXNlbnQsIGlzIGNhbGxlZCBhcyBzb29uIGFzIHRoZSBwcm9jZXNzIGlzIGNyZWF0ZWQgYW5kXG4gICAqIHJlY2VpdmVzIGEgbm9kZWpzIENoaWxkUHJvY2VzcyBvYmplY3QuICBJdCBtYXkgbm90IGJlIGNhbGxlZCBhdCBhbGwgaWYgYW4gZXJyb3IgaGFwcGVuc1xuICAgKiBiZWZvcmUgc3Bhd25pbmcgdGhlIHByb2Nlc3MuXG4gICAqXG4gICAqIFRoZSAnZW5kQ0InIGNhbGxiYWNrIGlzIGNhbGxlZCBlaXRoZXIgd2hlbiBhbiBlcnJvciBvY2N1cnMgb3Igd2hlbiB0aGUgZmZtcGVnIHByb2Nlc3MgZmluaXNoZXMuXG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNfc3Bhd25GZm1wZWdcbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyBmZm1wZWcgY29tbWFuZCBsaW5lIGFyZ3VtZW50IGxpc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBzcGF3biBvcHRpb25zIChzZWUgYWJvdmUpXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9jZXNzQ0JdIGNhbGxiYWNrIGNhbGxlZCB3aXRoIHByb2Nlc3Mgb2JqZWN0IGFuZCBzdGRvdXQvc3RkZXJyIHJpbmcgYnVmZmVycyB3aGVuIHByb2Nlc3MgaGFzIGJlZW4gY3JlYXRlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmRDQiBjYWxsYmFjayBjYWxsZWQgd2l0aCBlcnJvciAoaWYgYXBwbGljYWJsZSkgYW5kIHN0ZG91dC9zdGRlcnIgcmluZyBidWZmZXJzIHdoZW4gcHJvY2VzcyBmaW5pc2hlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdG8uX3NwYXduRmZtcGVnID0gZnVuY3Rpb24oYXJncywgb3B0aW9ucywgcHJvY2Vzc0NCLCBlbmRDQikge1xuICAgIC8vIEVuYWJsZSBvbWl0dGluZyBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlbmRDQiA9IHByb2Nlc3NDQjtcbiAgICAgIHByb2Nlc3NDQiA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgLy8gRW5hYmxlIG9taXR0aW5nIHByb2Nlc3NDQlxuICAgIGlmICh0eXBlb2YgZW5kQ0IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmRDQiA9IHByb2Nlc3NDQjtcbiAgICAgIHByb2Nlc3NDQiA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuXG4gICAgdmFyIG1heExpbmVzID0gJ3N0ZG91dExpbmVzJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGRvdXRMaW5lcyA6IHRoaXMub3B0aW9ucy5zdGRvdXRMaW5lcztcblxuICAgIC8vIEZpbmQgZmZtcGVnXG4gICAgdGhpcy5fZ2V0RmZtcGVnUGF0aChmdW5jdGlvbihlcnIsIGNvbW1hbmQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGVuZENCKGVycik7XG4gICAgICB9IGVsc2UgaWYgKCFjb21tYW5kIHx8IGNvbW1hbmQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBlbmRDQihuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGZmbXBlZycpKTtcbiAgICAgIH1cblxuICAgICAgLy8gQXBwbHkgbmljZW5lc3NcbiAgICAgIGlmIChvcHRpb25zLm5pY2VuZXNzICYmIG9wdGlvbnMubmljZW5lc3MgIT09IDAgJiYgIXV0aWxzLmlzV2luZG93cykge1xuICAgICAgICBhcmdzLnVuc2hpZnQoJy1uJywgb3B0aW9ucy5uaWNlbmVzcywgY29tbWFuZCk7XG4gICAgICAgIGNvbW1hbmQgPSAnbmljZSc7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGRvdXRSaW5nID0gdXRpbHMubGluZXNSaW5nKG1heExpbmVzKTtcbiAgICAgIHZhciBzdGRvdXRDbG9zZWQgPSBmYWxzZTtcblxuICAgICAgdmFyIHN0ZGVyclJpbmcgPSB1dGlscy5saW5lc1JpbmcobWF4TGluZXMpO1xuICAgICAgdmFyIHN0ZGVyckNsb3NlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBTcGF3biBwcm9jZXNzXG4gICAgICB2YXIgZmZtcGVnUHJvYyA9IHNwYXduKGNvbW1hbmQsIGFyZ3MsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoZmZtcGVnUHJvYy5zdGRlcnIpIHtcbiAgICAgICAgZmZtcGVnUHJvYy5zdGRlcnIuc2V0RW5jb2RpbmcoJ3V0ZjgnKTtcbiAgICAgIH1cblxuICAgICAgZmZtcGVnUHJvYy5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgZW5kQ0IoZXJyKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFbnN1cmUgd2Ugd2FpdCBmb3IgY2FwdHVyZWQgc3RyZWFtcyB0byBlbmQgYmVmb3JlIGNhbGxpbmcgZW5kQ0JcbiAgICAgIHZhciBleGl0RXJyb3IgPSBudWxsO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlRXhpdChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGV4aXRFcnJvciA9IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9jZXNzRXhpdGVkICYmIChzdGRvdXRDbG9zZWQgfHwgIW9wdGlvbnMuY2FwdHVyZVN0ZG91dCkgJiYgc3RkZXJyQ2xvc2VkKSB7XG4gICAgICAgICAgZW5kQ0IoZXhpdEVycm9yLCBzdGRvdXRSaW5nLCBzdGRlcnJSaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgcHJvY2VzcyBleGl0XG4gICAgICB2YXIgcHJvY2Vzc0V4aXRlZCA9IGZhbHNlO1xuICAgICAgZmZtcGVnUHJvYy5vbignZXhpdCcsIGZ1bmN0aW9uKGNvZGUsIHNpZ25hbCkge1xuICAgICAgICBwcm9jZXNzRXhpdGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgaGFuZGxlRXhpdChuZXcgRXJyb3IoJ2ZmbXBlZyB3YXMga2lsbGVkIHdpdGggc2lnbmFsICcgKyBzaWduYWwpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlKSB7XG4gICAgICAgICAgaGFuZGxlRXhpdChuZXcgRXJyb3IoJ2ZmbXBlZyBleGl0ZWQgd2l0aCBjb2RlICcgKyBjb2RlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlRXhpdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ2FwdHVyZSBzdGRvdXQgaWYgc3BlY2lmaWVkXG4gICAgICBpZiAob3B0aW9ucy5jYXB0dXJlU3Rkb3V0KSB7XG4gICAgICAgIGZmbXBlZ1Byb2Muc3Rkb3V0Lm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgIHN0ZG91dFJpbmcuYXBwZW5kKGRhdGEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmZm1wZWdQcm9jLnN0ZG91dC5vbignY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzdGRvdXRSaW5nLmNsb3NlKCk7XG4gICAgICAgICAgc3Rkb3V0Q2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICBoYW5kbGVFeGl0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBDYXB0dXJlIHN0ZGVyciBpZiBzcGVjaWZpZWRcbiAgICAgIGZmbXBlZ1Byb2Muc3RkZXJyLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBzdGRlcnJSaW5nLmFwcGVuZChkYXRhKTtcbiAgICAgIH0pO1xuXG4gICAgICBmZm1wZWdQcm9jLnN0ZGVyci5vbignY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RkZXJyUmluZy5jbG9zZSgpO1xuICAgICAgICBzdGRlcnJDbG9zZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVFeGl0KCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQ2FsbCBwcm9jZXNzIGNhbGxiYWNrXG4gICAgICBwcm9jZXNzQ0IoZmZtcGVnUHJvYywgc3Rkb3V0UmluZywgc3RkZXJyUmluZyk7XG4gICAgfSk7XG4gIH07XG5cblxuICAvKipcbiAgICogQnVpbGQgdGhlIGFyZ3VtZW50IGxpc3QgZm9yIGFuIGZmbXBlZyBjb21tYW5kXG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNfZ2V0QXJndW1lbnRzXG4gICAqIEByZXR1cm4gYXJndW1lbnQgbGlzdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdG8uX2dldEFyZ3VtZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb21wbGV4RmlsdGVycyA9IHRoaXMuX2NvbXBsZXhGaWx0ZXJzLmdldCgpO1xuXG4gICAgdmFyIGZpbGVPdXRwdXQgPSB0aGlzLl9vdXRwdXRzLnNvbWUoZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICByZXR1cm4gb3V0cHV0LmlzRmlsZTtcbiAgICB9KTtcblxuICAgIHJldHVybiBbXS5jb25jYXQoXG4gICAgICAgIC8vIElucHV0cyBhbmQgaW5wdXQgb3B0aW9uc1xuICAgICAgICB0aGlzLl9pbnB1dHMucmVkdWNlKGZ1bmN0aW9uKGFyZ3MsIGlucHV0KSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9ICh0eXBlb2YgaW5wdXQuc291cmNlID09PSAnc3RyaW5nJykgPyBpbnB1dC5zb3VyY2UgOiAncGlwZTowJztcblxuICAgICAgICAgIC8vIEZvciBlYWNoIGlucHV0LCBhZGQgaW5wdXQgb3B0aW9ucywgdGhlbiAnLWkgPHNvdXJjZT4nXG4gICAgICAgICAgcmV0dXJuIGFyZ3MuY29uY2F0KFxuICAgICAgICAgICAgaW5wdXQub3B0aW9ucy5nZXQoKSxcbiAgICAgICAgICAgIFsnLWknLCBzb3VyY2VdXG4gICAgICAgICAgKTtcbiAgICAgICAgfSwgW10pLFxuXG4gICAgICAgIC8vIEdsb2JhbCBvcHRpb25zXG4gICAgICAgIHRoaXMuX2dsb2JhbC5nZXQoKSxcblxuICAgICAgICAvLyBPdmVyd3JpdGUgaWYgd2UgaGF2ZSBmaWxlIG91dHB1dHNcbiAgICAgICAgZmlsZU91dHB1dCA/IFsnLXknXSA6IFtdLFxuXG4gICAgICAgIC8vIENvbXBsZXggZmlsdGVyc1xuICAgICAgICBjb21wbGV4RmlsdGVycyxcblxuICAgICAgICAvLyBPdXRwdXRzLCBmaWx0ZXJzIGFuZCBvdXRwdXQgb3B0aW9uc1xuICAgICAgICB0aGlzLl9vdXRwdXRzLnJlZHVjZShmdW5jdGlvbihhcmdzLCBvdXRwdXQpIHtcbiAgICAgICAgICB2YXIgc2l6ZUZpbHRlcnMgPSB1dGlscy5tYWtlRmlsdGVyU3RyaW5ncyhvdXRwdXQuc2l6ZUZpbHRlcnMuZ2V0KCkpO1xuICAgICAgICAgIHZhciBhdWRpb0ZpbHRlcnMgPSBvdXRwdXQuYXVkaW9GaWx0ZXJzLmdldCgpO1xuICAgICAgICAgIHZhciB2aWRlb0ZpbHRlcnMgPSBvdXRwdXQudmlkZW9GaWx0ZXJzLmdldCgpLmNvbmNhdChzaXplRmlsdGVycyk7XG4gICAgICAgICAgdmFyIG91dHB1dEFyZztcblxuICAgICAgICAgIGlmICghb3V0cHV0LnRhcmdldCkge1xuICAgICAgICAgICAgb3V0cHV0QXJnID0gW107XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3V0cHV0LnRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG91dHB1dEFyZyA9IFtvdXRwdXQudGFyZ2V0XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0QXJnID0gWydwaXBlOjEnXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYXJncy5jb25jYXQoXG4gICAgICAgICAgICBvdXRwdXQuYXVkaW8uZ2V0KCksXG4gICAgICAgICAgICBhdWRpb0ZpbHRlcnMubGVuZ3RoID8gWyctZmlsdGVyOmEnLCBhdWRpb0ZpbHRlcnMuam9pbignLCcpXSA6IFtdLFxuICAgICAgICAgICAgb3V0cHV0LnZpZGVvLmdldCgpLFxuICAgICAgICAgICAgdmlkZW9GaWx0ZXJzLmxlbmd0aCA/IFsnLWZpbHRlcjp2JywgdmlkZW9GaWx0ZXJzLmpvaW4oJywnKV0gOiBbXSxcbiAgICAgICAgICAgIG91dHB1dC5vcHRpb25zLmdldCgpLFxuICAgICAgICAgICAgb3V0cHV0QXJnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSwgW10pXG4gICAgICApO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFByZXBhcmUgZXhlY3V0aW9uIG9mIGFuIGZmbXBlZyBjb21tYW5kXG4gICAqXG4gICAqIENoZWNrcyBwcmVyZXF1aXNpdGVzIGZvciB0aGUgZXhlY3V0aW9uIG9mIHRoZSBjb21tYW5kIChjb2RlYy9mb3JtYXQgYXZhaWxhYmlsaXR5LCBmbHZ0b29sLi4uKSxcbiAgICogdGhlbiBidWlsZHMgdGhlIGFyZ3VtZW50IGxpc3QgZm9yIGZmbXBlZyBhbmQgcGFzcyB0aGVtIHRvICdjYWxsYmFjaycuXG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNfcHJlcGFyZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayB3aXRoIHNpZ25hdHVyZSAoZXJyLCBhcmdzKVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWFkTWV0YWRhdGE9ZmFsc2VdIHJlYWQgbWV0YWRhdGEgYmVmb3JlIHByb2Nlc3NpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RvLl9wcmVwYXJlID0gZnVuY3Rpb24oY2FsbGJhY2ssIHJlYWRNZXRhZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGFzeW5jLndhdGVyZmFsbChbXG4gICAgICAvLyBDaGVjayBjb2RlY3MgYW5kIGZvcm1hdHNcbiAgICAgIGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIHNlbGYuX2NoZWNrQ2FwYWJpbGl0aWVzKGNiKTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIFJlYWQgbWV0YWRhdGEgaWYgcmVxdWlyZWRcbiAgICAgIGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIGlmICghcmVhZE1ldGFkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmZmcHJvYmUoMCwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgIHNlbGYuX2ZmcHJvYmVEYXRhID0gZGF0YTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYigpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIENoZWNrIGZvciBmbHZ0b29sMi9mbHZtZXRhIGlmIG5lY2Vzc2FyeVxuICAgICAgZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgdmFyIGZsdm1ldGEgPSBzZWxmLl9vdXRwdXRzLnNvbWUoZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIGZsdm1ldGEgZmxhZyBvbiBub24tZmlsZSBvdXRwdXRcbiAgICAgICAgICBpZiAob3V0cHV0LmZsYWdzLmZsdm1ldGEgJiYgIW91dHB1dC5pc0ZpbGUpIHtcbiAgICAgICAgICAgIHNlbGYubG9nZ2VyLndhcm4oJ1VwZGF0aW5nIGZsdiBtZXRhZGF0YSBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgZmlsZXMnKTtcbiAgICAgICAgICAgIG91dHB1dC5mbGFncy5mbHZtZXRhID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG91dHB1dC5mbGFncy5mbHZtZXRhO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZmx2bWV0YSkge1xuICAgICAgICAgIHNlbGYuX2dldEZsdnRvb2xQYXRoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyBCdWlsZCBhcmd1bWVudCBsaXN0XG4gICAgICBmdW5jdGlvbihjYikge1xuICAgICAgICB2YXIgYXJncztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhcmdzID0gc2VsZi5fZ2V0QXJndW1lbnRzKCk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIHJldHVybiBjYihlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNiKG51bGwsIGFyZ3MpO1xuICAgICAgfSxcblxuICAgICAgLy8gQWRkIFwiLXN0cmljdCBleHBlcmltZW50YWxcIiBvcHRpb24gd2hlcmUgbmVlZGVkXG4gICAgICBmdW5jdGlvbihhcmdzLCBjYikge1xuICAgICAgICBzZWxmLmF2YWlsYWJsZUVuY29kZXJzKGZ1bmN0aW9uKGVyciwgZW5jb2RlcnMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcmdzW2ldID09PSAnLWFjb2RlYycgfHwgYXJnc1tpXSA9PT0gJy12Y29kZWMnKSB7XG4gICAgICAgICAgICAgIGkrKztcblxuICAgICAgICAgICAgICBpZiAoKGFyZ3NbaV0gaW4gZW5jb2RlcnMpICYmIGVuY29kZXJzW2FyZ3NbaV1dLmV4cGVyaW1lbnRhbCkge1xuICAgICAgICAgICAgICAgIGFyZ3Muc3BsaWNlKGkgKyAxLCAwLCAnLXN0cmljdCcsICdleHBlcmltZW50YWwnKTtcbiAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYihudWxsLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgXSwgY2FsbGJhY2spO1xuXG4gICAgaWYgKCFyZWFkTWV0YWRhdGEpIHtcbiAgICAgIC8vIFJlYWQgbWV0YWRhdGEgYXMgc29vbiBhcyAncHJvZ3Jlc3MnIGxpc3RlbmVycyBhcmUgYWRkZWRcblxuICAgICAgaWYgKHRoaXMubGlzdGVuZXJzKCdwcm9ncmVzcycpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gUmVhZCBtZXRhZGF0YSBpbiBwYXJhbGxlbFxuICAgICAgICBydW5GZnByb2JlKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVhZCBtZXRhZGF0YSBhcyBzb29uIGFzIHRoZSBmaXJzdCAncHJvZ3Jlc3MnIGxpc3RlbmVyIGlzIGFkZGVkXG4gICAgICAgIHRoaXMub25jZSgnbmV3TGlzdGVuZXInLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIGlmIChldmVudCA9PT0gJ3Byb2dyZXNzJykge1xuICAgICAgICAgICAgcnVuRmZwcm9iZSh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSdW4gZmZtcGVnIGNvbW1hbmRcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI3J1blxuICAgKiBAY2F0ZWdvcnkgUHJvY2Vzc2luZ1xuICAgKiBAYWxpYXNlcyBleGVjLGV4ZWN1dGVcbiAgICovXG4gIHByb3RvLmV4ZWMgPVxuICBwcm90by5leGVjdXRlID1cbiAgcHJvdG8ucnVuID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gQ2hlY2sgaWYgYXQgbGVhc3Qgb25lIG91dHB1dCBpcyBwcmVzZW50XG4gICAgdmFyIG91dHB1dFByZXNlbnQgPSB0aGlzLl9vdXRwdXRzLnNvbWUoZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICByZXR1cm4gJ3RhcmdldCcgaW4gb3V0cHV0O1xuICAgIH0pO1xuXG4gICAgaWYgKCFvdXRwdXRQcmVzZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG91dHB1dCBzcGVjaWZpZWQnKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgb3V0cHV0IHN0cmVhbSBpZiBhbnlcbiAgICB2YXIgb3V0cHV0U3RyZWFtID0gdGhpcy5fb3V0cHV0cy5maWx0ZXIoZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG91dHB1dC50YXJnZXQgIT09ICdzdHJpbmcnO1xuICAgIH0pWzBdO1xuXG4gICAgLy8gR2V0IGlucHV0IHN0cmVhbSBpZiBhbnlcbiAgICB2YXIgaW5wdXRTdHJlYW0gPSB0aGlzLl9pbnB1dHMuZmlsdGVyKGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGlucHV0LnNvdXJjZSAhPT0gJ3N0cmluZyc7XG4gICAgfSlbMF07XG5cbiAgICAvLyBFbnN1cmUgd2Ugc2VuZCAnZW5kJyBvciAnZXJyb3InIG9ubHkgb25jZVxuICAgIHZhciBlbmRlZCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIGVtaXRFbmQoZXJyLCBzdGRvdXQsIHN0ZGVycikge1xuICAgICAgaWYgKCFlbmRlZCkge1xuICAgICAgICBlbmRlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIsIHN0ZG91dCwgc3RkZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2VuZCcsIHN0ZG91dCwgc3RkZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYuX3ByZXBhcmUoZnVuY3Rpb24oZXJyLCBhcmdzKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBlbWl0RW5kKGVycik7XG4gICAgICB9XG5cbiAgICAgIC8vIFJ1biBmZm1wZWdcbiAgICAgIHNlbGYuX3NwYXduRmZtcGVnKFxuICAgICAgICBhcmdzLFxuICAgICAgICB7XG4gICAgICAgICAgY2FwdHVyZVN0ZG91dDogIW91dHB1dFN0cmVhbSxcbiAgICAgICAgICBuaWNlbmVzczogc2VsZi5vcHRpb25zLm5pY2VuZXNzLFxuICAgICAgICAgIGN3ZDogc2VsZi5vcHRpb25zLmN3ZCxcbiAgICAgICAgICB3aW5kb3dzSGlkZTogdHJ1ZVxuICAgICAgICB9LCBcblxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzQ0IoZmZtcGVnUHJvYywgc3Rkb3V0UmluZywgc3RkZXJyUmluZykge1xuICAgICAgICAgIHNlbGYuZmZtcGVnUHJvYyA9IGZmbXBlZ1Byb2M7XG4gICAgICAgICAgc2VsZi5lbWl0KCdzdGFydCcsICdmZm1wZWcgJyArIGFyZ3Muam9pbignICcpKTtcblxuICAgICAgICAgIC8vIFBpcGUgaW5wdXQgc3RyZWFtIGlmIGFueVxuICAgICAgICAgIGlmIChpbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc291cmNlLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICB2YXIgcmVwb3J0aW5nRXJyID0gbmV3IEVycm9yKCdJbnB1dCBzdHJlYW0gZXJyb3I6ICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgIHJlcG9ydGluZ0Vyci5pbnB1dFN0cmVhbUVycm9yID0gZXJyO1xuICAgICAgICAgICAgICBlbWl0RW5kKHJlcG9ydGluZ0Vycik7XG4gICAgICAgICAgICAgIGZmbXBlZ1Byb2Mua2lsbCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlucHV0U3RyZWFtLnNvdXJjZS5yZXN1bWUoKTtcbiAgICAgICAgICAgIGlucHV0U3RyZWFtLnNvdXJjZS5waXBlKGZmbXBlZ1Byb2Muc3RkaW4pO1xuXG4gICAgICAgICAgICAvLyBTZXQgc3RkaW4gZXJyb3IgaGFuZGxlciBvbiBmZm1wZWcgKHByZXZlbnRzIG5vZGVqcyBjYXRjaGluZyB0aGUgZXJyb3IsIGJ1dFxuICAgICAgICAgICAgLy8gZmZtcGVnIHdpbGwgZmFpbCBhbnl3YXksIHNvIG5vIG5lZWQgdG8gYWN0dWFsbHkgaGFuZGxlIGFueXRoaW5nKVxuICAgICAgICAgICAgZmZtcGVnUHJvYy5zdGRpbi5vbignZXJyb3InLCBmdW5jdGlvbigpIHt9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZXR1cCB0aW1lb3V0IGlmIHJlcXVlc3RlZFxuICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMudGltZW91dCkge1xuICAgICAgICAgICAgc2VsZi5wcm9jZXNzVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgbXNnID0gJ3Byb2Nlc3MgcmFuIGludG8gYSB0aW1lb3V0ICgnICsgc2VsZi5vcHRpb25zLnRpbWVvdXQgKyAncyknO1xuXG4gICAgICAgICAgICAgIGVtaXRFbmQobmV3IEVycm9yKG1zZyksIHN0ZG91dFJpbmcuZ2V0KCksIHN0ZGVyclJpbmcuZ2V0KCkpO1xuICAgICAgICAgICAgICBmZm1wZWdQcm9jLmtpbGwoKTtcbiAgICAgICAgICAgIH0sIHNlbGYub3B0aW9ucy50aW1lb3V0ICogMTAwMCk7XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgICBpZiAob3V0cHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAvLyBQaXBlIGZmbXBlZyBzdGRvdXQgdG8gb3V0cHV0IHN0cmVhbVxuICAgICAgICAgICAgZmZtcGVnUHJvYy5zdGRvdXQucGlwZShvdXRwdXRTdHJlYW0udGFyZ2V0LCBvdXRwdXRTdHJlYW0ucGlwZW9wdHMpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgb3V0cHV0IHN0cmVhbSBldmVudHNcbiAgICAgICAgICAgIG91dHB1dFN0cmVhbS50YXJnZXQub24oJ2Nsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHNlbGYubG9nZ2VyLmRlYnVnKCdPdXRwdXQgc3RyZWFtIGNsb3NlZCwgc2NoZWR1bGluZyBraWxsIGZvciBmZm1wZWcgcHJvY2VzcycpO1xuXG4gICAgICAgICAgICAgIC8vIERvbid0IGtpbGwgcHJvY2VzcyB5ZXQsIHRvIGdpdmUgYSBjaGFuY2UgdG8gZmZtcGVnIHRvXG4gICAgICAgICAgICAgIC8vIHRlcm1pbmF0ZSBzdWNjZXNzZnVsbHkgZmlyc3QgIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2VcbiAgICAgICAgICAgICAgLy8gdW5kZXIgbG9hZCwgdGhlIHByb2Nlc3MgJ2V4aXQnIGV2ZW50IHNvbWV0aW1lcyBoYXBwZW5zXG4gICAgICAgICAgICAgIC8vIGFmdGVyIHRoZSBvdXRwdXQgc3RyZWFtICdjbG9zZScgZXZlbnQuXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZW1pdEVuZChuZXcgRXJyb3IoJ091dHB1dCBzdHJlYW0gY2xvc2VkJykpO1xuICAgICAgICAgICAgICAgIGZmbXBlZ1Byb2Mua2lsbCgpO1xuICAgICAgICAgICAgICB9LCAyMCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgb3V0cHV0U3RyZWFtLnRhcmdldC5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgc2VsZi5sb2dnZXIuZGVidWcoJ091dHB1dCBzdHJlYW0gZXJyb3IsIGtpbGxpbmcgZmZtcGVnIHByb2Nlc3MnKTtcbiAgICAgICAgICAgICAgdmFyIHJlcG9ydGluZ0VyciA9IG5ldyBFcnJvcignT3V0cHV0IHN0cmVhbSBlcnJvcjogJyArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgcmVwb3J0aW5nRXJyLm91dHB1dFN0cmVhbUVycm9yID0gZXJyO1xuICAgICAgICAgICAgICBlbWl0RW5kKHJlcG9ydGluZ0Vyciwgc3Rkb3V0UmluZy5nZXQoKSwgc3RkZXJyUmluZy5nZXQoKSk7XG4gICAgICAgICAgICAgIGZmbXBlZ1Byb2Mua2lsbCgnU0lHS0lMTCcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2V0dXAgc3RkZXJyIGhhbmRsaW5nXG4gICAgICAgICAgaWYgKHN0ZGVyclJpbmcpIHtcblxuICAgICAgICAgICAgLy8gJ3N0ZGVycicgZXZlbnRcbiAgICAgICAgICAgIGlmIChzZWxmLmxpc3RlbmVycygnc3RkZXJyJykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHN0ZGVyclJpbmcuY2FsbGJhY2soZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZW1pdCgnc3RkZXJyJywgbGluZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAnY29kZWNEYXRhJyBldmVudFxuICAgICAgICAgICAgaWYgKHNlbGYubGlzdGVuZXJzKCdjb2RlY0RhdGEnKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIGNvZGVjRGF0YVNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdmFyIGNvZGVjT2JqZWN0ID0ge307XG5cbiAgICAgICAgICAgICAgc3RkZXJyUmluZy5jYWxsYmFjayhmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb2RlY0RhdGFTZW50KVxuICAgICAgICAgICAgICAgICAgY29kZWNEYXRhU2VudCA9IHV0aWxzLmV4dHJhY3RDb2RlY0RhdGEoc2VsZiwgbGluZSwgY29kZWNPYmplY3QpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gJ3Byb2dyZXNzJyBldmVudFxuICAgICAgICAgICAgaWYgKHNlbGYubGlzdGVuZXJzKCdwcm9ncmVzcycpLmxlbmd0aCkge1xuICAgICAgICAgICAgICBzdGRlcnJSaW5nLmNhbGxiYWNrKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICB1dGlscy5leHRyYWN0UHJvZ3Jlc3Moc2VsZiwgbGluZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvbiBlbmRDQihlcnIsIHN0ZG91dFJpbmcsIHN0ZGVyclJpbmcpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5wcm9jZXNzVGltZXIpO1xuICAgICAgICAgIGRlbGV0ZSBzZWxmLmZmbXBlZ1Byb2M7XG5cbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyLm1lc3NhZ2UubWF0Y2goL2ZmbXBlZyBleGl0ZWQgd2l0aCBjb2RlLykpIHtcbiAgICAgICAgICAgICAgLy8gQWRkIGZmbXBlZyBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgIGVyci5tZXNzYWdlICs9ICc6ICcgKyB1dGlscy5leHRyYWN0RXJyb3Ioc3RkZXJyUmluZy5nZXQoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVtaXRFbmQoZXJyLCBzdGRvdXRSaW5nLmdldCgpLCBzdGRlcnJSaW5nLmdldCgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmluZCBvdXQgd2hpY2ggb3V0cHV0cyBuZWVkIGZsdiBtZXRhZGF0YVxuICAgICAgICAgICAgdmFyIGZsdm1ldGEgPSBzZWxmLl9vdXRwdXRzLmZpbHRlcihmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5mbGFncy5mbHZtZXRhO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChmbHZtZXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICBzZWxmLl9nZXRGbHZ0b29sUGF0aChmdW5jdGlvbihlcnIsIGZsdnRvb2wpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZW1pdEVuZChlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFzeW5jLmVhY2goXG4gICAgICAgICAgICAgICAgICBmbHZtZXRhLFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24ob3V0cHV0LCBjYikge1xuICAgICAgICAgICAgICAgICAgICBzcGF3bihmbHZ0b29sLCBbJy1VJywgb3V0cHV0LnRhcmdldF0sIHt3aW5kb3dzSGlkZTogdHJ1ZX0pXG4gICAgICAgICAgICAgICAgICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IobmV3IEVycm9yKCdFcnJvciBydW5uaW5nICcgKyBmbHZ0b29sICsgJyBvbiAnICsgb3V0cHV0LnRhcmdldCArICc6ICcgKyBlcnIubWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgLm9uKCdleGl0JywgZnVuY3Rpb24oY29kZSwgc2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gMCB8fCBzaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKGZsdnRvb2wgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNpZ25hbCA/ICdyZWNlaXZlZCBzaWduYWwgJyArIHNpZ25hbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdleGl0ZWQgd2l0aCBjb2RlICcgKyBjb2RlKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB3aGVuIHJ1bm5pbmcgb24gJyArIG91dHB1dC50YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlbWl0RW5kKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgZW1pdEVuZChudWxsLCBzdGRvdXRSaW5nLmdldCgpLCBzdGRlcnJSaW5nLmdldCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZW1pdEVuZChudWxsLCBzdGRvdXRSaW5nLmdldCgpLCBzdGRlcnJSaW5nLmdldCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSZW5pY2UgY3VycmVudCBhbmQvb3IgZnV0dXJlIGZmbXBlZyBwcm9jZXNzZXNcbiAgICpcbiAgICogSWdub3JlZCBvbiBXaW5kb3dzIHBsYXRmb3Jtcy5cbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI3JlbmljZVxuICAgKiBAY2F0ZWdvcnkgUHJvY2Vzc2luZ1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW25pY2VuZXNzPTBdIG5pY2VuZXNzIHZhbHVlIGJldHdlZW4gLTIwIChoaWdoZXN0IHByaW9yaXR5KSBhbmQgMjAgKGxvd2VzdCBwcmlvcml0eSlcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by5yZW5pY2UgPSBmdW5jdGlvbihuaWNlbmVzcykge1xuICAgIGlmICghdXRpbHMuaXNXaW5kb3dzKSB7XG4gICAgICBuaWNlbmVzcyA9IG5pY2VuZXNzIHx8IDA7XG5cbiAgICAgIGlmIChuaWNlbmVzcyA8IC0yMCB8fCBuaWNlbmVzcyA+IDIwKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0ludmFsaWQgbmljZW5lc3MgdmFsdWU6ICcgKyBuaWNlbmVzcyArICcsIG11c3QgYmUgYmV0d2VlbiAtMjAgYW5kIDIwJyk7XG4gICAgICB9XG5cbiAgICAgIG5pY2VuZXNzID0gTWF0aC5taW4oMjAsIE1hdGgubWF4KC0yMCwgbmljZW5lc3MpKTtcbiAgICAgIHRoaXMub3B0aW9ucy5uaWNlbmVzcyA9IG5pY2VuZXNzO1xuXG4gICAgICBpZiAodGhpcy5mZm1wZWdQcm9jKSB7XG4gICAgICAgIHZhciBsb2dnZXIgPSB0aGlzLmxvZ2dlcjtcbiAgICAgICAgdmFyIHBpZCA9IHRoaXMuZmZtcGVnUHJvYy5waWQ7XG4gICAgICAgIHZhciByZW5pY2UgPSBzcGF3bigncmVuaWNlJywgW25pY2VuZXNzLCAnLXAnLCBwaWRdLCB7d2luZG93c0hpZGU6IHRydWV9KTtcblxuICAgICAgICByZW5pY2Uub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ2NvdWxkIG5vdCByZW5pY2UgcHJvY2VzcyAnICsgcGlkICsgJzogJyArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVuaWNlLm9uKCdleGl0JywgZnVuY3Rpb24oY29kZSwgc2lnbmFsKSB7XG4gICAgICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2NvdWxkIG5vdCByZW5pY2UgcHJvY2VzcyAnICsgcGlkICsgJzogcmVuaWNlIHdhcyBraWxsZWQgYnkgc2lnbmFsICcgKyBzaWduYWwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2NvdWxkIG5vdCByZW5pY2UgcHJvY2VzcyAnICsgcGlkICsgJzogcmVuaWNlIGV4aXRlZCB3aXRoICcgKyBjb2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oJ3N1Y2Nlc3NmdWxseSByZW5pY2VkIHByb2Nlc3MgJyArIHBpZCArICcgdG8gJyArIG5pY2VuZXNzICsgJyBuaWNlbmVzcycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogS2lsbCBjdXJyZW50IGZmbXBlZyBwcm9jZXNzLCBpZiBhbnlcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2tpbGxcbiAgICogQGNhdGVnb3J5IFByb2Nlc3NpbmdcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzaWduYWw9U0lHS0lMTF0gc2lnbmFsIG5hbWVcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by5raWxsID0gZnVuY3Rpb24oc2lnbmFsKSB7XG4gICAgaWYgKCF0aGlzLmZmbXBlZ1Byb2MpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ05vIHJ1bm5pbmcgZmZtcGVnIHByb2Nlc3MsIGNhbm5vdCBzZW5kIHNpZ25hbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZmbXBlZ1Byb2Mua2lsbChzaWduYWwgfHwgJ1NJR0tJTEwnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/processor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/recipes.js":
/*!***************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/recipes.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path?8ff8\");\nvar PassThrough = (__webpack_require__(/*! stream */ \"stream\").PassThrough);\nvar async = __webpack_require__(/*! async */ \"(rsc)/./node_modules/async/lib/async.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\");\n\n\n/*\n * Useful recipes for commands\n */\n\nmodule.exports = function recipes(proto) {\n  /**\n   * Execute ffmpeg command and save output to a file\n   *\n   * @method FfmpegCommand#save\n   * @category Processing\n   * @aliases saveToFile\n   *\n   * @param {String} output file path\n   * @return FfmpegCommand\n   */\n  proto.saveToFile =\n  proto.save = function(output) {\n    this.output(output).run();\n    return this;\n  };\n\n\n  /**\n   * Execute ffmpeg command and save output to a stream\n   *\n   * If 'stream' is not specified, a PassThrough stream is created and returned.\n   * 'options' will be used when piping ffmpeg output to the output stream\n   * (@see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options)\n   *\n   * @method FfmpegCommand#pipe\n   * @category Processing\n   * @aliases stream,writeToStream\n   *\n   * @param {stream.Writable} [stream] output stream\n   * @param {Object} [options={}] pipe options\n   * @return Output stream\n   */\n  proto.writeToStream =\n  proto.pipe =\n  proto.stream = function(stream, options) {\n    if (stream && !('writable' in stream)) {\n      options = stream;\n      stream = undefined;\n    }\n\n    if (!stream) {\n      if (process.version.match(/v0\\.8\\./)) {\n        throw new Error('PassThrough stream is not supported on node v0.8');\n      }\n\n      stream = new PassThrough();\n    }\n\n    this.output(stream, options).run();\n    return stream;\n  };\n\n\n  /**\n   * Generate images from a video\n   *\n   * Note: this method makes the command emit a 'filenames' event with an array of\n   * the generated image filenames.\n   *\n   * @method FfmpegCommand#screenshots\n   * @category Processing\n   * @aliases takeScreenshots,thumbnail,thumbnails,screenshot\n   *\n   * @param {Number|Object} [config=1] screenshot count or configuration object with\n   *   the following keys:\n   * @param {Number} [config.count] number of screenshots to take; using this option\n   *   takes screenshots at regular intervals (eg. count=4 would take screens at 20%, 40%,\n   *   60% and 80% of the video length).\n   * @param {String} [config.folder='.'] output folder\n   * @param {String} [config.filename='tn.png'] output filename pattern, may contain the following\n   *   tokens:\n   *   - '%s': offset in seconds\n   *   - '%w': screenshot width\n   *   - '%h': screenshot height\n   *   - '%r': screenshot resolution (same as '%wx%h')\n   *   - '%f': input filename\n   *   - '%b': input basename (filename w/o extension)\n   *   - '%i': index of screenshot in timemark array (can be zero-padded by using it like `%000i`)\n   * @param {Number[]|String[]} [config.timemarks] array of timemarks to take screenshots\n   *   at; each timemark may be a number of seconds, a '[[hh:]mm:]ss[.xxx]' string or a\n   *   'XX%' string.  Overrides 'count' if present.\n   * @param {Number[]|String[]} [config.timestamps] alias for 'timemarks'\n   * @param {Boolean} [config.fastSeek] use fast seek (less accurate)\n   * @param {String} [config.size] screenshot size, with the same syntax as {@link FfmpegCommand#size}\n   * @param {String} [folder] output folder (legacy alias for 'config.folder')\n   * @return FfmpegCommand\n   */\n  proto.takeScreenshots =\n  proto.thumbnail =\n  proto.thumbnails =\n  proto.screenshot =\n  proto.screenshots = function(config, folder) {\n    var self = this;\n    var source = this._currentInput.source;\n    config = config || { count: 1 };\n\n    // Accept a number of screenshots instead of a config object\n    if (typeof config === 'number') {\n      config = {\n        count: config\n      };\n    }\n\n    // Accept a second 'folder' parameter instead of config.folder\n    if (!('folder' in config)) {\n      config.folder = folder || '.';\n    }\n\n    // Accept 'timestamps' instead of 'timemarks'\n    if ('timestamps' in config) {\n      config.timemarks = config.timestamps;\n    }\n\n    // Compute timemarks from count if not present\n    if (!('timemarks' in config)) {\n      if (!config.count) {\n        throw new Error('Cannot take screenshots: neither a count nor a timemark list are specified');\n      }\n\n      var interval = 100 / (1 + config.count);\n      config.timemarks = [];\n      for (var i = 0; i < config.count; i++) {\n        config.timemarks.push((interval * (i + 1)) + '%');\n      }\n    }\n\n    // Parse size option\n    if ('size' in config) {\n      var fixedSize = config.size.match(/^(\\d+)x(\\d+)$/);\n      var fixedWidth = config.size.match(/^(\\d+)x\\?$/);\n      var fixedHeight = config.size.match(/^\\?x(\\d+)$/);\n      var percentSize = config.size.match(/^(\\d+)%$/);\n\n      if (!fixedSize && !fixedWidth && !fixedHeight && !percentSize) {\n        throw new Error('Invalid size parameter: ' + config.size);\n      }\n    }\n\n    // Metadata helper\n    var metadata;\n    function getMetadata(cb) {\n      if (metadata) {\n        cb(null, metadata);\n      } else {\n        self.ffprobe(function(err, meta) {\n          metadata = meta;\n          cb(err, meta);\n        });\n      }\n    }\n\n    async.waterfall([\n      // Compute percent timemarks if any\n      function computeTimemarks(next) {\n        if (config.timemarks.some(function(t) { return ('' + t).match(/^[\\d.]+%$/); })) {\n          if (typeof source !== 'string') {\n            return next(new Error('Cannot compute screenshot timemarks with an input stream, please specify fixed timemarks'));\n          }\n\n          getMetadata(function(err, meta) {\n            if (err) {\n              next(err);\n            } else {\n              // Select video stream with the highest resolution\n              var vstream = meta.streams.reduce(function(biggest, stream) {\n                if (stream.codec_type === 'video' && stream.width * stream.height > biggest.width * biggest.height) {\n                  return stream;\n                } else {\n                  return biggest;\n                }\n              }, { width: 0, height: 0 });\n\n              if (vstream.width === 0) {\n                return next(new Error('No video stream in input, cannot take screenshots'));\n              }\n\n              var duration = Number(vstream.duration);\n              if (isNaN(duration)) {\n                duration = Number(meta.format.duration);\n              }\n\n              if (isNaN(duration)) {\n                return next(new Error('Could not get input duration, please specify fixed timemarks'));\n              }\n\n              config.timemarks = config.timemarks.map(function(mark) {\n                if (('' + mark).match(/^([\\d.]+)%$/)) {\n                  return duration * parseFloat(mark) / 100;\n                } else {\n                  return mark;\n                }\n              });\n\n              next();\n            }\n          });\n        } else {\n          next();\n        }\n      },\n\n      // Turn all timemarks into numbers and sort them\n      function normalizeTimemarks(next) {\n        config.timemarks = config.timemarks.map(function(mark) {\n          return utils.timemarkToSeconds(mark);\n        }).sort(function(a, b) { return a - b; });\n\n        next();\n      },\n\n      // Add '_%i' to pattern when requesting multiple screenshots and no variable token is present\n      function fixPattern(next) {\n        var pattern = config.filename || 'tn.png';\n\n        if (pattern.indexOf('.') === -1) {\n          pattern += '.png';\n        }\n\n        if (config.timemarks.length > 1 && !pattern.match(/%(s|0*i)/)) {\n          var ext = path.extname(pattern);\n          pattern = path.join(path.dirname(pattern), path.basename(pattern, ext) + '_%i' + ext);\n        }\n\n        next(null, pattern);\n      },\n\n      // Replace filename tokens (%f, %b) in pattern\n      function replaceFilenameTokens(pattern, next) {\n        if (pattern.match(/%[bf]/)) {\n          if (typeof source !== 'string') {\n            return next(new Error('Cannot replace %f or %b when using an input stream'));\n          }\n\n          pattern = pattern\n            .replace(/%f/g, path.basename(source))\n            .replace(/%b/g, path.basename(source, path.extname(source)));\n        }\n\n        next(null, pattern);\n      },\n\n      // Compute size if needed\n      function getSize(pattern, next) {\n        if (pattern.match(/%[whr]/)) {\n          if (fixedSize) {\n            return next(null, pattern, fixedSize[1], fixedSize[2]);\n          }\n\n          getMetadata(function(err, meta) {\n            if (err) {\n              return next(new Error('Could not determine video resolution to replace %w, %h or %r'));\n            }\n\n            var vstream = meta.streams.reduce(function(biggest, stream) {\n              if (stream.codec_type === 'video' && stream.width * stream.height > biggest.width * biggest.height) {\n                return stream;\n              } else {\n                return biggest;\n              }\n            }, { width: 0, height: 0 });\n\n            if (vstream.width === 0) {\n              return next(new Error('No video stream in input, cannot replace %w, %h or %r'));\n            }\n\n            var width = vstream.width;\n            var height = vstream.height;\n\n            if (fixedWidth) {\n              height = height * Number(fixedWidth[1]) / width;\n              width = Number(fixedWidth[1]);\n            } else if (fixedHeight) {\n              width = width * Number(fixedHeight[1]) / height;\n              height = Number(fixedHeight[1]);\n            } else if (percentSize) {\n              width = width * Number(percentSize[1]) / 100;\n              height = height * Number(percentSize[1]) / 100;\n            }\n\n            next(null, pattern, Math.round(width / 2) * 2, Math.round(height / 2) * 2);\n          });\n        } else {\n          next(null, pattern, -1, -1);\n        }\n      },\n\n      // Replace size tokens (%w, %h, %r) in pattern\n      function replaceSizeTokens(pattern, width, height, next) {\n        pattern = pattern\n          .replace(/%r/g, '%wx%h')\n          .replace(/%w/g, width)\n          .replace(/%h/g, height);\n\n        next(null, pattern);\n      },\n\n      // Replace variable tokens in pattern (%s, %i) and generate filename list\n      function replaceVariableTokens(pattern, next) {\n        var filenames = config.timemarks.map(function(t, i) {\n          return pattern\n            .replace(/%s/g, utils.timemarkToSeconds(t))\n            .replace(/%(0*)i/g, function(match, padding) {\n              var idx = '' + (i + 1);\n              return padding.substr(0, Math.max(0, padding.length + 1 - idx.length)) + idx;\n            });\n        });\n\n        self.emit('filenames', filenames);\n        next(null, filenames);\n      },\n\n      // Create output directory\n      function createDirectory(filenames, next) {\n        fs.exists(config.folder, function(exists) {\n          if (!exists) {\n            fs.mkdir(config.folder, function(err) {\n              if (err) {\n                next(err);\n              } else {\n                next(null, filenames);\n              }\n            });\n          } else {\n            next(null, filenames);\n          }\n        });\n      }\n    ], function runCommand(err, filenames) {\n      if (err) {\n        return self.emit('error', err);\n      }\n\n      var count = config.timemarks.length;\n      var split;\n      var filters = [split = {\n        filter: 'split',\n        options: count,\n        outputs: []\n      }];\n\n      if ('size' in config) {\n        // Set size to generate size filters\n        self.size(config.size);\n\n        // Get size filters and chain them with 'sizeN' stream names\n        var sizeFilters =  self._currentOutput.sizeFilters.get().map(function(f, i) {\n          if (i > 0) {\n            f.inputs = 'size' + (i - 1);\n          }\n\n          f.outputs = 'size' + i;\n\n          return f;\n        });\n\n        // Input last size filter output into split filter\n        split.inputs = 'size' + (sizeFilters.length - 1);\n\n        // Add size filters in front of split filter\n        filters = sizeFilters.concat(filters);\n\n        // Remove size filters\n        self._currentOutput.sizeFilters.clear();\n      }\n\n      var first = 0;\n      for (var i = 0; i < count; i++) {\n        var stream = 'screen' + i;\n        split.outputs.push(stream);\n\n        if (i === 0) {\n          first = config.timemarks[i];\n          self.seekInput(first);\n        }\n\n        self.output(path.join(config.folder, filenames[i]))\n          .frames(1)\n          .map(stream);\n\n        if (i > 0) {\n          self.seek(config.timemarks[i] - first);\n        }\n      }\n\n      self.complexFilter(filters);\n      self.run();\n    });\n\n    return this;\n  };\n\n\n  /**\n   * Merge (concatenate) inputs to a single file\n   *\n   * @method FfmpegCommand#concat\n   * @category Processing\n   * @aliases concatenate,mergeToFile\n   *\n   * @param {String|Writable} target output file or writable stream\n   * @param {Object} [options] pipe options (only used when outputting to a writable stream)\n   * @return FfmpegCommand\n   */\n  proto.mergeToFile =\n  proto.concatenate =\n  proto.concat = function(target, options) {\n    // Find out which streams are present in the first non-stream input\n    var fileInput = this._inputs.filter(function(input) {\n      return !input.isStream;\n    })[0];\n\n    var self = this;\n    this.ffprobe(this._inputs.indexOf(fileInput), function(err, data) {\n      if (err) {\n        return self.emit('error', err);\n      }\n\n      var hasAudioStreams = data.streams.some(function(stream) {\n        return stream.codec_type === 'audio';\n      });\n\n      var hasVideoStreams = data.streams.some(function(stream) {\n        return stream.codec_type === 'video';\n      });\n\n      // Setup concat filter and start processing\n      self.output(target, options)\n        .complexFilter({\n          filter: 'concat',\n          options: {\n            n: self._inputs.length,\n            v: hasVideoStreams ? 1 : 0,\n            a: hasAudioStreams ? 1 : 0\n          }\n        })\n        .run();\n    });\n\n    return this;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvcmVjaXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOztBQUViLFNBQVMsbUJBQU8sQ0FBQyxjQUFJO0FBQ3JCLFdBQVcsbUJBQU8sQ0FBQyx1QkFBTTtBQUN6QixrQkFBa0IseURBQTZCO0FBQy9DLFlBQVksbUJBQU8sQ0FBQyxzREFBTztBQUMzQixZQUFZLG1CQUFPLENBQUMsZ0VBQVM7OztBQUc3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsUUFBUSxXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQSxhQUFhLFFBQVEsOENBQThDO0FBQ25FO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxXQUFXO0FBQ1g7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLFNBQVM7QUFDdEIsYUFBYSxRQUFRLHdEQUF3RDtBQUM3RSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHFDQUFxQztBQUNyRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlLElBQUkscUJBQXFCOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0JBQXdCLGVBQWU7O0FBRWhEO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWEsSUFBSSxxQkFBcUI7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWZpcmViYXNlLWFwaS8uL25vZGVfbW9kdWxlcy9mbHVlbnQtZmZtcGVnL2xpYi9yZWNpcGVzLmpzPzJmNmIiXSwic291cmNlc0NvbnRlbnQiOlsiLypqc2hpbnQgbm9kZTp0cnVlKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIFBhc3NUaHJvdWdoID0gcmVxdWlyZSgnc3RyZWFtJykuUGFzc1Rocm91Z2g7XG52YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5cbi8qXG4gKiBVc2VmdWwgcmVjaXBlcyBmb3IgY29tbWFuZHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlY2lwZXMocHJvdG8pIHtcbiAgLyoqXG4gICAqIEV4ZWN1dGUgZmZtcGVnIGNvbW1hbmQgYW5kIHNhdmUgb3V0cHV0IHRvIGEgZmlsZVxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjc2F2ZVxuICAgKiBAY2F0ZWdvcnkgUHJvY2Vzc2luZ1xuICAgKiBAYWxpYXNlcyBzYXZlVG9GaWxlXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvdXRwdXQgZmlsZSBwYXRoXG4gICAqIEByZXR1cm4gRmZtcGVnQ29tbWFuZFxuICAgKi9cbiAgcHJvdG8uc2F2ZVRvRmlsZSA9XG4gIHByb3RvLnNhdmUgPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICB0aGlzLm91dHB1dChvdXRwdXQpLnJ1bigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgZmZtcGVnIGNvbW1hbmQgYW5kIHNhdmUgb3V0cHV0IHRvIGEgc3RyZWFtXG4gICAqXG4gICAqIElmICdzdHJlYW0nIGlzIG5vdCBzcGVjaWZpZWQsIGEgUGFzc1Rocm91Z2ggc3RyZWFtIGlzIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxuICAgKiAnb3B0aW9ucycgd2lsbCBiZSB1c2VkIHdoZW4gcGlwaW5nIGZmbXBlZyBvdXRwdXQgdG8gdGhlIG91dHB1dCBzdHJlYW1cbiAgICogKEBzZWUgaHR0cDovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sI3N0cmVhbV9yZWFkYWJsZV9waXBlX2Rlc3RpbmF0aW9uX29wdGlvbnMpXG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNwaXBlXG4gICAqIEBjYXRlZ29yeSBQcm9jZXNzaW5nXG4gICAqIEBhbGlhc2VzIHN0cmVhbSx3cml0ZVRvU3RyZWFtXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyZWFtLldyaXRhYmxlfSBbc3RyZWFtXSBvdXRwdXQgc3RyZWFtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gcGlwZSBvcHRpb25zXG4gICAqIEByZXR1cm4gT3V0cHV0IHN0cmVhbVxuICAgKi9cbiAgcHJvdG8ud3JpdGVUb1N0cmVhbSA9XG4gIHByb3RvLnBpcGUgPVxuICBwcm90by5zdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0sIG9wdGlvbnMpIHtcbiAgICBpZiAoc3RyZWFtICYmICEoJ3dyaXRhYmxlJyBpbiBzdHJlYW0pKSB7XG4gICAgICBvcHRpb25zID0gc3RyZWFtO1xuICAgICAgc3RyZWFtID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICghc3RyZWFtKSB7XG4gICAgICBpZiAocHJvY2Vzcy52ZXJzaW9uLm1hdGNoKC92MFxcLjhcXC4vKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bhc3NUaHJvdWdoIHN0cmVhbSBpcyBub3Qgc3VwcG9ydGVkIG9uIG5vZGUgdjAuOCcpO1xuICAgICAgfVxuXG4gICAgICBzdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2goKTtcbiAgICB9XG5cbiAgICB0aGlzLm91dHB1dChzdHJlYW0sIG9wdGlvbnMpLnJ1bigpO1xuICAgIHJldHVybiBzdHJlYW07XG4gIH07XG5cblxuICAvKipcbiAgICogR2VuZXJhdGUgaW1hZ2VzIGZyb20gYSB2aWRlb1xuICAgKlxuICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBtYWtlcyB0aGUgY29tbWFuZCBlbWl0IGEgJ2ZpbGVuYW1lcycgZXZlbnQgd2l0aCBhbiBhcnJheSBvZlxuICAgKiB0aGUgZ2VuZXJhdGVkIGltYWdlIGZpbGVuYW1lcy5cbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI3NjcmVlbnNob3RzXG4gICAqIEBjYXRlZ29yeSBQcm9jZXNzaW5nXG4gICAqIEBhbGlhc2VzIHRha2VTY3JlZW5zaG90cyx0aHVtYm5haWwsdGh1bWJuYWlscyxzY3JlZW5zaG90XG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gW2NvbmZpZz0xXSBzY3JlZW5zaG90IGNvdW50IG9yIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdpdGhcbiAgICogICB0aGUgZm9sbG93aW5nIGtleXM6XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNvdW50XSBudW1iZXIgb2Ygc2NyZWVuc2hvdHMgdG8gdGFrZTsgdXNpbmcgdGhpcyBvcHRpb25cbiAgICogICB0YWtlcyBzY3JlZW5zaG90cyBhdCByZWd1bGFyIGludGVydmFscyAoZWcuIGNvdW50PTQgd291bGQgdGFrZSBzY3JlZW5zIGF0IDIwJSwgNDAlLFxuICAgKiAgIDYwJSBhbmQgODAlIG9mIHRoZSB2aWRlbyBsZW5ndGgpLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5mb2xkZXI9Jy4nXSBvdXRwdXQgZm9sZGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGVuYW1lPSd0bi5wbmcnXSBvdXRwdXQgZmlsZW5hbWUgcGF0dGVybiwgbWF5IGNvbnRhaW4gdGhlIGZvbGxvd2luZ1xuICAgKiAgIHRva2VuczpcbiAgICogICAtICclcyc6IG9mZnNldCBpbiBzZWNvbmRzXG4gICAqICAgLSAnJXcnOiBzY3JlZW5zaG90IHdpZHRoXG4gICAqICAgLSAnJWgnOiBzY3JlZW5zaG90IGhlaWdodFxuICAgKiAgIC0gJyVyJzogc2NyZWVuc2hvdCByZXNvbHV0aW9uIChzYW1lIGFzICcld3glaCcpXG4gICAqICAgLSAnJWYnOiBpbnB1dCBmaWxlbmFtZVxuICAgKiAgIC0gJyViJzogaW5wdXQgYmFzZW5hbWUgKGZpbGVuYW1lIHcvbyBleHRlbnNpb24pXG4gICAqICAgLSAnJWknOiBpbmRleCBvZiBzY3JlZW5zaG90IGluIHRpbWVtYXJrIGFycmF5IChjYW4gYmUgemVyby1wYWRkZWQgYnkgdXNpbmcgaXQgbGlrZSBgJTAwMGlgKVxuICAgKiBAcGFyYW0ge051bWJlcltdfFN0cmluZ1tdfSBbY29uZmlnLnRpbWVtYXJrc10gYXJyYXkgb2YgdGltZW1hcmtzIHRvIHRha2Ugc2NyZWVuc2hvdHNcbiAgICogICBhdDsgZWFjaCB0aW1lbWFyayBtYXkgYmUgYSBudW1iZXIgb2Ygc2Vjb25kcywgYSAnW1toaDpdbW06XXNzWy54eHhdJyBzdHJpbmcgb3IgYVxuICAgKiAgICdYWCUnIHN0cmluZy4gIE92ZXJyaWRlcyAnY291bnQnIGlmIHByZXNlbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyW118U3RyaW5nW119IFtjb25maWcudGltZXN0YW1wc10gYWxpYXMgZm9yICd0aW1lbWFya3MnXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5mYXN0U2Vla10gdXNlIGZhc3Qgc2VlayAobGVzcyBhY2N1cmF0ZSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2l6ZV0gc2NyZWVuc2hvdCBzaXplLCB3aXRoIHRoZSBzYW1lIHN5bnRheCBhcyB7QGxpbmsgRmZtcGVnQ29tbWFuZCNzaXplfVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2ZvbGRlcl0gb3V0cHV0IGZvbGRlciAobGVnYWN5IGFsaWFzIGZvciAnY29uZmlnLmZvbGRlcicpXG4gICAqIEByZXR1cm4gRmZtcGVnQ29tbWFuZFxuICAgKi9cbiAgcHJvdG8udGFrZVNjcmVlbnNob3RzID1cbiAgcHJvdG8udGh1bWJuYWlsID1cbiAgcHJvdG8udGh1bWJuYWlscyA9XG4gIHByb3RvLnNjcmVlbnNob3QgPVxuICBwcm90by5zY3JlZW5zaG90cyA9IGZ1bmN0aW9uKGNvbmZpZywgZm9sZGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLl9jdXJyZW50SW5wdXQuc291cmNlO1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7IGNvdW50OiAxIH07XG5cbiAgICAvLyBBY2NlcHQgYSBudW1iZXIgb2Ygc2NyZWVuc2hvdHMgaW5zdGVhZCBvZiBhIGNvbmZpZyBvYmplY3RcbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgY291bnQ6IGNvbmZpZ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBBY2NlcHQgYSBzZWNvbmQgJ2ZvbGRlcicgcGFyYW1ldGVyIGluc3RlYWQgb2YgY29uZmlnLmZvbGRlclxuICAgIGlmICghKCdmb2xkZXInIGluIGNvbmZpZykpIHtcbiAgICAgIGNvbmZpZy5mb2xkZXIgPSBmb2xkZXIgfHwgJy4nO1xuICAgIH1cblxuICAgIC8vIEFjY2VwdCAndGltZXN0YW1wcycgaW5zdGVhZCBvZiAndGltZW1hcmtzJ1xuICAgIGlmICgndGltZXN0YW1wcycgaW4gY29uZmlnKSB7XG4gICAgICBjb25maWcudGltZW1hcmtzID0gY29uZmlnLnRpbWVzdGFtcHM7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSB0aW1lbWFya3MgZnJvbSBjb3VudCBpZiBub3QgcHJlc2VudFxuICAgIGlmICghKCd0aW1lbWFya3MnIGluIGNvbmZpZykpIHtcbiAgICAgIGlmICghY29uZmlnLmNvdW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHRha2Ugc2NyZWVuc2hvdHM6IG5laXRoZXIgYSBjb3VudCBub3IgYSB0aW1lbWFyayBsaXN0IGFyZSBzcGVjaWZpZWQnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGludGVydmFsID0gMTAwIC8gKDEgKyBjb25maWcuY291bnQpO1xuICAgICAgY29uZmlnLnRpbWVtYXJrcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25maWcuY291bnQ7IGkrKykge1xuICAgICAgICBjb25maWcudGltZW1hcmtzLnB1c2goKGludGVydmFsICogKGkgKyAxKSkgKyAnJScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBhcnNlIHNpemUgb3B0aW9uXG4gICAgaWYgKCdzaXplJyBpbiBjb25maWcpIHtcbiAgICAgIHZhciBmaXhlZFNpemUgPSBjb25maWcuc2l6ZS5tYXRjaCgvXihcXGQrKXgoXFxkKykkLyk7XG4gICAgICB2YXIgZml4ZWRXaWR0aCA9IGNvbmZpZy5zaXplLm1hdGNoKC9eKFxcZCspeFxcPyQvKTtcbiAgICAgIHZhciBmaXhlZEhlaWdodCA9IGNvbmZpZy5zaXplLm1hdGNoKC9eXFw/eChcXGQrKSQvKTtcbiAgICAgIHZhciBwZXJjZW50U2l6ZSA9IGNvbmZpZy5zaXplLm1hdGNoKC9eKFxcZCspJSQvKTtcblxuICAgICAgaWYgKCFmaXhlZFNpemUgJiYgIWZpeGVkV2lkdGggJiYgIWZpeGVkSGVpZ2h0ICYmICFwZXJjZW50U2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2l6ZSBwYXJhbWV0ZXI6ICcgKyBjb25maWcuc2l6ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWV0YWRhdGEgaGVscGVyXG4gICAgdmFyIG1ldGFkYXRhO1xuICAgIGZ1bmN0aW9uIGdldE1ldGFkYXRhKGNiKSB7XG4gICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgY2IobnVsbCwgbWV0YWRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5mZnByb2JlKGZ1bmN0aW9uKGVyciwgbWV0YSkge1xuICAgICAgICAgIG1ldGFkYXRhID0gbWV0YTtcbiAgICAgICAgICBjYihlcnIsIG1ldGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYy53YXRlcmZhbGwoW1xuICAgICAgLy8gQ29tcHV0ZSBwZXJjZW50IHRpbWVtYXJrcyBpZiBhbnlcbiAgICAgIGZ1bmN0aW9uIGNvbXB1dGVUaW1lbWFya3MobmV4dCkge1xuICAgICAgICBpZiAoY29uZmlnLnRpbWVtYXJrcy5zb21lKGZ1bmN0aW9uKHQpIHsgcmV0dXJuICgnJyArIHQpLm1hdGNoKC9eW1xcZC5dKyUkLyk7IH0pKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dChuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wdXRlIHNjcmVlbnNob3QgdGltZW1hcmtzIHdpdGggYW4gaW5wdXQgc3RyZWFtLCBwbGVhc2Ugc3BlY2lmeSBmaXhlZCB0aW1lbWFya3MnKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2V0TWV0YWRhdGEoZnVuY3Rpb24oZXJyLCBtZXRhKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIG5leHQoZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFNlbGVjdCB2aWRlbyBzdHJlYW0gd2l0aCB0aGUgaGlnaGVzdCByZXNvbHV0aW9uXG4gICAgICAgICAgICAgIHZhciB2c3RyZWFtID0gbWV0YS5zdHJlYW1zLnJlZHVjZShmdW5jdGlvbihiaWdnZXN0LCBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLmNvZGVjX3R5cGUgPT09ICd2aWRlbycgJiYgc3RyZWFtLndpZHRoICogc3RyZWFtLmhlaWdodCA+IGJpZ2dlc3Qud2lkdGggKiBiaWdnZXN0LmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpZ2dlc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKHZzdHJlYW0ud2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChuZXcgRXJyb3IoJ05vIHZpZGVvIHN0cmVhbSBpbiBpbnB1dCwgY2Fubm90IHRha2Ugc2NyZWVuc2hvdHMnKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBOdW1iZXIodnN0cmVhbS5kdXJhdGlvbik7XG4gICAgICAgICAgICAgIGlmIChpc05hTihkdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE51bWJlcihtZXRhLmZvcm1hdC5kdXJhdGlvbik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaXNOYU4oZHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQobmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IGlucHV0IGR1cmF0aW9uLCBwbGVhc2Ugc3BlY2lmeSBmaXhlZCB0aW1lbWFya3MnKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25maWcudGltZW1hcmtzID0gY29uZmlnLnRpbWVtYXJrcy5tYXAoZnVuY3Rpb24obWFyaykge1xuICAgICAgICAgICAgICAgIGlmICgoJycgKyBtYXJrKS5tYXRjaCgvXihbXFxkLl0rKSUkLykpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkdXJhdGlvbiAqIHBhcnNlRmxvYXQobWFyaykgLyAxMDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtYXJrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLy8gVHVybiBhbGwgdGltZW1hcmtzIGludG8gbnVtYmVycyBhbmQgc29ydCB0aGVtXG4gICAgICBmdW5jdGlvbiBub3JtYWxpemVUaW1lbWFya3MobmV4dCkge1xuICAgICAgICBjb25maWcudGltZW1hcmtzID0gY29uZmlnLnRpbWVtYXJrcy5tYXAoZnVuY3Rpb24obWFyaykge1xuICAgICAgICAgIHJldHVybiB1dGlscy50aW1lbWFya1RvU2Vjb25kcyhtYXJrKTtcbiAgICAgICAgfSkuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG5cbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSxcblxuICAgICAgLy8gQWRkICdfJWknIHRvIHBhdHRlcm4gd2hlbiByZXF1ZXN0aW5nIG11bHRpcGxlIHNjcmVlbnNob3RzIGFuZCBubyB2YXJpYWJsZSB0b2tlbiBpcyBwcmVzZW50XG4gICAgICBmdW5jdGlvbiBmaXhQYXR0ZXJuKG5leHQpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBjb25maWcuZmlsZW5hbWUgfHwgJ3RuLnBuZyc7XG5cbiAgICAgICAgaWYgKHBhdHRlcm4uaW5kZXhPZignLicpID09PSAtMSkge1xuICAgICAgICAgIHBhdHRlcm4gKz0gJy5wbmcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy50aW1lbWFya3MubGVuZ3RoID4gMSAmJiAhcGF0dGVybi5tYXRjaCgvJShzfDAqaSkvKSkge1xuICAgICAgICAgIHZhciBleHQgPSBwYXRoLmV4dG5hbWUocGF0dGVybik7XG4gICAgICAgICAgcGF0dGVybiA9IHBhdGguam9pbihwYXRoLmRpcm5hbWUocGF0dGVybiksIHBhdGguYmFzZW5hbWUocGF0dGVybiwgZXh0KSArICdfJWknICsgZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQobnVsbCwgcGF0dGVybik7XG4gICAgICB9LFxuXG4gICAgICAvLyBSZXBsYWNlIGZpbGVuYW1lIHRva2VucyAoJWYsICViKSBpbiBwYXR0ZXJuXG4gICAgICBmdW5jdGlvbiByZXBsYWNlRmlsZW5hbWVUb2tlbnMocGF0dGVybiwgbmV4dCkge1xuICAgICAgICBpZiAocGF0dGVybi5tYXRjaCgvJVtiZl0vKSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQobmV3IEVycm9yKCdDYW5ub3QgcmVwbGFjZSAlZiBvciAlYiB3aGVuIHVzaW5nIGFuIGlucHV0IHN0cmVhbScpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXR0ZXJuID0gcGF0dGVyblxuICAgICAgICAgICAgLnJlcGxhY2UoLyVmL2csIHBhdGguYmFzZW5hbWUoc291cmNlKSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC8lYi9nLCBwYXRoLmJhc2VuYW1lKHNvdXJjZSwgcGF0aC5leHRuYW1lKHNvdXJjZSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQobnVsbCwgcGF0dGVybik7XG4gICAgICB9LFxuXG4gICAgICAvLyBDb21wdXRlIHNpemUgaWYgbmVlZGVkXG4gICAgICBmdW5jdGlvbiBnZXRTaXplKHBhdHRlcm4sIG5leHQpIHtcbiAgICAgICAgaWYgKHBhdHRlcm4ubWF0Y2goLyVbd2hyXS8pKSB7XG4gICAgICAgICAgaWYgKGZpeGVkU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQobnVsbCwgcGF0dGVybiwgZml4ZWRTaXplWzFdLCBmaXhlZFNpemVbMl0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdldE1ldGFkYXRhKGZ1bmN0aW9uKGVyciwgbWV0YSkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dChuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgdmlkZW8gcmVzb2x1dGlvbiB0byByZXBsYWNlICV3LCAlaCBvciAlcicpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZzdHJlYW0gPSBtZXRhLnN0cmVhbXMucmVkdWNlKGZ1bmN0aW9uKGJpZ2dlc3QsIHN0cmVhbSkge1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtLmNvZGVjX3R5cGUgPT09ICd2aWRlbycgJiYgc3RyZWFtLndpZHRoICogc3RyZWFtLmhlaWdodCA+IGJpZ2dlc3Qud2lkdGggKiBiaWdnZXN0LmhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpZ2dlc3Q7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHsgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcblxuICAgICAgICAgICAgaWYgKHZzdHJlYW0ud2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQobmV3IEVycm9yKCdObyB2aWRlbyBzdHJlYW0gaW4gaW5wdXQsIGNhbm5vdCByZXBsYWNlICV3LCAlaCBvciAlcicpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHdpZHRoID0gdnN0cmVhbS53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB2c3RyZWFtLmhlaWdodDtcblxuICAgICAgICAgICAgaWYgKGZpeGVkV2lkdGgpIHtcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0ICogTnVtYmVyKGZpeGVkV2lkdGhbMV0pIC8gd2lkdGg7XG4gICAgICAgICAgICAgIHdpZHRoID0gTnVtYmVyKGZpeGVkV2lkdGhbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmaXhlZEhlaWdodCkge1xuICAgICAgICAgICAgICB3aWR0aCA9IHdpZHRoICogTnVtYmVyKGZpeGVkSGVpZ2h0WzFdKSAvIGhlaWdodDtcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gTnVtYmVyKGZpeGVkSGVpZ2h0WzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGVyY2VudFNpemUpIHtcbiAgICAgICAgICAgICAgd2lkdGggPSB3aWR0aCAqIE51bWJlcihwZXJjZW50U2l6ZVsxXSkgLyAxMDA7XG4gICAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCAqIE51bWJlcihwZXJjZW50U2l6ZVsxXSkgLyAxMDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5leHQobnVsbCwgcGF0dGVybiwgTWF0aC5yb3VuZCh3aWR0aCAvIDIpICogMiwgTWF0aC5yb3VuZChoZWlnaHQgLyAyKSAqIDIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQobnVsbCwgcGF0dGVybiwgLTEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLy8gUmVwbGFjZSBzaXplIHRva2VucyAoJXcsICVoLCAlcikgaW4gcGF0dGVyblxuICAgICAgZnVuY3Rpb24gcmVwbGFjZVNpemVUb2tlbnMocGF0dGVybiwgd2lkdGgsIGhlaWdodCwgbmV4dCkge1xuICAgICAgICBwYXR0ZXJuID0gcGF0dGVyblxuICAgICAgICAgIC5yZXBsYWNlKC8lci9nLCAnJXd4JWgnKVxuICAgICAgICAgIC5yZXBsYWNlKC8ldy9nLCB3aWR0aClcbiAgICAgICAgICAucmVwbGFjZSgvJWgvZywgaGVpZ2h0KTtcblxuICAgICAgICBuZXh0KG51bGwsIHBhdHRlcm4pO1xuICAgICAgfSxcblxuICAgICAgLy8gUmVwbGFjZSB2YXJpYWJsZSB0b2tlbnMgaW4gcGF0dGVybiAoJXMsICVpKSBhbmQgZ2VuZXJhdGUgZmlsZW5hbWUgbGlzdFxuICAgICAgZnVuY3Rpb24gcmVwbGFjZVZhcmlhYmxlVG9rZW5zKHBhdHRlcm4sIG5leHQpIHtcbiAgICAgICAgdmFyIGZpbGVuYW1lcyA9IGNvbmZpZy50aW1lbWFya3MubWFwKGZ1bmN0aW9uKHQsIGkpIHtcbiAgICAgICAgICByZXR1cm4gcGF0dGVyblxuICAgICAgICAgICAgLnJlcGxhY2UoLyVzL2csIHV0aWxzLnRpbWVtYXJrVG9TZWNvbmRzKHQpKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyUoMCopaS9nLCBmdW5jdGlvbihtYXRjaCwgcGFkZGluZykge1xuICAgICAgICAgICAgICB2YXIgaWR4ID0gJycgKyAoaSArIDEpO1xuICAgICAgICAgICAgICByZXR1cm4gcGFkZGluZy5zdWJzdHIoMCwgTWF0aC5tYXgoMCwgcGFkZGluZy5sZW5ndGggKyAxIC0gaWR4Lmxlbmd0aCkpICsgaWR4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNlbGYuZW1pdCgnZmlsZW5hbWVzJywgZmlsZW5hbWVzKTtcbiAgICAgICAgbmV4dChudWxsLCBmaWxlbmFtZXMpO1xuICAgICAgfSxcblxuICAgICAgLy8gQ3JlYXRlIG91dHB1dCBkaXJlY3RvcnlcbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZURpcmVjdG9yeShmaWxlbmFtZXMsIG5leHQpIHtcbiAgICAgICAgZnMuZXhpc3RzKGNvbmZpZy5mb2xkZXIsIGZ1bmN0aW9uKGV4aXN0cykge1xuICAgICAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgICAgICBmcy5ta2Rpcihjb25maWcuZm9sZGVyLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIG5leHQoZXJyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0KG51bGwsIGZpbGVuYW1lcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0KG51bGwsIGZpbGVuYW1lcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBdLCBmdW5jdGlvbiBydW5Db21tYW5kKGVyciwgZmlsZW5hbWVzKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvdW50ID0gY29uZmlnLnRpbWVtYXJrcy5sZW5ndGg7XG4gICAgICB2YXIgc3BsaXQ7XG4gICAgICB2YXIgZmlsdGVycyA9IFtzcGxpdCA9IHtcbiAgICAgICAgZmlsdGVyOiAnc3BsaXQnLFxuICAgICAgICBvcHRpb25zOiBjb3VudCxcbiAgICAgICAgb3V0cHV0czogW11cbiAgICAgIH1dO1xuXG4gICAgICBpZiAoJ3NpemUnIGluIGNvbmZpZykge1xuICAgICAgICAvLyBTZXQgc2l6ZSB0byBnZW5lcmF0ZSBzaXplIGZpbHRlcnNcbiAgICAgICAgc2VsZi5zaXplKGNvbmZpZy5zaXplKTtcblxuICAgICAgICAvLyBHZXQgc2l6ZSBmaWx0ZXJzIGFuZCBjaGFpbiB0aGVtIHdpdGggJ3NpemVOJyBzdHJlYW0gbmFtZXNcbiAgICAgICAgdmFyIHNpemVGaWx0ZXJzID0gIHNlbGYuX2N1cnJlbnRPdXRwdXQuc2l6ZUZpbHRlcnMuZ2V0KCkubWFwKGZ1bmN0aW9uKGYsIGkpIHtcbiAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGYuaW5wdXRzID0gJ3NpemUnICsgKGkgLSAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmLm91dHB1dHMgPSAnc2l6ZScgKyBpO1xuXG4gICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIElucHV0IGxhc3Qgc2l6ZSBmaWx0ZXIgb3V0cHV0IGludG8gc3BsaXQgZmlsdGVyXG4gICAgICAgIHNwbGl0LmlucHV0cyA9ICdzaXplJyArIChzaXplRmlsdGVycy5sZW5ndGggLSAxKTtcblxuICAgICAgICAvLyBBZGQgc2l6ZSBmaWx0ZXJzIGluIGZyb250IG9mIHNwbGl0IGZpbHRlclxuICAgICAgICBmaWx0ZXJzID0gc2l6ZUZpbHRlcnMuY29uY2F0KGZpbHRlcnMpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBzaXplIGZpbHRlcnNcbiAgICAgICAgc2VsZi5fY3VycmVudE91dHB1dC5zaXplRmlsdGVycy5jbGVhcigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlyc3QgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSAnc2NyZWVuJyArIGk7XG4gICAgICAgIHNwbGl0Lm91dHB1dHMucHVzaChzdHJlYW0pO1xuXG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgZmlyc3QgPSBjb25maWcudGltZW1hcmtzW2ldO1xuICAgICAgICAgIHNlbGYuc2Vla0lucHV0KGZpcnN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYub3V0cHV0KHBhdGguam9pbihjb25maWcuZm9sZGVyLCBmaWxlbmFtZXNbaV0pKVxuICAgICAgICAgIC5mcmFtZXMoMSlcbiAgICAgICAgICAubWFwKHN0cmVhbSk7XG5cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgc2VsZi5zZWVrKGNvbmZpZy50aW1lbWFya3NbaV0gLSBmaXJzdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi5jb21wbGV4RmlsdGVyKGZpbHRlcnMpO1xuICAgICAgc2VsZi5ydW4oKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIE1lcmdlIChjb25jYXRlbmF0ZSkgaW5wdXRzIHRvIGEgc2luZ2xlIGZpbGVcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2NvbmNhdFxuICAgKiBAY2F0ZWdvcnkgUHJvY2Vzc2luZ1xuICAgKiBAYWxpYXNlcyBjb25jYXRlbmF0ZSxtZXJnZVRvRmlsZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xXcml0YWJsZX0gdGFyZ2V0IG91dHB1dCBmaWxlIG9yIHdyaXRhYmxlIHN0cmVhbVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHBpcGUgb3B0aW9ucyAob25seSB1c2VkIHdoZW4gb3V0cHV0dGluZyB0byBhIHdyaXRhYmxlIHN0cmVhbSlcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by5tZXJnZVRvRmlsZSA9XG4gIHByb3RvLmNvbmNhdGVuYXRlID1cbiAgcHJvdG8uY29uY2F0ID0gZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgLy8gRmluZCBvdXQgd2hpY2ggc3RyZWFtcyBhcmUgcHJlc2VudCBpbiB0aGUgZmlyc3Qgbm9uLXN0cmVhbSBpbnB1dFxuICAgIHZhciBmaWxlSW5wdXQgPSB0aGlzLl9pbnB1dHMuZmlsdGVyKGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICByZXR1cm4gIWlucHV0LmlzU3RyZWFtO1xuICAgIH0pWzBdO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZmZwcm9iZSh0aGlzLl9pbnB1dHMuaW5kZXhPZihmaWxlSW5wdXQpLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzQXVkaW9TdHJlYW1zID0gZGF0YS5zdHJlYW1zLnNvbWUoZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0uY29kZWNfdHlwZSA9PT0gJ2F1ZGlvJztcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgaGFzVmlkZW9TdHJlYW1zID0gZGF0YS5zdHJlYW1zLnNvbWUoZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0uY29kZWNfdHlwZSA9PT0gJ3ZpZGVvJztcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTZXR1cCBjb25jYXQgZmlsdGVyIGFuZCBzdGFydCBwcm9jZXNzaW5nXG4gICAgICBzZWxmLm91dHB1dCh0YXJnZXQsIG9wdGlvbnMpXG4gICAgICAgIC5jb21wbGV4RmlsdGVyKHtcbiAgICAgICAgICBmaWx0ZXI6ICdjb25jYXQnLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG46IHNlbGYuX2lucHV0cy5sZW5ndGgsXG4gICAgICAgICAgICB2OiBoYXNWaWRlb1N0cmVhbXMgPyAxIDogMCxcbiAgICAgICAgICAgIGE6IGhhc0F1ZGlvU3RyZWFtcyA/IDEgOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAucnVuKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/recipes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/utils.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar exec = (__webpack_require__(/*! child_process */ \"child_process\").exec);\nvar isWindows = (__webpack_require__(/*! os */ \"os\").platform)().match(/win(32|64)/);\nvar which = __webpack_require__(/*! which */ \"(rsc)/./node_modules/which/which.js\");\n\nvar nlRegexp = /\\r\\n|\\r|\\n/g;\nvar streamRegexp = /^\\[?(.*?)\\]?$/;\nvar filterEscapeRegexp = /[,]/;\nvar whichCache = {};\n\n/**\n * Parse progress line from ffmpeg stderr\n *\n * @param {String} line progress line\n * @return progress object\n * @private\n */\nfunction parseProgressLine(line) {\n  var progress = {};\n\n  // Remove all spaces after = and trim\n  line  = line.replace(/=\\s+/g, '=').trim();\n  var progressParts = line.split(' ');\n\n  // Split every progress part by \"=\" to get key and value\n  for(var i = 0; i < progressParts.length; i++) {\n    var progressSplit = progressParts[i].split('=', 2);\n    var key = progressSplit[0];\n    var value = progressSplit[1];\n\n    // This is not a progress line\n    if(typeof value === 'undefined')\n      return null;\n\n    progress[key] = value;\n  }\n\n  return progress;\n}\n\n\nvar utils = module.exports = {\n  isWindows: isWindows,\n  streamRegexp: streamRegexp,\n\n\n  /**\n   * Copy an object keys into another one\n   *\n   * @param {Object} source source object\n   * @param {Object} dest destination object\n   * @private\n   */\n  copy: function(source, dest) {\n    Object.keys(source).forEach(function(key) {\n      dest[key] = source[key];\n    });\n  },\n\n\n  /**\n   * Create an argument list\n   *\n   * Returns a function that adds new arguments to the list.\n   * It also has the following methods:\n   * - clear() empties the argument list\n   * - get() returns the argument list\n   * - find(arg, count) finds 'arg' in the list and return the following 'count' items, or undefined if not found\n   * - remove(arg, count) remove 'arg' in the list as well as the following 'count' items\n   *\n   * @private\n   */\n  args: function() {\n    var list = [];\n\n    // Append argument(s) to the list\n    var argfunc = function() {\n      if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        list = list.concat(arguments[0]);\n      } else {\n        list = list.concat([].slice.call(arguments));\n      }\n    };\n\n    // Clear argument list\n    argfunc.clear = function() {\n      list = [];\n    };\n\n    // Return argument list\n    argfunc.get = function() {\n      return list;\n    };\n\n    // Find argument 'arg' in list, and if found, return an array of the 'count' items that follow it\n    argfunc.find = function(arg, count) {\n      var index = list.indexOf(arg);\n      if (index !== -1) {\n        return list.slice(index + 1, index + 1 + (count || 0));\n      }\n    };\n\n    // Find argument 'arg' in list, and if found, remove it as well as the 'count' items that follow it\n    argfunc.remove = function(arg, count) {\n      var index = list.indexOf(arg);\n      if (index !== -1) {\n        list.splice(index, (count || 0) + 1);\n      }\n    };\n\n    // Clone argument list\n    argfunc.clone = function() {\n      var cloned = utils.args();\n      cloned(list);\n      return cloned;\n    };\n\n    return argfunc;\n  },\n\n\n  /**\n   * Generate filter strings\n   *\n   * @param {String[]|Object[]} filters filter specifications. When using objects,\n   *   each must have the following properties:\n   * @param {String} filters.filter filter name\n   * @param {String|Array} [filters.inputs] (array of) input stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically choosing the first unused matching streams\n   * @param {String|Array} [filters.outputs] (array of) output stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically assigning the output to the output file\n   * @param {Object|String|Array} [filters.options] filter options, can be omitted to not set any options\n   * @return String[]\n   * @private\n   */\n  makeFilterStrings: function(filters) {\n    return filters.map(function(filterSpec) {\n      if (typeof filterSpec === 'string') {\n        return filterSpec;\n      }\n\n      var filterString = '';\n\n      // Filter string format is:\n      // [input1][input2]...filter[output1][output2]...\n      // The 'filter' part can optionaly have arguments:\n      //   filter=arg1:arg2:arg3\n      //   filter=arg1=v1:arg2=v2:arg3=v3\n\n      // Add inputs\n      if (Array.isArray(filterSpec.inputs)) {\n        filterString += filterSpec.inputs.map(function(streamSpec) {\n          return streamSpec.replace(streamRegexp, '[$1]');\n        }).join('');\n      } else if (typeof filterSpec.inputs === 'string') {\n        filterString += filterSpec.inputs.replace(streamRegexp, '[$1]');\n      }\n\n      // Add filter\n      filterString += filterSpec.filter;\n\n      // Add options\n      if (filterSpec.options) {\n        if (typeof filterSpec.options === 'string' || typeof filterSpec.options === 'number') {\n          // Option string\n          filterString += '=' + filterSpec.options;\n        } else if (Array.isArray(filterSpec.options)) {\n          // Option array (unnamed options)\n          filterString += '=' + filterSpec.options.map(function(option) {\n            if (typeof option === 'string' && option.match(filterEscapeRegexp)) {\n              return '\\'' + option + '\\'';\n            } else {\n              return option;\n            }\n          }).join(':');\n        } else if (Object.keys(filterSpec.options).length) {\n          // Option object (named options)\n          filterString += '=' + Object.keys(filterSpec.options).map(function(option) {\n            var value = filterSpec.options[option];\n\n            if (typeof value === 'string' && value.match(filterEscapeRegexp)) {\n              value = '\\'' + value + '\\'';\n            }\n\n            return option + '=' + value;\n          }).join(':');\n        }\n      }\n\n      // Add outputs\n      if (Array.isArray(filterSpec.outputs)) {\n        filterString += filterSpec.outputs.map(function(streamSpec) {\n          return streamSpec.replace(streamRegexp, '[$1]');\n        }).join('');\n      } else if (typeof filterSpec.outputs === 'string') {\n        filterString += filterSpec.outputs.replace(streamRegexp, '[$1]');\n      }\n\n      return filterString;\n    });\n  },\n\n\n  /**\n   * Search for an executable\n   *\n   * Uses 'which' or 'where' depending on platform\n   *\n   * @param {String} name executable name\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  which: function(name, callback) {\n    if (name in whichCache) {\n      return callback(null, whichCache[name]);\n    }\n\n    which(name, function(err, result){\n      if (err) {\n        // Treat errors as not found\n        return callback(null, whichCache[name] = '');\n      }\n      callback(null, whichCache[name] = result);\n    });\n  },\n\n\n  /**\n   * Convert a [[hh:]mm:]ss[.xxx] timemark into seconds\n   *\n   * @param {String} timemark timemark string\n   * @return Number\n   * @private\n   */\n  timemarkToSeconds: function(timemark) {\n    if (typeof timemark === 'number') {\n      return timemark;\n    }\n\n    if (timemark.indexOf(':') === -1 && timemark.indexOf('.') >= 0) {\n      return Number(timemark);\n    }\n\n    var parts = timemark.split(':');\n\n    // add seconds\n    var secs = Number(parts.pop());\n\n    if (parts.length) {\n      // add minutes\n      secs += Number(parts.pop()) * 60;\n    }\n\n    if (parts.length) {\n      // add hours\n      secs += Number(parts.pop()) * 3600;\n    }\n\n    return secs;\n  },\n\n\n  /**\n   * Extract codec data from ffmpeg stderr and emit 'codecData' event if appropriate\n   * Call it with an initially empty codec object once with each line of stderr output until it returns true\n   *\n   * @param {FfmpegCommand} command event emitter\n   * @param {String} stderrLine ffmpeg stderr output line\n   * @param {Object} codecObject object used to accumulate codec data between calls\n   * @return {Boolean} true if codec data is complete (and event was emitted), false otherwise\n   * @private\n   */\n  extractCodecData: function(command, stderrLine, codecsObject) {\n    var inputPattern = /Input #[0-9]+, ([^ ]+),/;\n    var durPattern = /Duration\\: ([^,]+)/;\n    var audioPattern = /Audio\\: (.*)/;\n    var videoPattern = /Video\\: (.*)/;\n\n    if (!('inputStack' in codecsObject)) {\n      codecsObject.inputStack = [];\n      codecsObject.inputIndex = -1;\n      codecsObject.inInput = false;\n    }\n\n    var inputStack = codecsObject.inputStack;\n    var inputIndex = codecsObject.inputIndex;\n    var inInput = codecsObject.inInput;\n\n    var format, dur, audio, video;\n\n    if (format = stderrLine.match(inputPattern)) {\n      inInput = codecsObject.inInput = true;\n      inputIndex = codecsObject.inputIndex = codecsObject.inputIndex + 1;\n\n      inputStack[inputIndex] = { format: format[1], audio: '', video: '', duration: '' };\n    } else if (inInput && (dur = stderrLine.match(durPattern))) {\n      inputStack[inputIndex].duration = dur[1];\n    } else if (inInput && (audio = stderrLine.match(audioPattern))) {\n      audio = audio[1].split(', ');\n      inputStack[inputIndex].audio = audio[0];\n      inputStack[inputIndex].audio_details = audio;\n    } else if (inInput && (video = stderrLine.match(videoPattern))) {\n      video = video[1].split(', ');\n      inputStack[inputIndex].video = video[0];\n      inputStack[inputIndex].video_details = video;\n    } else if (/Output #\\d+/.test(stderrLine)) {\n      inInput = codecsObject.inInput = false;\n    } else if (/Stream mapping:|Press (\\[q\\]|ctrl-c) to stop/.test(stderrLine)) {\n      command.emit.apply(command, ['codecData'].concat(inputStack));\n      return true;\n    }\n\n    return false;\n  },\n\n\n  /**\n   * Extract progress data from ffmpeg stderr and emit 'progress' event if appropriate\n   *\n   * @param {FfmpegCommand} command event emitter\n   * @param {String} stderrLine ffmpeg stderr data\n   * @private\n   */\n  extractProgress: function(command, stderrLine) {\n    var progress = parseProgressLine(stderrLine);\n\n    if (progress) {\n      // build progress report object\n      var ret = {\n        frames: parseInt(progress.frame, 10),\n        currentFps: parseInt(progress.fps, 10),\n        currentKbps: progress.bitrate ? parseFloat(progress.bitrate.replace('kbits/s', '')) : 0,\n        targetSize: parseInt(progress.size || progress.Lsize, 10),\n        timemark: progress.time\n      };\n\n      // calculate percent progress using duration\n      if (command._ffprobeData && command._ffprobeData.format && command._ffprobeData.format.duration) {\n        var duration = Number(command._ffprobeData.format.duration);\n        if (!isNaN(duration))\n          ret.percent = (utils.timemarkToSeconds(ret.timemark) / duration) * 100;\n      }\n      command.emit('progress', ret);\n    }\n  },\n\n\n  /**\n   * Extract error message(s) from ffmpeg stderr\n   *\n   * @param {String} stderr ffmpeg stderr data\n   * @return {String}\n   * @private\n   */\n  extractError: function(stderr) {\n    // Only return the last stderr lines that don't start with a space or a square bracket\n    return stderr.split(nlRegexp).reduce(function(messages, message) {\n      if (message.charAt(0) === ' ' || message.charAt(0) === '[') {\n        return [];\n      } else {\n        messages.push(message);\n        return messages;\n      }\n    }, []).join('\\n');\n  },\n\n\n  /**\n   * Creates a line ring buffer object with the following methods:\n   * - append(str) : appends a string or buffer\n   * - get() : returns the whole string\n   * - close() : prevents further append() calls and does a last call to callbacks\n   * - callback(cb) : calls cb for each line (incl. those already in the ring)\n   *\n   * @param {Number} maxLines maximum number of lines to store (<= 0 for unlimited)\n   */\n  linesRing: function(maxLines) {\n    var cbs = [];\n    var lines = [];\n    var current = null;\n    var closed = false\n    var max = maxLines - 1;\n\n    function emit(line) {\n      cbs.forEach(function(cb) { cb(line); });\n    }\n\n    return {\n      callback: function(cb) {\n        lines.forEach(function(l) { cb(l); });\n        cbs.push(cb);\n      },\n\n      append: function(str) {\n        if (closed) return;\n        if (str instanceof Buffer) str = '' + str;\n        if (!str || str.length === 0) return;\n\n        var newLines = str.split(nlRegexp);\n\n        if (newLines.length === 1) {\n          if (current !== null) {\n            current = current + newLines.shift();\n          } else {\n            current = newLines.shift();\n          }\n        } else {\n          if (current !== null) {\n            current = current + newLines.shift();\n            emit(current);\n            lines.push(current);\n          }\n\n          current = newLines.pop();\n\n          newLines.forEach(function(l) {\n            emit(l);\n            lines.push(l);\n          });\n\n          if (max > -1 && lines.length > max) {\n            lines.splice(0, lines.length - max);\n          }\n        }\n      },\n\n      get: function() {\n        if (current !== null) {\n          return lines.concat([current]).join('\\n');\n        } else {\n          return lines.join('\\n');\n        }\n      },\n\n      close: function() {\n        if (closed) return;\n\n        if (current !== null) {\n          emit(current);\n          lines.push(current);\n\n          if (max > -1 && lines.length > max) {\n            lines.shift();\n          }\n\n          current = null;\n        }\n\n        closed = true;\n      }\n    };\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTs7QUFFYixXQUFXLGdFQUE2QjtBQUN4QyxnQkFBZ0IsOENBQXNCO0FBQ3RDLFlBQVksbUJBQU8sQ0FBQyxrREFBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxjQUFjO0FBQzNCO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxXQUFXO0FBQzVDOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1maXJlYmFzZS1hcGkvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvdXRpbHMuanM/MjE3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzaGludCBub2RlOnRydWUqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjO1xudmFyIGlzV2luZG93cyA9IHJlcXVpcmUoJ29zJykucGxhdGZvcm0oKS5tYXRjaCgvd2luKDMyfDY0KS8pO1xudmFyIHdoaWNoID0gcmVxdWlyZSgnd2hpY2gnKTtcblxudmFyIG5sUmVnZXhwID0gL1xcclxcbnxcXHJ8XFxuL2c7XG52YXIgc3RyZWFtUmVnZXhwID0gL15cXFs/KC4qPylcXF0/JC87XG52YXIgZmlsdGVyRXNjYXBlUmVnZXhwID0gL1ssXS87XG52YXIgd2hpY2hDYWNoZSA9IHt9O1xuXG4vKipcbiAqIFBhcnNlIHByb2dyZXNzIGxpbmUgZnJvbSBmZm1wZWcgc3RkZXJyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGxpbmUgcHJvZ3Jlc3MgbGluZVxuICogQHJldHVybiBwcm9ncmVzcyBvYmplY3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUHJvZ3Jlc3NMaW5lKGxpbmUpIHtcbiAgdmFyIHByb2dyZXNzID0ge307XG5cbiAgLy8gUmVtb3ZlIGFsbCBzcGFjZXMgYWZ0ZXIgPSBhbmQgdHJpbVxuICBsaW5lICA9IGxpbmUucmVwbGFjZSgvPVxccysvZywgJz0nKS50cmltKCk7XG4gIHZhciBwcm9ncmVzc1BhcnRzID0gbGluZS5zcGxpdCgnICcpO1xuXG4gIC8vIFNwbGl0IGV2ZXJ5IHByb2dyZXNzIHBhcnQgYnkgXCI9XCIgdG8gZ2V0IGtleSBhbmQgdmFsdWVcbiAgZm9yKHZhciBpID0gMDsgaSA8IHByb2dyZXNzUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvZ3Jlc3NTcGxpdCA9IHByb2dyZXNzUGFydHNbaV0uc3BsaXQoJz0nLCAyKTtcbiAgICB2YXIga2V5ID0gcHJvZ3Jlc3NTcGxpdFswXTtcbiAgICB2YXIgdmFsdWUgPSBwcm9ncmVzc1NwbGl0WzFdO1xuXG4gICAgLy8gVGhpcyBpcyBub3QgYSBwcm9ncmVzcyBsaW5lXG4gICAgaWYodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJylcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgcHJvZ3Jlc3Nba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHByb2dyZXNzO1xufVxuXG5cbnZhciB1dGlscyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBpc1dpbmRvd3M6IGlzV2luZG93cyxcbiAgc3RyZWFtUmVnZXhwOiBzdHJlYW1SZWdleHAsXG5cblxuICAvKipcbiAgICogQ29weSBhbiBvYmplY3Qga2V5cyBpbnRvIGFub3RoZXIgb25lXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2Ugc291cmNlIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzdCBkZXN0aW5hdGlvbiBvYmplY3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvcHk6IGZ1bmN0aW9uKHNvdXJjZSwgZGVzdCkge1xuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgIGRlc3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBhcmd1bWVudCBsaXN0XG4gICAqXG4gICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFkZHMgbmV3IGFyZ3VtZW50cyB0byB0aGUgbGlzdC5cbiAgICogSXQgYWxzbyBoYXMgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICAgKiAtIGNsZWFyKCkgZW1wdGllcyB0aGUgYXJndW1lbnQgbGlzdFxuICAgKiAtIGdldCgpIHJldHVybnMgdGhlIGFyZ3VtZW50IGxpc3RcbiAgICogLSBmaW5kKGFyZywgY291bnQpIGZpbmRzICdhcmcnIGluIHRoZSBsaXN0IGFuZCByZXR1cm4gdGhlIGZvbGxvd2luZyAnY291bnQnIGl0ZW1zLCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gICAqIC0gcmVtb3ZlKGFyZywgY291bnQpIHJlbW92ZSAnYXJnJyBpbiB0aGUgbGlzdCBhcyB3ZWxsIGFzIHRoZSBmb2xsb3dpbmcgJ2NvdW50JyBpdGVtc1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXJnczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxpc3QgPSBbXTtcblxuICAgIC8vIEFwcGVuZCBhcmd1bWVudChzKSB0byB0aGUgbGlzdFxuICAgIHZhciBhcmdmdW5jID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgbGlzdCA9IGxpc3QuY29uY2F0KGFyZ3VtZW50c1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0ID0gbGlzdC5jb25jYXQoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ2xlYXIgYXJndW1lbnQgbGlzdFxuICAgIGFyZ2Z1bmMuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGxpc3QgPSBbXTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIGFyZ3VtZW50IGxpc3RcbiAgICBhcmdmdW5jLmdldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfTtcblxuICAgIC8vIEZpbmQgYXJndW1lbnQgJ2FyZycgaW4gbGlzdCwgYW5kIGlmIGZvdW5kLCByZXR1cm4gYW4gYXJyYXkgb2YgdGhlICdjb3VudCcgaXRlbXMgdGhhdCBmb2xsb3cgaXRcbiAgICBhcmdmdW5jLmZpbmQgPSBmdW5jdGlvbihhcmcsIGNvdW50KSB7XG4gICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2YoYXJnKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGxpc3Quc2xpY2UoaW5kZXggKyAxLCBpbmRleCArIDEgKyAoY291bnQgfHwgMCkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBGaW5kIGFyZ3VtZW50ICdhcmcnIGluIGxpc3QsIGFuZCBpZiBmb3VuZCwgcmVtb3ZlIGl0IGFzIHdlbGwgYXMgdGhlICdjb3VudCcgaXRlbXMgdGhhdCBmb2xsb3cgaXRcbiAgICBhcmdmdW5jLnJlbW92ZSA9IGZ1bmN0aW9uKGFyZywgY291bnQpIHtcbiAgICAgIHZhciBpbmRleCA9IGxpc3QuaW5kZXhPZihhcmcpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgKGNvdW50IHx8IDApICsgMSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIENsb25lIGFyZ3VtZW50IGxpc3RcbiAgICBhcmdmdW5jLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2xvbmVkID0gdXRpbHMuYXJncygpO1xuICAgICAgY2xvbmVkKGxpc3QpO1xuICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGFyZ2Z1bmM7XG4gIH0sXG5cblxuICAvKipcbiAgICogR2VuZXJhdGUgZmlsdGVyIHN0cmluZ3NcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmdbXXxPYmplY3RbXX0gZmlsdGVycyBmaWx0ZXIgc3BlY2lmaWNhdGlvbnMuIFdoZW4gdXNpbmcgb2JqZWN0cyxcbiAgICogICBlYWNoIG11c3QgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaWx0ZXJzLmZpbHRlciBmaWx0ZXIgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gW2ZpbHRlcnMuaW5wdXRzXSAoYXJyYXkgb2YpIGlucHV0IHN0cmVhbSBzcGVjaWZpZXIocykgZm9yIHRoZSBmaWx0ZXIsXG4gICAqICAgZGVmYXVsdHMgdG8gZmZtcGVnIGF1dG9tYXRpY2FsbHkgY2hvb3NpbmcgdGhlIGZpcnN0IHVudXNlZCBtYXRjaGluZyBzdHJlYW1zXG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbZmlsdGVycy5vdXRwdXRzXSAoYXJyYXkgb2YpIG91dHB1dCBzdHJlYW0gc3BlY2lmaWVyKHMpIGZvciB0aGUgZmlsdGVyLFxuICAgKiAgIGRlZmF1bHRzIHRvIGZmbXBlZyBhdXRvbWF0aWNhbGx5IGFzc2lnbmluZyB0aGUgb3V0cHV0IHRvIHRoZSBvdXRwdXQgZmlsZVxuICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8QXJyYXl9IFtmaWx0ZXJzLm9wdGlvbnNdIGZpbHRlciBvcHRpb25zLCBjYW4gYmUgb21pdHRlZCB0byBub3Qgc2V0IGFueSBvcHRpb25zXG4gICAqIEByZXR1cm4gU3RyaW5nW11cbiAgICogQHByaXZhdGVcbiAgICovXG4gIG1ha2VGaWx0ZXJTdHJpbmdzOiBmdW5jdGlvbihmaWx0ZXJzKSB7XG4gICAgcmV0dXJuIGZpbHRlcnMubWFwKGZ1bmN0aW9uKGZpbHRlclNwZWMpIHtcbiAgICAgIGlmICh0eXBlb2YgZmlsdGVyU3BlYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlclNwZWM7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaWx0ZXJTdHJpbmcgPSAnJztcblxuICAgICAgLy8gRmlsdGVyIHN0cmluZyBmb3JtYXQgaXM6XG4gICAgICAvLyBbaW5wdXQxXVtpbnB1dDJdLi4uZmlsdGVyW291dHB1dDFdW291dHB1dDJdLi4uXG4gICAgICAvLyBUaGUgJ2ZpbHRlcicgcGFydCBjYW4gb3B0aW9uYWx5IGhhdmUgYXJndW1lbnRzOlxuICAgICAgLy8gICBmaWx0ZXI9YXJnMTphcmcyOmFyZzNcbiAgICAgIC8vICAgZmlsdGVyPWFyZzE9djE6YXJnMj12MjphcmczPXYzXG5cbiAgICAgIC8vIEFkZCBpbnB1dHNcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlclNwZWMuaW5wdXRzKSkge1xuICAgICAgICBmaWx0ZXJTdHJpbmcgKz0gZmlsdGVyU3BlYy5pbnB1dHMubWFwKGZ1bmN0aW9uKHN0cmVhbVNwZWMpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtU3BlYy5yZXBsYWNlKHN0cmVhbVJlZ2V4cCwgJ1skMV0nKTtcbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWx0ZXJTcGVjLmlucHV0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZmlsdGVyU3RyaW5nICs9IGZpbHRlclNwZWMuaW5wdXRzLnJlcGxhY2Uoc3RyZWFtUmVnZXhwLCAnWyQxXScpO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgZmlsdGVyXG4gICAgICBmaWx0ZXJTdHJpbmcgKz0gZmlsdGVyU3BlYy5maWx0ZXI7XG5cbiAgICAgIC8vIEFkZCBvcHRpb25zXG4gICAgICBpZiAoZmlsdGVyU3BlYy5vcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsdGVyU3BlYy5vcHRpb25zID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZmlsdGVyU3BlYy5vcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIC8vIE9wdGlvbiBzdHJpbmdcbiAgICAgICAgICBmaWx0ZXJTdHJpbmcgKz0gJz0nICsgZmlsdGVyU3BlYy5vcHRpb25zO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyU3BlYy5vcHRpb25zKSkge1xuICAgICAgICAgIC8vIE9wdGlvbiBhcnJheSAodW5uYW1lZCBvcHRpb25zKVxuICAgICAgICAgIGZpbHRlclN0cmluZyArPSAnPScgKyBmaWx0ZXJTcGVjLm9wdGlvbnMubWFwKGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdzdHJpbmcnICYmIG9wdGlvbi5tYXRjaChmaWx0ZXJFc2NhcGVSZWdleHApKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnXFwnJyArIG9wdGlvbiArICdcXCcnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5qb2luKCc6Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LmtleXMoZmlsdGVyU3BlYy5vcHRpb25zKS5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBPcHRpb24gb2JqZWN0IChuYW1lZCBvcHRpb25zKVxuICAgICAgICAgIGZpbHRlclN0cmluZyArPSAnPScgKyBPYmplY3Qua2V5cyhmaWx0ZXJTcGVjLm9wdGlvbnMpLm1hcChmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGZpbHRlclNwZWMub3B0aW9uc1tvcHRpb25dO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5tYXRjaChmaWx0ZXJFc2NhcGVSZWdleHApKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gJ1xcJycgKyB2YWx1ZSArICdcXCcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uICsgJz0nICsgdmFsdWU7XG4gICAgICAgICAgfSkuam9pbignOicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBvdXRwdXRzXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXJTcGVjLm91dHB1dHMpKSB7XG4gICAgICAgIGZpbHRlclN0cmluZyArPSBmaWx0ZXJTcGVjLm91dHB1dHMubWFwKGZ1bmN0aW9uKHN0cmVhbVNwZWMpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtU3BlYy5yZXBsYWNlKHN0cmVhbVJlZ2V4cCwgJ1skMV0nKTtcbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWx0ZXJTcGVjLm91dHB1dHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZpbHRlclN0cmluZyArPSBmaWx0ZXJTcGVjLm91dHB1dHMucmVwbGFjZShzdHJlYW1SZWdleHAsICdbJDFdJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaWx0ZXJTdHJpbmc7XG4gICAgfSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogU2VhcmNoIGZvciBhbiBleGVjdXRhYmxlXG4gICAqXG4gICAqIFVzZXMgJ3doaWNoJyBvciAnd2hlcmUnIGRlcGVuZGluZyBvbiBwbGF0Zm9ybVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBleGVjdXRhYmxlIG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgd2l0aCBzaWduYXR1cmUgKGVyciwgcGF0aClcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHdoaWNoOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICAgIGlmIChuYW1lIGluIHdoaWNoQ2FjaGUpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB3aGljaENhY2hlW25hbWVdKTtcbiAgICB9XG5cbiAgICB3aGljaChuYW1lLCBmdW5jdGlvbihlcnIsIHJlc3VsdCl7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIC8vIFRyZWF0IGVycm9ycyBhcyBub3QgZm91bmRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHdoaWNoQ2FjaGVbbmFtZV0gPSAnJyk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCB3aGljaENhY2hlW25hbWVdID0gcmVzdWx0KTtcbiAgICB9KTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgW1toaDpdbW06XXNzWy54eHhdIHRpbWVtYXJrIGludG8gc2Vjb25kc1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGltZW1hcmsgdGltZW1hcmsgc3RyaW5nXG4gICAqIEByZXR1cm4gTnVtYmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aW1lbWFya1RvU2Vjb25kczogZnVuY3Rpb24odGltZW1hcmspIHtcbiAgICBpZiAodHlwZW9mIHRpbWVtYXJrID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHRpbWVtYXJrO1xuICAgIH1cblxuICAgIGlmICh0aW1lbWFyay5pbmRleE9mKCc6JykgPT09IC0xICYmIHRpbWVtYXJrLmluZGV4T2YoJy4nKSA+PSAwKSB7XG4gICAgICByZXR1cm4gTnVtYmVyKHRpbWVtYXJrKTtcbiAgICB9XG5cbiAgICB2YXIgcGFydHMgPSB0aW1lbWFyay5zcGxpdCgnOicpO1xuXG4gICAgLy8gYWRkIHNlY29uZHNcbiAgICB2YXIgc2VjcyA9IE51bWJlcihwYXJ0cy5wb3AoKSk7XG5cbiAgICBpZiAocGFydHMubGVuZ3RoKSB7XG4gICAgICAvLyBhZGQgbWludXRlc1xuICAgICAgc2VjcyArPSBOdW1iZXIocGFydHMucG9wKCkpICogNjA7XG4gICAgfVxuXG4gICAgaWYgKHBhcnRzLmxlbmd0aCkge1xuICAgICAgLy8gYWRkIGhvdXJzXG4gICAgICBzZWNzICs9IE51bWJlcihwYXJ0cy5wb3AoKSkgKiAzNjAwO1xuICAgIH1cblxuICAgIHJldHVybiBzZWNzO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgY29kZWMgZGF0YSBmcm9tIGZmbXBlZyBzdGRlcnIgYW5kIGVtaXQgJ2NvZGVjRGF0YScgZXZlbnQgaWYgYXBwcm9wcmlhdGVcbiAgICogQ2FsbCBpdCB3aXRoIGFuIGluaXRpYWxseSBlbXB0eSBjb2RlYyBvYmplY3Qgb25jZSB3aXRoIGVhY2ggbGluZSBvZiBzdGRlcnIgb3V0cHV0IHVudGlsIGl0IHJldHVybnMgdHJ1ZVxuICAgKlxuICAgKiBAcGFyYW0ge0ZmbXBlZ0NvbW1hbmR9IGNvbW1hbmQgZXZlbnQgZW1pdHRlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RkZXJyTGluZSBmZm1wZWcgc3RkZXJyIG91dHB1dCBsaW5lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb2RlY09iamVjdCBvYmplY3QgdXNlZCB0byBhY2N1bXVsYXRlIGNvZGVjIGRhdGEgYmV0d2VlbiBjYWxsc1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGNvZGVjIGRhdGEgaXMgY29tcGxldGUgKGFuZCBldmVudCB3YXMgZW1pdHRlZCksIGZhbHNlIG90aGVyd2lzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZXh0cmFjdENvZGVjRGF0YTogZnVuY3Rpb24oY29tbWFuZCwgc3RkZXJyTGluZSwgY29kZWNzT2JqZWN0KSB7XG4gICAgdmFyIGlucHV0UGF0dGVybiA9IC9JbnB1dCAjWzAtOV0rLCAoW14gXSspLC87XG4gICAgdmFyIGR1clBhdHRlcm4gPSAvRHVyYXRpb25cXDogKFteLF0rKS87XG4gICAgdmFyIGF1ZGlvUGF0dGVybiA9IC9BdWRpb1xcOiAoLiopLztcbiAgICB2YXIgdmlkZW9QYXR0ZXJuID0gL1ZpZGVvXFw6ICguKikvO1xuXG4gICAgaWYgKCEoJ2lucHV0U3RhY2snIGluIGNvZGVjc09iamVjdCkpIHtcbiAgICAgIGNvZGVjc09iamVjdC5pbnB1dFN0YWNrID0gW107XG4gICAgICBjb2RlY3NPYmplY3QuaW5wdXRJbmRleCA9IC0xO1xuICAgICAgY29kZWNzT2JqZWN0LmluSW5wdXQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaW5wdXRTdGFjayA9IGNvZGVjc09iamVjdC5pbnB1dFN0YWNrO1xuICAgIHZhciBpbnB1dEluZGV4ID0gY29kZWNzT2JqZWN0LmlucHV0SW5kZXg7XG4gICAgdmFyIGluSW5wdXQgPSBjb2RlY3NPYmplY3QuaW5JbnB1dDtcblxuICAgIHZhciBmb3JtYXQsIGR1ciwgYXVkaW8sIHZpZGVvO1xuXG4gICAgaWYgKGZvcm1hdCA9IHN0ZGVyckxpbmUubWF0Y2goaW5wdXRQYXR0ZXJuKSkge1xuICAgICAgaW5JbnB1dCA9IGNvZGVjc09iamVjdC5pbklucHV0ID0gdHJ1ZTtcbiAgICAgIGlucHV0SW5kZXggPSBjb2RlY3NPYmplY3QuaW5wdXRJbmRleCA9IGNvZGVjc09iamVjdC5pbnB1dEluZGV4ICsgMTtcblxuICAgICAgaW5wdXRTdGFja1tpbnB1dEluZGV4XSA9IHsgZm9ybWF0OiBmb3JtYXRbMV0sIGF1ZGlvOiAnJywgdmlkZW86ICcnLCBkdXJhdGlvbjogJycgfTtcbiAgICB9IGVsc2UgaWYgKGluSW5wdXQgJiYgKGR1ciA9IHN0ZGVyckxpbmUubWF0Y2goZHVyUGF0dGVybikpKSB7XG4gICAgICBpbnB1dFN0YWNrW2lucHV0SW5kZXhdLmR1cmF0aW9uID0gZHVyWzFdO1xuICAgIH0gZWxzZSBpZiAoaW5JbnB1dCAmJiAoYXVkaW8gPSBzdGRlcnJMaW5lLm1hdGNoKGF1ZGlvUGF0dGVybikpKSB7XG4gICAgICBhdWRpbyA9IGF1ZGlvWzFdLnNwbGl0KCcsICcpO1xuICAgICAgaW5wdXRTdGFja1tpbnB1dEluZGV4XS5hdWRpbyA9IGF1ZGlvWzBdO1xuICAgICAgaW5wdXRTdGFja1tpbnB1dEluZGV4XS5hdWRpb19kZXRhaWxzID0gYXVkaW87XG4gICAgfSBlbHNlIGlmIChpbklucHV0ICYmICh2aWRlbyA9IHN0ZGVyckxpbmUubWF0Y2godmlkZW9QYXR0ZXJuKSkpIHtcbiAgICAgIHZpZGVvID0gdmlkZW9bMV0uc3BsaXQoJywgJyk7XG4gICAgICBpbnB1dFN0YWNrW2lucHV0SW5kZXhdLnZpZGVvID0gdmlkZW9bMF07XG4gICAgICBpbnB1dFN0YWNrW2lucHV0SW5kZXhdLnZpZGVvX2RldGFpbHMgPSB2aWRlbztcbiAgICB9IGVsc2UgaWYgKC9PdXRwdXQgI1xcZCsvLnRlc3Qoc3RkZXJyTGluZSkpIHtcbiAgICAgIGluSW5wdXQgPSBjb2RlY3NPYmplY3QuaW5JbnB1dCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoL1N0cmVhbSBtYXBwaW5nOnxQcmVzcyAoXFxbcVxcXXxjdHJsLWMpIHRvIHN0b3AvLnRlc3Qoc3RkZXJyTGluZSkpIHtcbiAgICAgIGNvbW1hbmQuZW1pdC5hcHBseShjb21tYW5kLCBbJ2NvZGVjRGF0YSddLmNvbmNhdChpbnB1dFN0YWNrKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cblxuICAvKipcbiAgICogRXh0cmFjdCBwcm9ncmVzcyBkYXRhIGZyb20gZmZtcGVnIHN0ZGVyciBhbmQgZW1pdCAncHJvZ3Jlc3MnIGV2ZW50IGlmIGFwcHJvcHJpYXRlXG4gICAqXG4gICAqIEBwYXJhbSB7RmZtcGVnQ29tbWFuZH0gY29tbWFuZCBldmVudCBlbWl0dGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdGRlcnJMaW5lIGZmbXBlZyBzdGRlcnIgZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZXh0cmFjdFByb2dyZXNzOiBmdW5jdGlvbihjb21tYW5kLCBzdGRlcnJMaW5lKSB7XG4gICAgdmFyIHByb2dyZXNzID0gcGFyc2VQcm9ncmVzc0xpbmUoc3RkZXJyTGluZSk7XG5cbiAgICBpZiAocHJvZ3Jlc3MpIHtcbiAgICAgIC8vIGJ1aWxkIHByb2dyZXNzIHJlcG9ydCBvYmplY3RcbiAgICAgIHZhciByZXQgPSB7XG4gICAgICAgIGZyYW1lczogcGFyc2VJbnQocHJvZ3Jlc3MuZnJhbWUsIDEwKSxcbiAgICAgICAgY3VycmVudEZwczogcGFyc2VJbnQocHJvZ3Jlc3MuZnBzLCAxMCksXG4gICAgICAgIGN1cnJlbnRLYnBzOiBwcm9ncmVzcy5iaXRyYXRlID8gcGFyc2VGbG9hdChwcm9ncmVzcy5iaXRyYXRlLnJlcGxhY2UoJ2tiaXRzL3MnLCAnJykpIDogMCxcbiAgICAgICAgdGFyZ2V0U2l6ZTogcGFyc2VJbnQocHJvZ3Jlc3Muc2l6ZSB8fCBwcm9ncmVzcy5Mc2l6ZSwgMTApLFxuICAgICAgICB0aW1lbWFyazogcHJvZ3Jlc3MudGltZVxuICAgICAgfTtcblxuICAgICAgLy8gY2FsY3VsYXRlIHBlcmNlbnQgcHJvZ3Jlc3MgdXNpbmcgZHVyYXRpb25cbiAgICAgIGlmIChjb21tYW5kLl9mZnByb2JlRGF0YSAmJiBjb21tYW5kLl9mZnByb2JlRGF0YS5mb3JtYXQgJiYgY29tbWFuZC5fZmZwcm9iZURhdGEuZm9ybWF0LmR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IE51bWJlcihjb21tYW5kLl9mZnByb2JlRGF0YS5mb3JtYXQuZHVyYXRpb24pO1xuICAgICAgICBpZiAoIWlzTmFOKGR1cmF0aW9uKSlcbiAgICAgICAgICByZXQucGVyY2VudCA9ICh1dGlscy50aW1lbWFya1RvU2Vjb25kcyhyZXQudGltZW1hcmspIC8gZHVyYXRpb24pICogMTAwO1xuICAgICAgfVxuICAgICAgY29tbWFuZC5lbWl0KCdwcm9ncmVzcycsIHJldCk7XG4gICAgfVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgZXJyb3IgbWVzc2FnZShzKSBmcm9tIGZmbXBlZyBzdGRlcnJcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ZGVyciBmZm1wZWcgc3RkZXJyIGRhdGFcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZXh0cmFjdEVycm9yOiBmdW5jdGlvbihzdGRlcnIpIHtcbiAgICAvLyBPbmx5IHJldHVybiB0aGUgbGFzdCBzdGRlcnIgbGluZXMgdGhhdCBkb24ndCBzdGFydCB3aXRoIGEgc3BhY2Ugb3IgYSBzcXVhcmUgYnJhY2tldFxuICAgIHJldHVybiBzdGRlcnIuc3BsaXQobmxSZWdleHApLnJlZHVjZShmdW5jdGlvbihtZXNzYWdlcywgbWVzc2FnZSkge1xuICAgICAgaWYgKG1lc3NhZ2UuY2hhckF0KDApID09PSAnICcgfHwgbWVzc2FnZS5jaGFyQXQoMCkgPT09ICdbJykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgICB9XG4gICAgfSwgW10pLmpvaW4oJ1xcbicpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBsaW5lIHJpbmcgYnVmZmVyIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAgICogLSBhcHBlbmQoc3RyKSA6IGFwcGVuZHMgYSBzdHJpbmcgb3IgYnVmZmVyXG4gICAqIC0gZ2V0KCkgOiByZXR1cm5zIHRoZSB3aG9sZSBzdHJpbmdcbiAgICogLSBjbG9zZSgpIDogcHJldmVudHMgZnVydGhlciBhcHBlbmQoKSBjYWxscyBhbmQgZG9lcyBhIGxhc3QgY2FsbCB0byBjYWxsYmFja3NcbiAgICogLSBjYWxsYmFjayhjYikgOiBjYWxscyBjYiBmb3IgZWFjaCBsaW5lIChpbmNsLiB0aG9zZSBhbHJlYWR5IGluIHRoZSByaW5nKVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbWF4TGluZXMgbWF4aW11bSBudW1iZXIgb2YgbGluZXMgdG8gc3RvcmUgKDw9IDAgZm9yIHVubGltaXRlZClcbiAgICovXG4gIGxpbmVzUmluZzogZnVuY3Rpb24obWF4TGluZXMpIHtcbiAgICB2YXIgY2JzID0gW107XG4gICAgdmFyIGxpbmVzID0gW107XG4gICAgdmFyIGN1cnJlbnQgPSBudWxsO1xuICAgIHZhciBjbG9zZWQgPSBmYWxzZVxuICAgIHZhciBtYXggPSBtYXhMaW5lcyAtIDE7XG5cbiAgICBmdW5jdGlvbiBlbWl0KGxpbmUpIHtcbiAgICAgIGNicy5mb3JFYWNoKGZ1bmN0aW9uKGNiKSB7IGNiKGxpbmUpOyB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24obCkgeyBjYihsKTsgfSk7XG4gICAgICAgIGNicy5wdXNoKGNiKTtcbiAgICAgIH0sXG5cbiAgICAgIGFwcGVuZDogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIGlmIChjbG9zZWQpIHJldHVybjtcbiAgICAgICAgaWYgKHN0ciBpbnN0YW5jZW9mIEJ1ZmZlcikgc3RyID0gJycgKyBzdHI7XG4gICAgICAgIGlmICghc3RyIHx8IHN0ci5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgICB2YXIgbmV3TGluZXMgPSBzdHIuc3BsaXQobmxSZWdleHApO1xuXG4gICAgICAgIGlmIChuZXdMaW5lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQgKyBuZXdMaW5lcy5zaGlmdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gbmV3TGluZXMuc2hpZnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50ICsgbmV3TGluZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIGVtaXQoY3VycmVudCk7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnQgPSBuZXdMaW5lcy5wb3AoKTtcblxuICAgICAgICAgIG5ld0xpbmVzLmZvckVhY2goZnVuY3Rpb24obCkge1xuICAgICAgICAgICAgZW1pdChsKTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2gobCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAobWF4ID4gLTEgJiYgbGluZXMubGVuZ3RoID4gbWF4KSB7XG4gICAgICAgICAgICBsaW5lcy5zcGxpY2UoMCwgbGluZXMubGVuZ3RoIC0gbWF4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGxpbmVzLmNvbmNhdChbY3VycmVudF0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoY2xvc2VkKSByZXR1cm47XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBlbWl0KGN1cnJlbnQpO1xuICAgICAgICAgIGxpbmVzLnB1c2goY3VycmVudCk7XG5cbiAgICAgICAgICBpZiAobWF4ID4gLTEgJiYgbGluZXMubGVuZ3RoID4gbWF4KSB7XG4gICAgICAgICAgICBsaW5lcy5zaGlmdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\n");

/***/ })

};
;